<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zaizizaizai</title>
  
  <subtitle>a dream of a child</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zaizizaizai.github.io/"/>
  <updated>2018-06-06T01:43:47.190Z</updated>
  <id>https://zaizizaizai.github.io/</id>
  
  <author>
    <name>pinocchio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018.06.04</title>
    <link href="https://zaizizaizai.github.io/2018/06/06/2018-06-04/"/>
    <id>https://zaizizaizai.github.io/2018/06/06/2018-06-04/</id>
    <published>2018-06-06T01:41:05.000Z</published>
    <updated>2018-06-06T01:43:47.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="看山是山，看山不是山，看山还是山，为什么越看越伤心呢？"><a href="#看山是山，看山不是山，看山还是山，为什么越看越伤心呢？" class="headerlink" title="看山是山，看山不是山，看山还是山，为什么越看越伤心呢？"></a>看山是山，看山不是山，看山还是山，为什么越看越伤心呢？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot;&gt;&lt;a href=&quot;#看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot; class=&quot;headerlink&quot; title=&quot;看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot;&gt;&lt;/a&gt;看山是山，
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>2018.03.23</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/2018-03-23/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/2018-03-23/</id>
    <published>2018-03-25T10:30:04.000Z</published>
    <updated>2018-03-25T10:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>过了一会，青年人把右臂举起，把手抚上石碑，开口了：</p><p>　　“法师认为，是法源寺的名字好呢，还是悯忠寺好？”</p><p>　　和尚对突如其来的问话，没有任何惊异。顺口就答了：</p><p>　　“从对人的意义说，是法源寺好；从对鬼的意义说，是悯忠寺好；从对出家人的意义说，两个都好。”</p><p>　　青年人会心地一笑，法师也笑着。</p><p>　　“我觉得还是悯忠寺好，因为人早晚都要变成鬼。”</p><p>　　“寺庙的用意并不完全为了超度死者，也是为了觉悟生者。”</p><p>　　“但是悯忠寺盖的时候，却是为了超度死者。”</p><p>　　“超度死者的目的，除了为了死者以外，也为了生者。唐太宗当年把阵亡的两千人，都埋在一起，又盖这座悯忠寺以慰亡魂，也未尝不是给生者看。”<br>“对唐太宗说来，唐太宗杀了他弟弟元吉，又霸占了弟媳妇杨氏。后来，他把弟弟追封为巢刺王，把杨氏封为巢刺王妃。最妙的是，他把他跟弟媳妇奸生的儿子出继给死去的弟弟，而弟弟的五个儿子，却统统被他杀掉。照法师说来，这也是以慰亡魂，给生者看？”</p><p>　　“也不能说不是。”和尚不以为奇。“在中国帝王中，像有唐太宗那么多优点的人很少，唐太宗许多优点都考第一，当然他也有考第一的缺点，他在父子兄弟之间，惭德太多。有些是逼得不做不行；有些却不该做他做了。做过以后，他的优点又来收场，我认为他在事情过后，收场收得意味很深。盖这悯忠寺，就是证明。他肯盖这悯忠寺，在我们出家人看来，是种善因。”</p><p>　　“会不会是一种伪善？”</p><p>　　“判定善的真伪，要从他的做出来的看。做出来的是善，我们就与人为善，认为那是善；如果他没做，只是他想去行善。说去行善，就都不算。我认为唐太宗做了，不管是后悔后做了、还是忏悔后做了、还是为了女人寡妇做了、还是为了收揽民心做了，不管是什么理由，他做了。你就很难说他是伪善。只能说他动机复杂、纯度不够而已。”</p><p>　　“我所了解的善，跟法师不一样。谈到一个人的善，要追问到他本来的心迹，要看他心迹是不是为善。存心善，才算善，哪怕是转出恶果，仍旧无损于他的善行；相反的，存心恶，便算恶，尽管转出善果，仍旧不能不说是伪善；进一步说，不但存心恶如此，就便是存心不恶，但并没存心为善，转出善果，也不能说是善行；更进一步说，存心不善不恶，但若有心为善，转出的善果，也是不值得称道的，这就是俗话所说的‘有心为善，虽善不赏；无心为恶，虽恶不罚’。上面所说，重点是根本这个人要存心善，善是自然而然自内发出，而不是有心为善，有心为善是有目的的，跟善的本质有冲突，善的本质是没有别的目的的，善本身就是目的。至于无心为善，更不足道，只是碰巧有了善果而已，但比起存心为恶却反转出善果来的，当然也高明很多。天下最荒谬的事莫过于存心为恶，反而转出善果，这个作恶的人，反倒因此受人崇拜歌颂，这太不公道了！所以，唐太宗所作所为，是一种伪善。”</p><p>　　“刚才我说过，判定善的真伪，要从一个人做出来的看，而不是想出来的说出来的看。这个标准，也许不理想，可是它很客观。你口口声声要问一个人本来的心迹，你悬格太高了，人是多么复杂的动物，他的心迹又多么复杂，人的心迹，不是那么单纯的，也不是非善即恶的，事实上，它是善恶混合的、善恶共处的，有好的、有坏的、有明的、有暗的、有高的、有低的、有为人的、有为我的。而这些好坏明暗高低人我的对立，在一个人心迹里，也不一定是对立状态，而是混成一团状态，连他自己也弄不太清楚。心迹既是这么不可捉摸的抽象标准，你怎么能用这种标准来评定他存心善、还是存心不善不恶、还是存心恶、还是有心为善呢？心迹状态是一团乱麻，是他本人和别人都难分得一清二楚的啊。所以，我的办法是回过头来，以做出来的做标准，来知人论世、来以实践检验真理。我的标准也许比较宽，宽得把你所指的存心善以外的三类——就是存心不善不恶、有心为善、甚至是存心恶的三类都包括进去了，只要这四类都有善行表现出来，不管是有意的无意的好意的恶意的，只要有善行，一律加以肯定。所以我才说，唐太宗肯盖这个悯忠寺，是种善因。”</p><p>　　“法师真是佛心，喜欢与人为善，到了这样从宽录取的程度。”</p><p>　　“宽是宽了一点，但也不是不讲究分寸。像我说唐太宗盖这个悯忠寺，是种善因，并不是做善行，这就是分寸。”</p><p>　　“照法师这么说来，盖了这么个大庙都不算是善行，只算是善因，那么怎么才算是善行？”</p><p>　　“这要看对谁来说。如果某甲有一两黄金，他出九钱盖庙，哪怕只能盖一砖一瓦，这是善行；如果某乙有十万两黄金，他出一千两盖了整个的庙，他的善行，比起来像善因，很难算是善行。”</p><p>　　“所以唐太宗不算？”</p><p>　　“唐太宗身为皇帝，当然不止是十万两的某乙，他盖悯忠寺，不能算是善行。何况，他有权力根本就不使盖悯忠寺的理由发生，那就是何必出兵打高丽？不打高丽，就不会死人，就无忠可悯，所以，唐太宗如根本不打高丽，那才算是他的善行。”</p><p>　　“照法师这个因人而异的标准，我发现法师悬的格，简直比我还高。唐朝当时受到四边民族的压力，唐太宗不动手打别人，别人大了，就会打他，如今你法师竟用的是人类和平的标准、不杀不伐的佛教标准，来要求一个十九岁起兵、二十四岁灭群雄、二十九岁就君临天下的大人物，法师未免太苛求了。”</p><p>　　“你说的不无道理，我悬格太高了。可是，大人物犯的错，都是大错。唐太宗若不是大人物，我也不会这么苛求了。因为，从历史上看，当时高丽并没有威胁到唐朝，高丽虽然欺负它南边的新罗，但对唐朝，还受唐朝的封、还对唐朝入贡，唐太宗打它没成功，盖悯忠寺回来，第二年高丽还遣使来谢罪、还送了唐太宗两个高丽美人。这些行为，都说明了你说的唐太宗不动手打别人，别人大了，就会打他的威胁性，至少对高丽来说，是担心得太过分。我认为唐太宗打高丽，主要的原因是他的‘天可汗’思想作祟，要君临天下，当然也就谈不到爱和平了。我承认，要求唐太宗那样雄才大略的皇帝不走武力征服别人的路线，那反倒不近人情了。”</p><p>　　“这么说来，法师还是肯定唐太宗了？”</p><p>　　“当然肯定，任何人做出来的善我都肯定，而不以人废善。至于想去行善、说去行善，那只是一念之善，并没有行，那是不算的。善和行善是两回事，善不行，不算是善。”</p><p>　　“法师这样注意行、注意做、注意以实践检验真理，这种思想，跟孟子以至王阳明的，完全不一样。”</p><p>“是不一样。孟子认为发善情就是善，所谓‘乃若其情，则可以谓善矣’；王阳明认为在内心就是善，所谓‘至善只是此心纯乎天理之极便是’，这些抽象的检定善的标准，我是不承认的。善必须要行，藏在心里是不行的。”</p><p>　　“法师这种见解，我听了很奇怪，太不唯心了，佛教是讲唯心的。”青年人露出一点取笑的神气。</p><p>　　和尚好像有一点为难，想了一下，最后说：</p><p>　　“真正的唯心是破除我执，释迦牟尼与何罗逻仙人辩道时说：‘若能除我及我执，一切尽舍，是名真解脱。’我执就是主观的心，善如果没行出来，只凭主观的心认为已经是善就善了，这是唯心的魔道，不是唯心的正道。唯心的正道是破除这种凭想凭说就算行了善的魔道。真正的唯心在告诉人什么是唯心的限度、什么是光凭唯心做不到的。比如说吃饭，必须吃，想吃和说吃并不算吃，一定要有吃的行为；善也是这类性质，善要有行为，没有行为的善才真是伪善。”</p><p>　　“法师这一番话，我很佩服。只是最后免不掉有点奇怪，奇怪这些话，不像是一般佛门弟子的口气、不像是出家人的口气。我说这话，是佩服，不是挖苦，请法师别见怪。”</p><p>　　和尚笑起来，又合十为礼。然后伸出右手，向庙门外面指一指：</p><p>　　“现在北京城都在过年，大年初二，外面正在赶热闹，而你这位年轻朋友居然有这么大的定力，不怕寂寞，一个人，到这冷清清的千年老庙来研究古碑龟趺，一看就不是凡品。”</p><p>——《北京法源寺》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过了一会，青年人把右臂举起，把手抚上石碑，开口了：&lt;/p&gt;
&lt;p&gt;　　“法师认为，是法源寺的名字好呢，还是悯忠寺好？”&lt;/p&gt;
&lt;p&gt;　　和尚对突如其来的问话，没有任何惊异。顺口就答了：&lt;/p&gt;
&lt;p&gt;　　“从对人的意义说，是法源寺好；从对鬼的意义说，是悯忠寺好；从对出家人
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>2018.03.20</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/2018-03-20/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/2018-03-20/</id>
    <published>2018-03-25T10:26:21.000Z</published>
    <updated>2018-03-25T10:28:03.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我试着远离、忘记高中，也试着找回"><a href="#我试着远离、忘记高中，也试着找回" class="headerlink" title="我试着远离、忘记高中，也试着找回"></a>我试着远离、忘记高中，也试着找回</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我试着远离、忘记高中，也试着找回&quot;&gt;&lt;a href=&quot;#我试着远离、忘记高中，也试着找回&quot; class=&quot;headerlink&quot; title=&quot;我试着远离、忘记高中，也试着找回&quot;&gt;&lt;/a&gt;我试着远离、忘记高中，也试着找回&lt;/h3&gt;
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>2018.03.08</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/2018-03-08/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/2018-03-08/</id>
    <published>2018-03-25T10:24:04.000Z</published>
    <updated>2018-03-25T10:24:52.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Talk-is-cheap-show-me-code"><a href="#Talk-is-cheap-show-me-code" class="headerlink" title="Talk is cheap,show me code"></a>Talk is cheap,show me code</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Talk-is-cheap-show-me-code&quot;&gt;&lt;a href=&quot;#Talk-is-cheap-show-me-code&quot; class=&quot;headerlink&quot; title=&quot;Talk is cheap,show me code&quot;&gt;&lt;/a&gt;Talk is 
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>2018.03.06</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/2018-03-06/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/2018-03-06/</id>
    <published>2018-03-25T10:22:36.000Z</published>
    <updated>2018-03-25T10:23:27.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生不是百米赛跑，而是长途接力赛"><a href="#人生不是百米赛跑，而是长途接力赛" class="headerlink" title="人生不是百米赛跑，而是长途接力赛"></a>人生不是百米赛跑，而是长途接力赛</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;人生不是百米赛跑，而是长途接力赛&quot;&gt;&lt;a href=&quot;#人生不是百米赛跑，而是长途接力赛&quot; class=&quot;headerlink&quot; title=&quot;人生不是百米赛跑，而是长途接力赛&quot;&gt;&lt;/a&gt;人生不是百米赛跑，而是长途接力赛&lt;/h3&gt;
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>2018.03.05</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/2018.03.05/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/2018.03.05/</id>
    <published>2018-03-25T09:58:37.000Z</published>
    <updated>2018-03-25T10:19:47.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软则柔，刚则折，刚柔并济，方圆之道"><a href="#软则柔，刚则折，刚柔并济，方圆之道" class="headerlink" title="软则柔，刚则折，刚柔并济，方圆之道"></a>软则柔，刚则折，刚柔并济，方圆之道</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软则柔，刚则折，刚柔并济，方圆之道&quot;&gt;&lt;a href=&quot;#软则柔，刚则折，刚柔并济，方圆之道&quot; class=&quot;headerlink&quot; title=&quot;软则柔，刚则折，刚柔并济，方圆之道&quot;&gt;&lt;/a&gt;软则柔，刚则折，刚柔并济，方圆之道&lt;/h3&gt;
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>学长考研</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/%E5%AD%A6%E9%95%BF%E8%80%83%E7%A0%94/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/学长考研/</id>
    <published>2018-03-25T09:49:01.000Z</published>
    <updated>2018-03-25T10:16:47.083Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;刚知道实验室的一个学长考上华科，虽是全非，但听到这消息，我心中的石头像是下去了。<br>&emsp;当时回了句“不知祝贺，还是”，在这祝贺你！</p><p>&emsp;&emsp;&emsp;– 2018.03.22晚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;刚知道实验室的一个学长考上华科，虽是全非，但听到这消息，我心中的石头像是下去了。&lt;br&gt;&amp;emsp;当时回了句“不知祝贺，还是”，在这祝贺你！&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;– 2018.03.22晚&lt;/p&gt;

      
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>途中加油</title>
    <link href="https://zaizizaizai.github.io/2018/03/25/%E9%80%94%E4%B8%AD%E5%8A%A0%E6%B2%B9/"/>
    <id>https://zaizizaizai.github.io/2018/03/25/途中加油/</id>
    <published>2018-03-25T09:37:13.000Z</published>
    <updated>2018-03-25T10:16:32.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这段时间"><a href="#这段时间" class="headerlink" title="这段时间"></a>这段时间</h3><p>&emsp;对自开学以来我的行为做一个总结、反思。先来一个总结：初期斗志昂扬，也带些许犹豫；中期在坚持，也受事物干扰；后期没有坚持，有些迷惘。<br>&emsp;刚来学校的时候，我自己都可以感到充满斗志，也确实在坚持。在5到8天的犹豫选择期后，大致有了一个目标：考研为主，学技术为辅。实际行为中是完全准备考研也无大碍，这段时间过的还是充足，这时候遇到第一个障碍，手机太卡了，已经完全影响到心情，在经历3到5天的选择后，终于也解决这件事情。<br>&emsp;接下来进入了下一个阶段，在摸索了新手机几天后，继续在学习。但这时受到新干扰，与朋友事情的处理和突然又想找女朋友，前者我能理解，但后者我无法作出解释。<br>&emsp;后期就开始迷茫了，怎么选学校，考研是为什么，我不是要学习技术的吗？在宿舍呆了大概一个星期后，虽未完全知道答案，但有大致的方向：以我目前掌握的皮毛，是无法进入IT行业，而且本科学校也不受认可，考研考一个认可度高的学校，并且在期间一直学习技术，而后，进入行业。</p><h3 id="总结方法"><a href="#总结方法" class="headerlink" title="总结方法"></a>总结方法</h3><p>&emsp;经历迷茫期后，我对目标执行方法有了自己的看法：探索，总结，坚持。<br>&emsp;在原本广义的学习的路上，探索能力是不可缺少的，即寻找所学习目标的知识、寻找解决问题的方法、寻找新的学习目标。<br>&emsp;总结是重中之重，在探索来内容后，对其学习、实践、总结，将其消化吸收，转化为自身所掌握的。总结也需要对总结的过程进行总结，即“吾日三醒吾身”。<br>坚持是以两者的基础，探索和总结是循环交叉的，而坚持是一直在进行。坚持的是每日规划的任务。<br>&emsp;（这段梦话瞎说）想一想有意思的是，深度学习在图像识别的应用貌似也是这个过程，探索新的特征点，总结特征点自身以及彼此之间的规律，当然，也一直在不断循环探索和总结这两个过程。也许上面的方法说的太模糊，所以对许多事物都套得住吧。<br>&emsp;展望和规划:心中有一颗钉子，抱着目标，运用方法。真诚待己。<br>&emsp;总结虽好，多说无益。GO HEAD!</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–2018.03.25</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;这段时间&quot;&gt;&lt;a href=&quot;#这段时间&quot; class=&quot;headerlink&quot; title=&quot;这段时间&quot;&gt;&lt;/a&gt;这段时间&lt;/h3&gt;&lt;p&gt;&amp;emsp;对自开学以来我的行为做一个总结、反思。先来一个总结：初期斗志昂扬，也带些许犹豫；中期在坚持，也受事物干扰；后期没
      
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出node读书笔记</title>
    <link href="https://zaizizaizai.github.io/2018/03/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://zaizizaizai.github.io/2018/03/12/深入浅出node读书笔记/</id>
    <published>2018-03-12T14:42:12.000Z</published>
    <updated>2018-03-12T15:16:27.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="读书" scheme="https://zaizizaizai.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="node" scheme="https://zaizizaizai.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>学习ES6</title>
    <link href="https://zaizizaizai.github.io/2018/03/03/%E5%AD%A6%E4%B9%A0ES6/"/>
    <id>https://zaizizaizai.github.io/2018/03/03/学习ES6/</id>
    <published>2018-03-03T01:44:37.000Z</published>
    <updated>2018-03-12T14:48:25.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h1><ul><li>ES6(ES2015)——IE10+</li><li>Chrome</li><li>FireFox</li><li>移动端</li><li><p>Node.js</p><p><strong>如何兼容老版本？(编译、转译)</strong></p></li></ul><ul><li><p>1、在线转换(用户每次打开页面需重新转换，费时)<br>   在线转换有很多工具，在这里以babel为例，在线转换只需要在<head>加上browser.js就行，如下：</head></p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">...省略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"browser.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"type/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li><li><p>2、提前编译(babel/browser.js)</p></li></ul><h1 id="ES6变化内容"><a href="#ES6变化内容" class="headerlink" title="ES6变化内容"></a>ES6变化内容</h1><ul><li>1、变量</li><li>2、箭头函数</li><li>3、函数的参数</li><li>4、数组方法</li><li>5、字符串</li><li>6、Promise(串行化的数据请求、异步交互)</li><li>7、generator(将同步操作拆为异步操作)</li><li>8、JSON</li><li>9、面向对象</li><li>10、解构赋值</li></ul><h1 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h1><h3 id="var存在的问题"><a href="#var存在的问题" class="headerlink" title="var存在的问题"></a>var存在的问题</h3><ul><li><p>可重复声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">12</span>;</span><br><span class="line">int a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li><li><p>无法限制修改<br>也可以说无常量，会导致数据变动，出现问题但程序无报错。</p></li><li><p>无块级作用域<br>var是函数作用域，导致块外面也可访问块内的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="let、const性质"><a href="#let、const性质" class="headerlink" title="let、const性质"></a>let、const性质</h3><ul><li><p>不可重复声明</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">3</span>;</span><br><span class="line">//报错，不可重复声明</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//报错，不可重复声明</span></span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//报错，不可重复声明</span></span><br></pre></td></tr></table></figure></li><li><p>let-变量，const-常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">a =<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="块级作用域有什么用？"><a href="#块级作用域有什么用？" class="headerlink" title="块级作用域有什么用？"></a>块级作用域有什么用？</h3><ul><li>经典问题： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//5,5,5,5,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>原始解决方法<br> 用函数包起来——闭包</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)(i);  <span class="comment">//0,1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>let解决</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//0,1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2、箭头函数-方便"><a href="#2、箭头函数-方便" class="headerlink" title="2、箭头函数(方便)"></a>2、箭头函数(方便)</h1><ul><li><p>区别</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line">() =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="keyword">let</span> show = <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="keyword">let</span> show = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>要点</p><ul><li>如果只有一个参数，可省略()</li><li><p>如果只有一个return，可省略{}</p><p>以下例子，可说明两要点</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">//ES5</span></span><br><span class="line">       <span class="keyword">let</span> show = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a*<span class="number">2</span>; </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//简写</span></span><br><span class="line">       <span class="keyword">let</span> show = <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">         retuen a*<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//进一步简写</span></span><br><span class="line">       <span class="keyword">let</span> show = <span class="function"><span class="params">a</span> =&gt;</span> a*<span class="number">2</span>; </span><br><span class="line">       <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">       </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 7、generator(生成器)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 概念</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 普通函数——一路到底</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>function show(){<br>    alert(‘a’);<br>    alert(‘b’);<br>}</p><p>show()<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>generator——中间能暂停(踹一脚走一步)</span><br></pre></td></tr></table></figure></p><p>function *show(){<br>    alert(‘a’);</p><pre><code>yield;    //放弃alert(&apos;b&apos;);</code></pre><p>}</p><p>let genObj = show();</p><p>genObj.next();    // a<br>genObj.next();    // b<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">* </span>generator原理</span><br></pre></td></tr></table></figure></p><p>//以上一段代码为例<br>function show_1(){<br>    alert(‘a’);<br>}</p><p>function show_2(){<br>    alert(‘b’);<br>}</p><p>genObj.next();    // show_1<br>genObj.next();    // show_2<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* yield</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 应用场景</span><br><span class="line">  请求数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8、Json</span></span><br><span class="line"></span><br><span class="line">* <span class="number">1</span>、<span class="keyword">JSON对象</span></span><br><span class="line"><span class="keyword"> </span>  + <span class="keyword">JSON.stringify</span></span><br><span class="line"><span class="keyword"> </span>  + <span class="keyword">Json.parse</span></span><br><span class="line"><span class="keyword"> </span>  </span><br><span class="line">* <span class="number">2</span>、简写</span><br><span class="line">   + 名字一样</span><br><span class="line">   </span><br><span class="line">   ```<span class="keyword">javascript</span></span><br><span class="line"><span class="keyword"> </span>  let a = <span class="number">2</span><span class="comment">;</span></span><br><span class="line">   let <span class="keyword">b </span>= <span class="number">5</span><span class="comment">;</span></span><br><span class="line">   let <span class="keyword">json </span>= &#123;a, <span class="keyword">b, </span>c: <span class="number">6</span>&#125;<span class="comment">;//&#123;2,5,6&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><p>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show ()&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>3、json的标准写法<ul><li>1.只能用双引号</li><li>2.所有名字都必须用引号包起来<ul><li>{a: 12, b: 15}  ×</li><li>{‘a’: 12, ‘b’: 15}  ×</li><li>{“a”: 12, “b”: 15}  √</li></ul></li></ul></li></ul><h1 id="9、面向对象应用——React"><a href="#9、面向对象应用——React" class="headerlink" title="9、面向对象应用——React"></a>9、面向对象应用——React</h1><blockquote><p>React特点</p><blockquote><p>1、组件化<br>2、强依赖于JSX=babel=browser.js</p></blockquote></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>学习react-组件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"react-dom.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"browser.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>(</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">constructor</span>(...args)&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">super</span>(...args);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            render()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;this.props.str&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        )</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="class"><span class="keyword">class</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>(</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">constructor</span>(params) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">super</span>(params);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            render()&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// let aItems=[];</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// for(let i = 0; i &lt; this.props.arr.length; i++)&#123;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                //     aItems.push(<span class="tag">&lt;<span class="name">Item</span> <span class="attr">str</span> = <span class="string">&#123;this.props.arr[i]</span>&lt;/<span class="attr">Item</span>&gt;</span>&#125;&gt;);</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">                        &#123;<span class="keyword">this</span>.props.arr.map(<span class="function"><span class="params">a</span> =&gt;</span> &lt;Item str = &#123;a&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Item</span>&gt;</span></span>)&#125;</span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>;</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        )</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> oDiv = docum</span></span><br><span class="line"><span class="actionscript">            ent.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            ReactDom.render(</span></span><br><span class="line"><span class="javascript">                &lt;List arr=&#123;[<span class="string">'123'</span>,<span class="string">'abc'</span>,<span class="string">'bxsa'</span>]&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">List</span>&gt;</span></span>,</span></span><br><span class="line"><span class="undefined">                oDiv</span></span><br><span class="line"><span class="undefined">            );</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;ES6(ES2015)——IE10+&lt;/li&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;li&gt;FireFox&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/categories/JavaScript/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="web" scheme="https://zaizizaizai.github.io/tags/web/"/>
    
      <category term="es6" scheme="https://zaizizaizai.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>记一次网站解析</title>
    <link href="https://zaizizaizai.github.io/2018/03/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%AB%99%E8%A7%A3%E6%9E%90/"/>
    <id>https://zaizizaizai.github.io/2018/03/01/记一次网站解析/</id>
    <published>2018-03-01T15:07:24.000Z</published>
    <updated>2018-03-12T14:44:35.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天记起要选公选课，同学安利一个教务处app，打开一看发现界面和功能都挺不错的，突然有做教务处微信小程序版本的想法，第一想法就是去找官网api，可转眼一想，哪来的api？原作者说网站解析来的，于是开始第一次抓包过程。</p><h1 id="1、去长大官网溜了一圈"><a href="#1、去长大官网溜了一圈" class="headerlink" title="1、去长大官网溜了一圈"></a>1、去长大官网溜了一圈</h1><p>首先来到官网看了下</p><h3 id="1-1、登录前"><a href="#1-1、登录前" class="headerlink" title="1.1、登录前"></a>1.1、登录前</h3><blockquote><p>教务处登录页面<br><img src="/images/网站解析/长大教务处登录前.png" alt="长大教务处登录前"></p><p>发送请求中的header<br><img src="/images/网站解析/长大教务处登录前header.png" alt="长大教务处登录前header"></p></blockquote><h3 id="1-2、登陆后"><a href="#1-2、登陆后" class="headerlink" title="1.2、登陆后"></a>1.2、登陆后</h3><p><img src="/images/网站解析/长大教务处登录后data.png" alt="长大教务处登录后data"></p><h3 id="1-3、测试"><a href="#1-3、测试" class="headerlink" title="1.3、测试"></a>1.3、测试</h3><blockquote><p>postman测试<br><img src="/images/网站解析/postMan发送教务处请求失败.png" alt="postMan发送教务处请求失败"></p></blockquote><p>一开始想到把请求数据拿到，再伪造不就行了吗？至于怎么发送、接受数据，后面再说嘛…<br>结果转眼一想，这还有验证码，难道要把验证码都转发给客户端？我看到的教务处app中用户名和密码都是学号，不科学啊，难道他找到漏洞，把学校教务处数据爬下来了？<br>我转向解析app</p><h1 id="2、解析app"><a href="#2、解析app" class="headerlink" title="2、解析app"></a>2、解析app</h1><blockquote><p>app发送到服务器的数据<br><img src="/images/网站解析/app请求.png" alt="app请求"></p></blockquote><p>从截图中<code>Request PostData</code>这一栏中可以看到发送的数据，这个username(学号)没加密，password(密码)加密了，由于学号就是用户名和密码，我试着把密码用md5方法编码、URL编/解码…等一系列还有我没见过的编/解码方法，结果都不与password/原密码匹配，我猜应该加入了干扰字符吧，寻找编码方法失败。<br>    但可以看到是发送到<code>http://221.233.24.23/eams/login.action</code>,就去这个网址看看。</p><h1 id="3、-教学管理系统溜一圈"><a href="#3、-教学管理系统溜一圈" class="headerlink" title="3、 教学管理系统溜一圈"></a>3、 教学管理系统溜一圈</h1><h3 id="3-1、登录前"><a href="#3-1、登录前" class="headerlink" title="3.1、登录前"></a>3.1、登录前</h3><p>访问这个地址，有登录界面，这张图片是<code>以错误的用户名密码登录时浏览器发送的数据</code></p><blockquote><p>以错误的用户名密码登录时浏览器发送的数据<br><img src="/images/网站解析/失败登录教学管理系统.png" alt="失败登录教学管理系统"></p></blockquote><p><code>username</code>是明文发送，<code>password</code>则加密了，可以看到也是发送了4个参数，这和app发送的请求参数相同，说明那个教务处app就是发送请求到这个教学管理系统的</p><h3 id="3-2、登陆后"><a href="#3-2、登陆后" class="headerlink" title="3.2、登陆后"></a>3.2、登陆后</h3><blockquote><p>以正确的用户名密码登录时浏览器发送的数据<br><img src="/images/网站解析/成功登录教学管理系统.png" alt="成功登录教学管理系统"></p></blockquote><p>这里图片无法显示，图片内容就是与上一个图片内容类似，但就是没有<code>post data</code>，这是什么？没见过啊，为什么登陆成功不发送数据，登录错误还可以显示数据</p><h4 id="留一个坑，不理解"><a href="#留一个坑，不理解" class="headerlink" title="留一个坑，不理解"></a>留一个坑，不理解</h4><h3 id="3-3、测试"><a href="#3-3、测试" class="headerlink" title="3.3、测试"></a>3.3、测试</h3><p><img src="/images/网站解析/成功登录教学管理系统.png" alt="postman发送教学管理系统失败"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天记起要选公选课，同学安利一个教务处app，打开一看发现界面和功能都挺不错的，突然有做教务处微信小程序版本的想法，第一想法就是去找官网ap
      
    
    </summary>
    
      <category term="实践" scheme="https://zaizizaizai.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="web" scheme="https://zaizizaizai.github.io/tags/web/"/>
    
      <category term="抓包" scheme="https://zaizizaizai.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>模板引擎jade与ejs的区别与重点</title>
    <link href="https://zaizizaizai.github.io/2018/02/27/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8Ejade%E4%B8%8Eejs%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%87%8D%E7%82%B9/"/>
    <id>https://zaizizaizai.github.io/2018/02/27/模板引擎jade与ejs的区别与重点/</id>
    <published>2018-02-27T13:03:29.000Z</published>
    <updated>2018-03-12T14:47:15.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、模板引擎"><a href="#一、模板引擎" class="headerlink" title="一、模板引擎"></a>一、模板引擎</h1><blockquote><p> <strong>//TODO</strong></p></blockquote><h1 id="二、jade"><a href="#二、jade" class="headerlink" title="二、jade"></a>二、jade</h1><h2 id="1、认识jade"><a href="#1、认识jade" class="headerlink" title="1、认识jade"></a>1、认识jade</h2><blockquote><p> <strong>//TODO</strong></p></blockquote><h2 id="2、基础语法"><a href="#2、基础语法" class="headerlink" title="2、基础语法"></a>2、基础语法</h2><h3 id="2-1、根据缩进划分层级"><a href="#2-1、根据缩进划分层级" class="headerlink" title="2.1、根据缩进划分层级"></a>2.1、根据缩进划分层级</h3><h3 id="2-2、属性用-表示，用逗号分割"><a href="#2-2、属性用-表示，用逗号分割" class="headerlink" title="2.2、属性用()表示，用逗号分割"></a>2.2、属性用()表示，用逗号分割</h3><blockquote><pre><code>*style = []*class = []</code></pre></blockquote><h3 id="2-3、内容"><a href="#2-3、内容" class="headerlink" title="2.3、内容"></a>2.3、内容</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> xxx</span><br><span class="line">  <span class="selector-tag">span</span> xxx</span><br><span class="line">    a(href=<span class="string">"xxx"</span>)链接</span><br></pre></td></tr></table></figure><h3 id="2-4、渲染"><a href="#2-4、渲染" class="headerlink" title="2.4、渲染"></a>2.4、渲染</h3><blockquote><p> jade.render(‘字符串’);<br> jdde.renderFile(‘模板文件名’, 参数);</p></blockquote><h2 id="3、高级用法"><a href="#3、高级用法" class="headerlink" title="3、高级用法"></a>3、高级用法</h2><h3 id="3-1原样输出"><a href="#3-1原样输出" class="headerlink" title="3.1原样输出"></a>3.1原样输出</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.jade</span></span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">  body</span><br><span class="line">    zaizi</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转为对应html</span></span><br><span class="line"><span class="params">&lt;html&gt;</span></span><br><span class="line">  <span class="params">&lt;head&gt;</span><span class="params">&lt;/head&gt;</span></span><br><span class="line">  <span class="params">&lt;body&gt;</span></span><br><span class="line">    <span class="params">&lt;zaizi&gt;</span><span class="params">&lt;/zaizi&gt;</span></span><br><span class="line">  <span class="params">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看出，原意是body的内容为zaizi，但实际转译把zaizi作为自定义标签。如何在标签里原样显示内容呢？如下:</p><blockquote><p><strong>加竖线|,原样输出</strong></p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.jade</span></span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">  body</span><br><span class="line">    |zaizi</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转为对应html</span></span><br><span class="line"><span class="params">&lt;html&gt;</span></span><br><span class="line">  <span class="params">&lt;head&gt;</span><span class="params">&lt;/head&gt;</span></span><br><span class="line">  <span class="params">&lt;body&gt;</span>zaizi<span class="params">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><p>此语法可用于在html代码中写js，例子：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    script</span><br><span class="line">      <span class="string">| //js代码</span></span><br><span class="line">      <span class="string">| //js代码</span></span><br><span class="line">    body</span><br><span class="line">      <span class="string">|zaizi</span></span><br><span class="line">      <span class="string">|dog</span></span><br></pre></td></tr></table></figure><p>以上情况满足写在html中js的需求，但每一行都需要加|，还是比较麻烦，更简单的方法是：<code>在script后面加一个点.</code>，例子：</p><blockquote><p><strong>在标签后加一个点.表示标签后的内容都原样输出</strong></p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    script.</span><br><span class="line">      <span class="comment">// js代码</span></span><br><span class="line">  body</span><br></pre></td></tr></table></figure><p>若要文件结构更清楚，可以尝试引用外部js文件，但会增加http请求数，这里可以采用<code>include</code>，例子：</p><blockquote><p><strong>include引用文件</strong></p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    script.</span><br><span class="line">      include <span class="selector-tag">a</span>.js</span><br><span class="line">  body</span><br></pre></td></tr></table></figure><h3 id="3-2-使用变量"><a href="#3-2-使用变量" class="headerlink" title="3.2 使用变量"></a>3.2 使用变量</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jade代码</span></span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">  body</span><br><span class="line">    <span class="keyword">div</span> 我的名字: <span class="meta">#&#123;name&#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//js代码</span></span><br><span class="line">const jade = require(<span class="string">'jade'</span>);</span><br><span class="line"></span><br><span class="line">const.log(jade.renderFile(<span class="string">'`jade文件地址`'</span>, &#123;pretty: <span class="keyword">true</span>, name: <span class="string">'zaizi'</span>&#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译效果</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;我的名字: zaizi&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、模板引擎&quot;&gt;&lt;a href=&quot;#一、模板引擎&quot; class=&quot;headerlink&quot; title=&quot;一、模板引擎&quot;&gt;&lt;/a&gt;一、模板引擎&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; &lt;strong&gt;//TODO&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="node" scheme="https://zaizizaizai.github.io/categories/node/"/>
    
    
      <category term="jade" scheme="https://zaizizaizai.github.io/tags/jade/"/>
    
      <category term="ejs" scheme="https://zaizizaizai.github.io/tags/ejs/"/>
    
      <category term="模板引擎" scheme="https://zaizizaizai.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>剖析Promise内部结构</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E5%89%96%E6%9E%90Promise%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/剖析Promise内部结构/</id>
    <published>2018-02-25T12:01:27.000Z</published>
    <updated>2018-03-12T14:47:19.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  阅读本文需要对promise有一定了解，可阅读<a href="https://zaizizaizai.github.io/2018/02/20/%E8%AF%A6%E8%A7%A3promise/">详解promise</a></p><h1 id="Promise标准解读"><a href="#Promise标准解读" class="headerlink" title="Promise标准解读"></a>Promise标准解读</h1><p>  1.只有一个<code>then</code>方法，没有<code>catch</code>，<code>race</code>，<code>all</code>等方法，甚至没有构造函数</p><pre><code>Promise标准中仅指定了Promise对象的`then`方法的行为，其他常见的方法/函数都没有指定，包括`catch`，`race`，`all`等常用方法，甚至也没有指定该乳环构造一个Promise对象，而且`then`也没有一般实现中(Q,$q等)所支持的第三个参数，一般成为onProgress</code></pre><p>  2.<code>then</code>方法返回一个新的Promise</p><pre><code>Promise的`then`方法返回一个新的Promise，而不是返回this，此处下文会有更多解释<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">promise2</span> = promise1.<span class="keyword">then</span>(alert);</span><br><span class="line">promise2 != promise1 //<span class="literal">true</span></span><br></pre></td></tr></table></figure></code></pre><p>  3.不同Promise的实现需要可以相互调用(interoperable)</p><p>  4.Promise的初始状态为pending，它可以由此状态转换为fulfilled(也叫resolved)或者rejected，一旦状态确定，就不可以再转换为其他状态，状态确定的过程成为settle</p><p>  5.<a href="https://promisesaplus.com/" target="_blank" rel="noopener">更具体的标准</a></p><h1 id="一步一步实现一个Promise"><a href="#一步一步实现一个Promise" class="headerlink" title="一步一步实现一个Promise"></a>一步一步实现一个Promise</h1><p>  一步一步实现一个Promise</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>标准中并没由指定如何构造一个Promise对象，在此以实现Promise的通用方法来构造一个Promise对象，即ES6原生Promise里所使用的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise构造函数接收一个executor函数，execuyor函数执行完同步或者异步操作后，调用它的两个参数resolve和reject</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果操作成功，调用resolve并传入value</span></span><br><span class="line"><span class="comment">如果操作失败，调用reject并传入reason</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先实现构造函数的框架：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line"><span class="keyword">self</span>.status = <span class="string">'pending'</span>;  <span class="comment">//Promise当前的状态</span></span><br><span class="line"><span class="keyword">self</span>.data = undefined;  <span class="comment">//Promise的值</span></span><br><span class="line"><span class="keyword">self</span>.onResolvedCallback = [];  <span class="comment">//Promise resolve时的回调函数</span></span><br><span class="line"><span class="keyword">self</span>.onRejectedCallback = [];  <span class="comment">//Promise reject时的回调函数</span></span><br><span class="line"></span><br><span class="line">executor(resolve, reject);  <span class="comment">//执行executor并传入相应的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码基本实现了Promise构造函数的主体，但还是有两个问题：</p><p>1.我们给executor函数传了两个参数：resolve和reject，这两个参数尚未定义</p><p>2.executor也有可能出错(throw)，此时，Promise应该被其throw出的值reject：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以我们需要在构造函数里定义resolve和reject这两个函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this</span><br><span class="line"><span class="keyword">self</span>.status = <span class="string">'pending'</span> <span class="comment">// Promise当前的状态</span></span><br><span class="line"><span class="keyword">self</span>.data = undefined  <span class="comment">// Promise的值</span></span><br><span class="line"><span class="keyword">self</span>.onResolvedCallback = [] <span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"><span class="keyword">self</span>.onRejectedCallback = [] <span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(reson)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//try/catch捕捉错误</span></span><br><span class="line">executor(resolve, reject);<span class="comment">//执行executor</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">原文</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;  阅读本文需要对promise有一定了解，可阅读&lt;a href=&quot;https://zaizizaizai.github.io/2018/0
      
    
    </summary>
    
      <category term="node" scheme="https://zaizizaizai.github.io/categories/node/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="node" scheme="https://zaizizaizai.github.io/tags/node/"/>
    
      <category term="promise" scheme="https://zaizizaizai.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>博文置顶测试</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%B5%8B%E8%AF%95/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/博文置顶测试/</id>
    <published>2018-02-25T09:09:16.000Z</published>
    <updated>2018-03-12T14:44:10.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在文章中添加<strong>top</strong>值，数值越大文章越靠前，如：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 博文置顶测试</span><br><span class="line">date: 2018<span class="string">-02</span><span class="string">-25</span> 17:09:16</span><br><span class="line"><span class="keyword">tags:</span> [测试,博客]</span><br><span class="line">categories: 博客说明</span><br><span class="line">top: 3</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h3&gt;&lt;p&gt;在文章中添加&lt;strong&gt;top&lt;/strong&gt;值，数值越大文章越靠前，如：&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="博客建设" scheme="https://zaizizaizai.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="测试" scheme="https://zaizizaizai.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="博客" scheme="https://zaizizaizai.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>文章密码测试</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E6%96%87%E7%AB%A0%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%95/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/文章密码测试/</id>
    <published>2018-02-25T09:01:10.000Z</published>
    <updated>2018-03-12T14:48:07.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章密码测试"><a href="#文章密码测试" class="headerlink" title="文章密码测试"></a>文章密码测试</h2><p>测试</p><blockquote><p>点击全文应该需要输入密码<br>密码：123456</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文章密码测试&quot;&gt;&lt;a href=&quot;#文章密码测试&quot; class=&quot;headerlink&quot; title=&quot;文章密码测试&quot;&gt;&lt;/a&gt;文章密码测试&lt;/h2&gt;&lt;p&gt;测试&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;点击全文应该需要输入密码&lt;br&gt;密码：123456&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="博客建设" scheme="https://zaizizaizai.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="测试" scheme="https://zaizizaizai.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="博客" scheme="https://zaizizaizai.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>科学上网</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/科学上网/</id>
    <published>2018-02-25T07:44:48.000Z</published>
    <updated>2018-03-12T14:45:49.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="heroku上部署ss"><a href="#heroku上部署ss" class="headerlink" title="heroku上部署ss"></a>heroku上部署ss</h2><p><strong>先来占个坑</strong></p><p>之前在github上发现了一个在heroku上搭建shadowsocks的项目，自己试着搭建，发现极好用。此时原项目已被作者删除，重新找了一个。<br><strong>特点：</strong></p><blockquote><p>1、快速，youtube上4k视频无压力<br>2、无限流量<br>3、<strong>免费！免费！</strong></p></blockquote><hr><h3 id="github项目地址"><a href="#github项目地址" class="headerlink" title="github项目地址"></a><a href="https://github.com/VincentChanX/shadowsocks-over-websocket" target="_blank" rel="noopener">github项目地址</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;heroku上部署ss&quot;&gt;&lt;a href=&quot;#heroku上部署ss&quot; class=&quot;headerlink&quot; title=&quot;heroku上部署ss&quot;&gt;&lt;/a&gt;heroku上部署ss&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;先来占个坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前在g
      
    
    </summary>
    
      <category term="技巧" scheme="https://zaizizaizai.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="heroku" scheme="https://zaizizaizai.github.io/tags/heroku/"/>
    
      <category term="ss" scheme="https://zaizizaizai.github.io/tags/ss/"/>
    
      <category term="科学上网" scheme="https://zaizizaizai.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript--深克隆</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E7%90%86%E8%A7%A3JavaScript--%E6%B7%B1%E5%85%8B%E9%9A%86/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/理解JavaScript--深克隆/</id>
    <published>2018-02-25T07:34:44.000Z</published>
    <updated>2018-03-12T14:46:22.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="八、在JavaScript中如何实现一个深克隆"><a href="#八、在JavaScript中如何实现一个深克隆" class="headerlink" title="八、在JavaScript中如何实现一个深克隆"></a>八、在JavaScript中如何实现一个深克隆</h1><hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在要实现一个深克隆之前我们需要了解一下javascript中的基础类型.</p><p><a href="https://github.com/xiaomuzhu/ElemeFE-node-interview/blob/master/JavaScript%E5%9F%BA%E7%A1%80/JavaScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.md" target="_blank" rel="noopener">javascript基础类型</a>　　</p><blockquote><p>JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol<br>JavaScript引用类型:Object</p></blockquote><hr><h4 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1.浅克隆"></a>1.浅克隆</h4><p>　　<strong>浅克隆</strong>之所以被称为<strong>浅克隆</strong>，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅克隆函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">    obj[i] = o[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被克隆对象</span></span><br><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: [ <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> ],</span><br><span class="line">  c: &#123; <span class="attr">h</span>: &#123; <span class="attr">i</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = shallowClone(oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj.c.h, oldObj.c.h); <span class="comment">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(oldObj.c.h === newObj.c.h); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们可以看到,很明显虽然<code>oldObj.c.h</code>被克隆了,但是它还与<code>oldObj.c.h</code>相等,这表明他们依然指向同一段堆内存,这就造成了如果对<code>newObj.c.h</code>进行修改,也会影响<code>oldObj.c.h</code>,这就不是一版好的克隆.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newObj.c.h.i = <span class="string">'change'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newObj.c.h, oldObj.c.h); <span class="comment">// &#123; i: 'change' &#125; &#123; i: 'change' &#125;</span></span><br></pre></td></tr></table></figure><p>我们改变了<code>newObj.c.h.i</code>的值,<code>oldObj.c.h.i</code>也被改变了,这就是浅克隆的问题所在.</p><p>当然有一个新的api<code>Object.assign()</code>也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p><h4 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2.深克隆"></a>2.深克隆</h4><h5 id="2-1-JSON-parse方法"><a href="#2-1-JSON-parse方法" class="headerlink" title="2.1 JSON.parse方法"></a>2.1 JSON.parse方法</h5><p>前几年微博上流传着一个传说中最便捷实现深克隆的方法,<br>JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure></p><p>我们依然用上一节的例子进行测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: [ <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span> ],</span><br><span class="line">  c: &#123; <span class="attr">h</span>: &#123; <span class="attr">i</span>: <span class="number">2</span> &#125; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj.c.h, oldObj.c.h); <span class="comment">// &#123; i: 2 &#125; &#123; i: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(oldObj.c.h === newObj.c.h); <span class="comment">// false</span></span><br><span class="line">newObj.c.h.i = <span class="string">'change'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(newObj.c.h, oldObj.c.h); <span class="comment">// &#123; i: 'change' &#125; &#123; i: 2 &#125;</span></span><br></pre></td></tr></table></figure></p><p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p><p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p><blockquote><p>1.他无法实现对函数 、RegExp等特殊对象的克隆</p><p>2.会抛弃对象的constructor,所有的构造函数会指向Object</p><p>3.对象有循环引用,会报错</p></blockquote><p>主要的坑就是以上几点,我们一一测试下.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">pname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = pname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Messi = <span class="keyword">new</span> person(<span class="string">'Messi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">  a: say,</span><br><span class="line">  b: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>),</span><br><span class="line">  c: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>, <span class="string">'i'</span>),</span><br><span class="line">  d: Messi</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法复制函数</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.a, oldObj.a); <span class="comment">// undefined [Function: say]</span></span><br><span class="line"><span class="comment">// 稀疏数组复制错误</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b[<span class="number">0</span>], oldObj.b[<span class="number">0</span>]); <span class="comment">// null undefined</span></span><br><span class="line"><span class="comment">// 无法复制正则对象</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.c, oldObj.c); <span class="comment">// &#123;&#125; /ab+c/i</span></span><br><span class="line"><span class="comment">// 构造函数指向错误</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class="comment">// [Function: Object] [Function: person]</span></span><br></pre></td></tr></table></figure><p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">oldObj.a = oldObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj.a, oldObj.a); <span class="comment">// TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure><p>对象的循环引用会抛出错误.</p><h5 id="2-2-构造一个深克隆函数"><a href="#2-2-构造一个深克隆函数" class="headerlink" title="2.2 构造一个深克隆函数"></a>2.2 构造一个深克隆函数</h5><p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的<strong>序列/反序列</strong>是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.<br><img src="http://omrbgpqyl.bkt.clouddn.com/18-1-20/43905997.jpg" alt=""><br><em>(这个方法也会出现上一节提到的问题)</em></p><p>由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function">(<span class="params">obj, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> typeString = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">let</span> flag;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Array'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Array]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Date'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Date]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'RegExp'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object RegExp]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isType(arr, <span class="string">'Array'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对于正则对象,我们在处理之前要先补充一点新知识.</p><p>我们需要通过<a href="http://es6.ruanyifeng.com/#docs/regex#flags-%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">正则的扩展</a>了解到<strong>flags 属性 </strong>等等,因此我们需要实现一个提取flags的函数.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getRegExp = <span class="function"><span class="params">re</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> flags = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">if</span> (re.global) flags += <span class="string">'g'</span>;</span><br><span class="line">  <span class="keyword">if</span> (re.ignoreCase) flags += <span class="string">'i'</span>;</span><br><span class="line">  <span class="keyword">if</span> (re.multiline) flags += <span class="string">'m'</span>;</span><br><span class="line">  <span class="keyword">return</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>做好了这些准备工作,我们就可以进行深克隆的实现了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* deep clone</span></span><br><span class="line"><span class="comment">* @param  &#123;[type]&#125; parent object 需要进行克隆的对象</span></span><br><span class="line"><span class="comment">* @return &#123;[type]&#125;        深克隆后的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> clone = <span class="function"><span class="params">parent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 维护两个储存循环引用的数组</span></span><br><span class="line">  <span class="keyword">const</span> parents = [];</span><br><span class="line">  <span class="keyword">const</span> children = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _clone = <span class="function"><span class="params">parent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> parent !== <span class="string">'object'</span>) <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> child, proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isType(parent, <span class="string">'Array'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 对数组做特殊处理</span></span><br><span class="line">      child = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isType(parent, <span class="string">'RegExp'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 对正则对象做特殊处理</span></span><br><span class="line">      child = <span class="keyword">new</span> <span class="built_in">RegExp</span>(parent.source, getRegExp(parent));</span><br><span class="line">      <span class="keyword">if</span> (parent.lastIndex) child.lastIndex = parent.lastIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isType(parent, <span class="string">'Date'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 对Date对象做特殊处理</span></span><br><span class="line">      child = <span class="keyword">new</span> <span class="built_in">Date</span>(parent.getTime());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 处理对象原型</span></span><br><span class="line">      proto = <span class="built_in">Object</span>.getPrototypeOf(parent);</span><br><span class="line">      <span class="comment">// 利用Object.create切断原型链</span></span><br><span class="line">      child = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理循环引用</span></span><br><span class="line">    <span class="keyword">const</span> index = parents.indexOf(parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象</span></span><br><span class="line">      <span class="keyword">return</span> children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    parents.push(parent);</span><br><span class="line">    children.push(child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parent) &#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      child[i] = _clone(parent[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _clone(parent);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们做一下测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">pname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = pname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Messi = <span class="keyword">new</span> person(<span class="string">'Messi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">  a: say,</span><br><span class="line">  c: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>, <span class="string">'i'</span>),</span><br><span class="line">  d: Messi,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oldObj.b = oldObj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = clone(oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj.a, oldObj.a); <span class="comment">// [Function: say] [Function: say]</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b, oldObj.b); <span class="comment">// &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.c, oldObj.c); <span class="comment">// /ab+c/i /ab+c/i</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.d.constructor, oldObj.d.constructor); <span class="comment">// [Function: person] [Function: person]</span></span><br></pre></td></tr></table></figure></p><p>当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;八、在JavaScript中如何实现一个深克隆&quot;&gt;&lt;a href=&quot;#八、在JavaScript中如何实现一个深克隆&quot; class=&quot;headerlink&quot; title=&quot;八、在JavaScript中如何实现一个深克隆&quot;&gt;&lt;/a&gt;八、在JavaScript中如何实
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/categories/JavaScript/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript--传递引用</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E7%90%86%E8%A7%A3JavaScript--%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/理解JavaScript--传递引用/</id>
    <published>2018-02-25T07:23:29.000Z</published>
    <updated>2018-03-12T14:45:56.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七、传递引用"><a href="#七、传递引用" class="headerlink" title="七、传递引用"></a>七、传递引用</h1><hr><h4 id="1-JavaScript中的基本类型传递"><a href="#1-JavaScript中的基本类型传递" class="headerlink" title="1.JavaScript中的基本类型传递"></a>1.JavaScript中的基本类型传递</h4><p>一个我们经常遇到的问题：“JS中的值是按值传递，还是按引用传递呢？”</p><p>由于js中存在<strong>复杂类型</strong>和<strong>基本类型</strong>,对于<strong>基本类型</strong>而言,是按值传递的.    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">test(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>虽然在函数<code>test</code>中<code>a</code>被修改,并没有有影响到<br>外部<code>a</code>的值,基本类型是按值传递的.</p><hr><h4 id="2-复杂类型按引用传递"><a href="#2-复杂类型按引用传递" class="headerlink" title="2.复杂类型按引用传递?"></a>2.复杂类型按引用传递?</h4><p>我们将外部<code>a</code>作为一个对象传入<code>test</code>函数.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x.a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">test(a); <span class="comment">// &#123; a: 10, b: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; a: 10, b: 2 &#125;</span></span><br></pre></td></tr></table></figure></p><p>可以看到,在函数体内被修改的<code>a</code>对象也同时影响到了外部的<code>a</code>对象,可见复杂类型是按<strong>引用传递的</strong>.</p><p>可是如果再做一个实验:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">test(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure></p><p>外部的<code>a</code>并没有被修改,如果是按引用传递的话,由于共享同一个堆内存,<code>a</code>在外部也会表现为<code>10</code>才对.<br>此时的复杂类型同时表现出了<code>按值传递</code>和<code>按引用传递</code>的特性.</p><hr><h4 id="3-按共享传递"><a href="#3-按共享传递" class="headerlink" title="3.按共享传递"></a>3.按共享传递</h4><p>复杂类型之所以会产生这种特性,原因就是在传递过程中,对象<code>a</code>先产生了一个<code>副本a</code>,这个<code>副本a</code>并不是深克隆得到的<code>副本a</code>,<code>副本a</code>地址同样指向对象<code>a</code>指向的堆内存.</p><p><img src="http://omrbgpqyl.bkt.clouddn.com/17-8-31/72507393.jpg" alt=""></p><p>因此在函数体中修改<code>x=10</code>只是修改了<code>副本a</code>,<code>a</code>对象没有变化.<br>但是如果修改了<code>x.a=10</code>是修改了两者指向的同一堆内存,此时对象<code>a</code>也会受到影响.</p><p>有人讲这种特性叫做<strong>传递引用</strong>,也有一种说法叫做<strong>按共享传递</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;七、传递引用&quot;&gt;&lt;a href=&quot;#七、传递引用&quot; class=&quot;headerlink&quot; title=&quot;七、传递引用&quot;&gt;&lt;/a&gt;七、传递引用&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-JavaScript中的基本类型传递&quot;&gt;&lt;a href=&quot;#1-JavaScript
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/categories/JavaScript/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript--this</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E7%90%86%E8%A7%A3JavaScript--this/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/理解JavaScript--this/</id>
    <published>2018-02-25T06:09:29.000Z</published>
    <updated>2018-03-12T14:46:45.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、this"><a href="#五、this" class="headerlink" title="五、this"></a>五、this</h1><hr><h4 id="1-什么决定了this的指向"><a href="#1-什么决定了this的指向" class="headerlink" title="1.什么决定了this的指向"></a>1.什么决定了<code>this</code>的指向</h4><p>　　<code>this</code>一直是JavaScript中十分玄乎的存在,很多人为了避开这个琢磨不透的东西,选择了尽量少得运用<code>this</code>,但是不可否认的是,正是因为<code>this</code>的存在才使得JavaScript拥有了更加灵活的特性,因此,搞清楚<code>this</code>是每一个JavaScript学习者的必修课.</p><p>　　<code>this</code>之所以让人又爱又恨,正是因为它的指向让人琢磨不透,在进行详细讲解之前,我们要搞清楚一个大前提,<code>this</code>的指向不是在编写时确定的,而是在执行时确定的.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">  name: <span class="string">"Messi"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayName(); <span class="comment">//"Messi"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.sayName;</span><br><span class="line">f(); <span class="comment">//undefind</span></span><br><span class="line"><span class="built_in">console</span>.log(f === obj.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>　　很明显,虽然<code>f</code>与<code>obj.sayName</code>是等价的,但是他们所产生的结果却截然不同,归根到底是因为它们调用位置的不同造成的.</p><p>　　<code>f</code>的调用位置在全局作用域,因此<code>this</code>指向<code>window</code>对象,而<code>window</code>对象并不存在<code>name</code>因此会显示出<code>undefind</code>,而<code>obj.sayName</code>的<code>this</code>指向的是<code>obj</code>对象,因此会打印出<code>&quot;Messi&quot;</code>.</p><p>　　我们可以在以下代码中加入<code>name = &quot;Bale&quot;;</code>来证明以上说法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Bale"</span>;</span><br><span class="line">obj = &#123;</span><br><span class="line">  name: <span class="string">"Messi"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayName(); <span class="comment">//"Messi"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.sayName;</span><br><span class="line">f(); <span class="comment">//"Bale"</span></span><br><span class="line"><span class="built_in">console</span>.log(f === obj.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>　　大家一定会好奇,调用位置是如何决定<code>obj.sayName</code>的<code>this</code>指向<code>obj</code>对象,<code>f</code>却指向<code>window</code>对象呢,其中遵循什么规则吗?</p><hr><h4 id="2-默认绑定"><a href="#2-默认绑定" class="headerlink" title="2.默认绑定"></a>2.默认绑定</h4><p>　　<code>this</code>一共存在4种绑定规则,默认绑定是其中最常见的,我们可以认为当其他三个绑定规则都没有体现时,就用的是默认的绑定规则.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Bale"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sayName(); <span class="comment">//"Bale"</span></span><br></pre></td></tr></table></figure><p>　　以上代码可以看成我们第一节例子中的<code>f</code>函数,它之所以指向<code>window</code>对象,就是运用了<code>this</code><strong>默认绑定</strong>的规则,因为此实例代码中既没有运用<code>apply</code> 　<code>bind</code>等显示绑定,也没有用<code>new</code>绑定,不适用于其他绑定规则,因此便是<strong>默认绑定</strong>,此时的<code>this</code>指向全局变量,即浏览器端的<code>window</code>Node.js中的<code>global</code>.</p><hr><h4 id="3-隐式绑定"><a href="#3-隐式绑定" class="headerlink" title="3.隐式绑定"></a>3.隐式绑定</h4><p>　　当函数被调用的位置存在上下文对象,或者说被某个对象拥有或包含,这时候函数的<code>f</code>的<code>this</code>被<strong>隐式绑定</strong>到<code>obj</code>对象上.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">"Messi"</span>,</span><br><span class="line">f: f</span><br><span class="line">&#125;;</span><br><span class="line">obj.f(); <span class="comment">// Messi</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="4-显式绑定"><a href="#4-显式绑定" class="headerlink" title="4.显式绑定"></a>4.显式绑定</h4><p>　　除了极少数的宿主函数之外,所有的函数都拥有<code>call</code> <code>apply</code>方法,而这两个大家既熟悉又陌生的方法可以强制改变<code>this</code>的指向,从而实现显式绑定.</p><p><code>call</code> <code>apply</code>可以产生对<code>this</code>相同的绑定效果,唯一的区别便是他们参数传入的方式不同.</p><blockquote><p><strong>call方法</strong>:<br><strong>语法</strong>：call([thisObj[,arg1[, arg2[,   [,.argN]]]]])<br><strong>定义</strong>：调用一个对象的一个方法，以另一个对象替换当前对象。<br><strong>说明</strong>：<br>　　call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>　　如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p><p><strong>apply方法</strong>：<br><strong>语法</strong>：apply([thisObj[,argArray]])<br><strong>定义</strong>：应用某一对象的一个方法，用另一个对象替换当前对象。<br><strong>说明</strong>：<br>　　如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p></blockquote><p>　　第一个参数意义都一样。第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而<code>call</code>则作为<code>call</code>的参数传入（从第二个参数开始）。<br>　　如 <code>func.call(func1,var1,var2,var3)</code>  对应的<code>apply</code>写法为：<code>func.apply(func1,[var1,var2,var3])</code>，同时使用<code>apply</code>的好处是可以直接将当前函数的<code>arguments</code>对象作为<code>apply</code>的第二个参数传入。 　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">"Messi"</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">f.call(obj); <span class="comment">// Messi</span></span><br><span class="line">f.apply(obj); <span class="comment">//Messi</span></span><br></pre></td></tr></table></figure><p>我们可以看到,效果是相同的,<code>call</code>  <code>apply</code>的作用都是强制将<code>f</code>函数的<code>this</code>绑定到<code>obj</code>对象上.<br>在ES5中有一个与<code>call</code> <code>apply</code>效果类似的<code>bind</code>方法,同样可以达成这种效果,</p><blockquote><p><strong><code>Function.prototype.bind()</code></strong> 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Messi"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">     name: <span class="string">"Bale"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.bind(obj)(); <span class="comment">//Messi ,由于bind将obj绑定到f函数上后返回一个新函数,因此需要再在后面加上括号进行执行,这是bind与apply和call的区别</span></span><br></pre></td></tr></table></figure><hr><h4 id="5-new绑定"><a href="#5-new绑定" class="headerlink" title="5.new绑定"></a>5.new绑定</h4><p>用 new 调用一个构造函数，会创建一个新对象, 在创造这个新对象的过程中,新对象会自动绑定到<code>Person</code>对象的<code>this</code>上，那么 <code>this</code> 自然就指向这个新对象。<br>这没有什么悬念，因为 new 本身就是设计来创建新对象的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Messi'</span>); <span class="comment">//Messi</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="6-绑定优先级"><a href="#6-绑定优先级" class="headerlink" title="6.绑定优先级"></a>6.绑定优先级</h4><p>通过以上的介绍,我们知道了四种绑定的规则,但是当这些规则同时出现,那么谁的优先级更高呢,这才有助于我们判断<code>this</code>的指向.<br>通常情况下,按照优先级排序是:<br><strong>new绑定 &gt; 显式绑定 &gt;隐式绑定 &gt;默认绑定</strong></p><p>我们完全可以通过这个优先级顺序判断<code>this</code>的指向问题.</p><hr><h4 id="7-ES6箭头函数中的this"><a href="#7-ES6箭头函数中的this" class="headerlink" title="7.ES6箭头函数中的this"></a>7.ES6箭头函数中的this</h4><p>箭头函数不同于传统JavaScript中的函数,箭头函数并没有属于自己的<code>this</code>,它的<code>this</code>是捕获其所在上下文的  this 值，作为自己的 this 值,并且由于没有属于自己的<code>this</code>,箭头函数是不会被<code>new</code>调用的.</p><p>MDN文档中关于箭头函数的实例很清楚的说明了这一点.</p><p>在 ECMAScript 3/5 中，这个问题可以通过新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 也有人选择使用 `that` 而非 `self`. </span></span><br><span class="line">                   <span class="comment">// 只要保证一致就好.</span></span><br><span class="line">  self.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调里面的 `self` 变量就指向了期望的那个对象了</span></span><br><span class="line">    self.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，还可以使用 bind 函数，把期望的 this 值传递给 growUp() 函数。</p><p>箭头函数则会捕获其所在上下文的  this 值，作为自己的 this 值，因此下面的代码将如期运行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++; <span class="comment">// |this| 正确地指向了 person 对象</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p><p>当然,我们用babel转码器,也可以让我们更清楚理解箭头函数的<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    getArrow() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    getArrow: <span class="function"><span class="keyword">function</span> <span class="title">getArrow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(_this === obj);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;五、this&quot;&gt;&lt;a href=&quot;#五、this&quot; class=&quot;headerlink&quot; title=&quot;五、this&quot;&gt;&lt;/a&gt;五、this&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-什么决定了this的指向&quot;&gt;&lt;a href=&quot;#1-什么决定了this的指向&quot; cl
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/categories/JavaScript/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript--属性</title>
    <link href="https://zaizizaizai.github.io/2018/02/25/%E7%90%86%E8%A7%A3JavaScript--%E5%B1%9E%E6%80%A7/"/>
    <id>https://zaizizaizai.github.io/2018/02/25/理解JavaScript--属性/</id>
    <published>2018-02-25T05:50:52.000Z</published>
    <updated>2018-03-12T14:46:27.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="六、属性"><a href="#六、属性" class="headerlink" title="六、属性"></a>六、属性</h1><hr><h4 id="1-JavaScript中的对象"><a href="#1-JavaScript中的对象" class="headerlink" title="1.JavaScript中的对象"></a>1.JavaScript中的对象</h4><p>JavaScript中的对象一般分为三类:<strong>内置对象</strong>(Array, Error, Date等), <strong>宿主对象</strong>(对于前端来说指的是浏览器对象,例如window), <strong>自定义对象</strong>(指我们自己创建的对象).</p><p>因此,我们主要讨论的内容是围绕自定义对象展开的,今天我们就对象的属性进行深入地探究.</p><hr><h4 id="2-属性的创建"><a href="#2-属性的创建" class="headerlink" title="2.属性的创建"></a>2.属性的创建</h4><p>我们先定义一个对象,然后对其赋值:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"Messi"</span>;</span><br></pre></td></tr></table></figure></p><p>以上操作相当于给<code>person</code>对象建立了一个<code>name</code>属性,且值为<code>&#39;Messi&#39;</code>.</p><p>那么这个赋值的过程具体的原理是什么呢?</p><p>首先,我们创建了一个’空’对象,之所以我们打上引号,是因为这并不是一个严格意义上的空对象,因为在建立这个对象的过程中,JavaScript已经为这个对象内置了方法和属性,当然是不可见的,在属性的建立过程中就调用了一个隐式的方法<code>[[put]]</code>.</p><p>大概的创建过程是,当属性第一次被创建时,对象调用内部方法<code>[[put]]</code>为对象创建一个节点保存属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: person</span><br><span class="line">e=&gt;end: persen.name = &quot;Messi&quot;</span><br><span class="line">io1=&gt;inputoutput: [[put]]</span><br><span class="line"></span><br><span class="line">st-&gt;io1-&gt;e</span><br></pre></td></tr></table></figure></p><hr><h4 id="3-属性的修改"><a href="#3-属性的修改" class="headerlink" title="3.属性的修改"></a>3.属性的修改</h4><p>我们对上例中的代码做一下修改:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">"Messi"</span>;</span><br><span class="line">person.name = <span class="string">"Bale"</span>;</span><br></pre></td></tr></table></figure></p><p>很显然,<code>name</code>被创建后,该属就被进行了修改,原属性值<code>Messi</code>被修改为<code>Bale</code>,那么这个过程又是如何发生的呢?</p><p>其实对象内部除了隐式的<code>[[put]]</code>方法,还有一个<code>[[set]]</code>方法,这个方法不同于<code>[[put]]</code>在创建属性时调用,而是在同一个属性被再次赋值的时候用于更新属性进行的调用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: person.name = &quot;Messi&quot;</span><br><span class="line">e=&gt;end: persen.name = &quot;Bale&quot;</span><br><span class="line">io1=&gt;inputoutput: [[put]]</span><br><span class="line"></span><br><span class="line">st-&gt;io1-&gt;e</span><br></pre></td></tr></table></figure><hr><h4 id="4-属性的查询"><a href="#4-属性的查询" class="headerlink" title="4.属性的查询"></a>4.属性的查询</h4><p>判断一个属性或者方法是否在一个对象中,通常有两种方式.<br><code>in</code>操作符方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Messi"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p><code>hasOwnProperty</code>方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Messi"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><h4 id="5-属性的删除"><a href="#5-属性的删除" class="headerlink" title="5.属性的删除"></a>5.属性的删除</h4><p>删除一个属性,最正确的方式是用<code>delete</code>方法,一个错误的方式是将该属性赋值为<code>null</code>,该方式的错误之处在于赋值<code>null</code>相当于调用了[[set]]方法把原属性值更改为了<code>null</code>,这个保存属性的节点依然存在,而用<code>delete</code>方法便能彻底删除这个节点.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Messi"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><h4 id="6-属性的枚举"><a href="#6-属性的枚举" class="headerlink" title="6.属性的枚举"></a>6.属性的枚举</h4><p>我们通常用<code>for...in</code>枚举对象中的属性,它会将属性一一返回.<br>在ES5中引入了一个新的方法<code>Object.key()</code>,不同之处在于,它可以将结果以数组的形式返回<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Messi"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> pros <span class="keyword">in</span> person ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pros); <span class="comment">// name age </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pros = <span class="built_in">Object</span>.keys(person);</span><br><span class="line"><span class="built_in">console</span>.log(pros); <span class="comment">//[ 'name', 'age' ]</span></span><br></pre></td></tr></table></figure></p><blockquote><p>值得注意的是,并非所有的属性都是可枚举的,例如对象自带的属性<code>length</code>等等,因此我们可以用<code>propertyIsEnumerable()</code>方法来判断一个属性是否可枚举.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;六、属性&quot;&gt;&lt;a href=&quot;#六、属性&quot; class=&quot;headerlink&quot; title=&quot;六、属性&quot;&gt;&lt;/a&gt;六、属性&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-JavaScript中的对象&quot;&gt;&lt;a href=&quot;#1-JavaScript中的对象&quot; class=
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/categories/JavaScript/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="https://zaizizaizai.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
