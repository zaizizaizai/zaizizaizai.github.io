<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zaizizaizai</title>
  
  <subtitle>a dream of a child</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zaizizaizai.github.io/"/>
  <updated>2020-05-06T07:06:41.235Z</updated>
  <id>https://zaizizaizai.github.io/</id>
  
  <author>
    <name>pinocchio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>binder监测连接状态</title>
    <link href="https://zaizizaizai.github.io/2020/05/06/binder%E7%9B%91%E6%B5%8B%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>https://zaizizaizai.github.io/2020/05/06/binder监测连接状态/</id>
    <published>2020-05-06T07:05:34.000Z</published>
    <updated>2020-05-06T07:06:41.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binder监测连接状态，以及断开后的重连"><a href="#Binder监测连接状态，以及断开后的重连" class="headerlink" title="Binder监测连接状态，以及断开后的重连"></a>Binder监测连接状态，以及断开后的重连</h1><h3 id="一、监测连接状态"><a href="#一、监测连接状态" class="headerlink" title="一、监测连接状态"></a>一、监测连接状态</h3><h3 id="1-binder对象死亡通知机制"><a href="#1-binder对象死亡通知机制" class="headerlink" title="1. binder对象死亡通知机制"></a>1. binder对象死亡通知机制</h3><h4 id="1-1-注册死亡通知"><a href="#1-1-注册死亡通知" class="headerlink" title="1.1. 注册死亡通知"></a>1.1. 注册死亡通知</h4><p>client和server通过binder通信，且binder提供一个方法，即传入死亡代理binder.linkToDeath(IBinder.DeathRecipient) ，当client于server断开的时候，client收到DeathRecipient的binderDied()方法回调 ，从而知道连接断开，以下为binder源码：</p><ul><li><p>BBinder::linkToDeath ()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::linkToDeath(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;&amp; <span class="comment">/*recipient*/</span>, <span class="keyword">void</span>* <span class="comment">/*cookie*/</span>,</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="comment">/*flags*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;<span class="comment">// 返回无效操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server端的linkToDeath只返回无效操作</p></li><li><p>BpBinder::linkToDeath ()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::linkToDeath(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DeathRecipient&gt;&amp; recipient, <span class="keyword">void</span>* cookie, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    Obituary ob;</span><br><span class="line">    ob.recipient = recipient;</span><br><span class="line">    ob.cookie = cookie;<span class="comment">//标识死亡接收者</span></span><br><span class="line">    ob.flags = flags;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(recipient == <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="string">"linkToDeath(): recipient must be non-NULL"</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mObitsSent) &#123;<span class="comment">//mObitsSent用来表示Binder驱动程序是否已经向它发送过死亡通知，如果是，直接返回DEAD_OBJECT</span></span><br><span class="line">            <span class="keyword">if</span> (!mObituaries) &#123;<span class="comment">//第一次注册</span></span><br><span class="line">                mObituaries = <span class="keyword">new</span> Vector&lt;Obituary&gt;;<span class="comment">//死亡通知对象列表</span></span><br><span class="line">                <span class="keyword">if</span> (!mObituaries) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">                &#125;</span><br><span class="line">                ALOGV(<span class="string">"Requesting death notification: %p handle %d\n"</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line">                getWeakRefs()-&gt;incWeak(<span class="keyword">this</span>);<span class="comment">//增加了弱引用计数</span></span><br><span class="line">                IPCThreadState* self = IPCThreadState::self();</span><br><span class="line">                self-&gt;requestDeathNotification(mHandle, <span class="keyword">this</span>);<span class="comment">// 记录对象</span></span><br><span class="line">                self-&gt;flushCommands();<span class="comment">//促使当前线程马上通过IO控制命令BINDER_WRITE_READ进入到Binder驱动程序中，以便可以执行注册死亡接受通知的操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">ssize_t</span> res = mObituaries-&gt;add(ob);<span class="comment">//非第一个注册</span></span><br><span class="line">            <span class="keyword">return</span> res &gt;= (<span class="keyword">ssize_t</span>)NO_ERROR ? (<span class="keyword">status_t</span>)NO_ERROR : res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Binder代理对象内部的成员变量mObitsSent用来表示Binder驱动程序是否已经向它发送过死亡通知</p><ul><li>若是，表示Binder本地对象已经死亡，返回DEAD_OBJECT</li><li>若否，<ul><li>若第一次注册，记录Binder代理对象的地址，并立马调用Binder Driver执行注册死亡通知</li><li>非第一次注册，直接加入死亡通知对象列表mObituaries</li></ul></li></ul></li><li><p>binderDied()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBinder</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DeathRecipient</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">(<span class="keyword">const</span> wp&lt;IBinder&gt;&amp; who)</span> </span>= <span class="number">0</span>;<span class="comment">//重写父类DeathRecipient的成员函数binderDied</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 自定义的死亡通知接受者必须要重写父类DeathRecipient的成员函数binderDied。当Binder驱动程序通知一个Binder代理对象它所引用的Binder本地对象已经死亡时，就会调用它所指定的死亡通知接受者的成员函数binderDied </p></li><li><p>简述流程</p><ul><li>Binder代理对象将一个死亡接收通知注册到Binder驱动程序中</li><li>当Binder驱动程序监控到它所引用的Binder本地对象死亡时，Binder驱动程序就会向Binder代理对象发送一个死亡通知 </li></ul><p>由BBinder::linkToDeath ()和BpBinder::linkToDeath ()代码可见</p><ul><li>server进程死亡时，运行在其里的Binder对象就死亡，通过比较Binder代理存在，本地对象为空可知server端死亡，会通知到client代理对象，pmcs模块中即为BnPmcsProxy对象</li><li>client进程死亡时，没有通知任何对象。这时候Binder驱动程序就应该向那些引用了它的Binder代理对象发送死亡接受通知，以便它们可以知道自己引用了一个无效的Binder本地对象 </li></ul></li><li><p>一句话总结</p><p>client可以知道连接断开，server不知道什么时候断开，只有通过连接它的client来获得连接状态</p></li></ul><h4 id="1-2-发送死亡接收通知"><a href="#1-2-发送死亡接收通知" class="headerlink" title="1.2. 发送死亡接收通知"></a>1.2. 发送死亡接收通知</h4><p>​    暂略</p><h3 id="2-client检测连接状态"><a href="#2-client检测连接状态" class="headerlink" title="2. client检测连接状态"></a>2. client检测连接状态</h3><p>由 binder对象死亡通知机制 可知，client端(PmcsProxy )可通过binder.linkToDeath(IBinder.DeathRecipient)获得连接状态，即server挂掉，通知Binder代理对象</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> PmcsProxy::attachServer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IPmcsService&gt;&amp; service(getPmcsService());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(service.get() != <span class="keyword">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDeathNotifier == <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            mDeathNotifier = <span class="keyword">new</span> DeathNotifier&lt;PmcsProxy&gt;(this);</span><br><span class="line">        &#125;</span><br><span class="line">        service-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier);<span class="comment">// 注册死亡通知</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-server检测连接状态"><a href="#3-server检测连接状态" class="headerlink" title="3. server检测连接状态"></a>3. server检测连接状态</h3><p>由 binder对象死亡通知机制 可知，server自身无法检测连接状态，只能通过与server端连接的client端来获取连接状态，即通过client端(PmcsProxy )的binder.linkToDeath(IBinder.DeathRecipient)，那么server端只要获取到client对象就可以检测连接状态</p><ul><li>server如何获取和区分client？两种方法<ul><li>server端给每个连接上的client端一个标识token<ul><li>client类增加一个token属性</li><li>当创建一个client时，server给其分配一个token标识</li></ul></li><li>利用Binder的static方法，Binder.getCallingPid()来拿到client端的pid</li></ul></li></ul><h3 id="二、连接断开后的重连"><a href="#二、连接断开后的重连" class="headerlink" title="二、连接断开后的重连"></a>二、连接断开后的重连</h3><p>由上文 监测连接状态 可知，在重写binderDied函数时，再次连接就好了</p><ul><li>client检测到server断开，client重启server</li><li>server检测到client断开，server重创建一个client</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binder监测连接状态，以及断开后的重连&quot;&gt;&lt;a href=&quot;#Binder监测连接状态，以及断开后的重连&quot; class=&quot;headerlink&quot; title=&quot;Binder监测连接状态，以及断开后的重连&quot;&gt;&lt;/a&gt;Binder监测连接状态，以及断开后的重连&lt;/
      
    
    </summary>
    
      <category term="android" scheme="https://zaizizaizai.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://zaizizaizai.github.io/tags/android/"/>
    
      <category term="源码分析" scheme="https://zaizizaizai.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>binder-LinkToDeath</title>
    <link href="https://zaizizaizai.github.io/2020/05/06/binder-LinkToDeath/"/>
    <id>https://zaizizaizai.github.io/2020/05/06/binder-LinkToDeath/</id>
    <published>2020-05-06T06:55:51.000Z</published>
    <updated>2020-05-06T07:04:57.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pmcs类图理解"><a href="#Pmcs类图理解" class="headerlink" title="Pmcs类图理解"></a>Pmcs类图理解</h1><h3 id="1-名词定义"><a href="#1-名词定义" class="headerlink" title="1. 名词定义"></a>1. 名词定义</h3><table><thead><tr><th style="text-align:center">名词</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">BBinder</td><td style="text-align:center">服务端接口</td></tr><tr><td style="text-align:center">BpBinder</td><td style="text-align:center">客户端接口</td></tr></tbody></table><h3 id="2-使用Binder流程"><a href="#2-使用Binder流程" class="headerlink" title="2. 使用Binder流程"></a>2. 使用Binder流程</h3><ul><li>开发native service<ol><li>定义服务端接口文件，即IPmcsService类，其继承于IInterface类</li><li>定义BnPmcsService类，继承于BnInterface<ipmcsservice></ipmcsservice></li><li>实现一个PmcsService类，继承于BnPmcsService类，并实现响应客户端请求onTransact()</li></ol></li><li>开发client</li></ul><p>BpBinder(客户端)如何把请求发送给BBinder(服务端)，BBinder又如何将响应传回给客户端的呢?</p><h3 id="3-BBinder服务端"><a href="#3-BBinder服务端" class="headerlink" title="3. BBinder服务端"></a>3. BBinder服务端</h3><p><img src="../images/android/server.png" alt="服务端类"></p><ul><li><strong>BBinder</strong> 实现了大部分的IBinder 接口，除了onTransact() 和 queryLocalInterface()， getInterfaceDescriptor() </li><li><strong>IInterface</strong><ul><li>实现queryLocalInterface()，该函数可查询服务端提供的服务</li><li>INTERFACE模板继承和实现IInterface</li></ul></li><li><strong>BnInterface</strong><ul><li>BnInterface<interface> 对象将自己强制转换成 IInterface对象返回给客户端</interface></li><li><strong>BnInterface</strong>是一个模板类，继承了<strong>BBinder</strong>和模板<strong>INTERFACE</strong></li><li>BnInterface 实现了IBinder的queryLocalInterface()和getInterfaceDescriptor() </li></ul></li><li><strong>BnPmcsServer</strong>同时继承<strong>IInterface</strong>和<strong>IBinder</strong>，定义了onTransact()，没有实现</li><li><strong>PmcsService</strong>里具体实现了onTransact()</li></ul><h3 id="4-BpBinder客户端"><a href="#4-BpBinder客户端" class="headerlink" title="4. BpBinder客户端"></a>4. BpBinder客户端</h3><p>​    目标：找到一个类，它必须同时拥有IBinder 和 IIterface的特性 </p><p><img src="../images/android/client.png" alt="client"></p><ul><li><strong>BpRefBase</strong>里有<strong>IBinder</strong>成员变量</li><li><strong>BpInterface</strong><ul><li>BpInterface继承于BpRefBase，而BpRefBase里有IBinder成员变量，从而获取到IBinder特性</li><li>BpInterface继承于INTRFACE，这里INTRFACE就是IPmcsService</li></ul></li><li><strong>IInterface</strong>中函数asBinder()-&gt;BpInterface::onAsBinder()-&gt;BpInterface::remote()，返回得到mRemote </li><li><strong>BpPmcsService</strong>为客户端，具体向服务端发起请求</li><li><strong>PmcsProxy</strong>为客户端的回调，服务端响应完请求后，调用回调向调用发起者通知执行结果</li></ul><p><strong>BpRefbase的mRemote是如何被赋值的？</strong> </p><p>最后追溯到 IPmcsService.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder()); <span class="comment">//reply里读出IBinder,然后转成IMediaPlayer接口对象</span></span><br></pre></td></tr></table></figure><p>通过子类一级一级注入，即new一个BpPmcsService，然后将其转换为父父类IPmcsService</p><p><strong>客户端流程</strong></p><p>​    客户端从远端生成一个IBinder对象，再生成BpPmcsService，将其转换为IpmcsService接口对象，调用其接口方法，最终调用到BpBinder的transact()</p><p>​    而客户端的transact()函数通过<strong>Binder Driver</strong>获取到BBinder对象(IBinder的实现)，并调用onTransact()</p><h3 id="5-总流程"><a href="#5-总流程" class="headerlink" title="5. 总流程"></a>5. 总流程</h3><p><img src="../images/android/pmcs.png" alt="pmcs"></p><ul><li>应用程序的角度<ol><li>已知服务名，APP通过getService() 从ServiceManager 获取存储在<strong>Parcel对象</strong>的服务的信息</li><li>APP收到Parcel对象 (通过kernel)，获取到服务对应的服务号，mHandle</li><li>以mHandle作为参数输入生成一个IBinder对象(实际是<strong>BpBinder</strong>)</li><li>APP获取到IBinder对象，通过asInterface(IBinder<em>)生成服务对应的Proxy对象(BpPmcsService)，将其强转到<em>*IPmcsService</em></em>，调用接口函数</li><li>所有的接口对象调用最终会走到<strong>BpBinder-&gt;transact</strong>()函数，这个函数调用IPCThreadState-&gt;transact()并以Service号作为参数之一 </li><li>最终通过系统调用ioctrl() 进入内核空间，Binder驱动根据传进来的Service 号寻找该Service正处于等待状态的Binder Thread, 唤醒它并在该线程内执行相应的函数，并返回结果给APP </li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Pmcs类图理解&quot;&gt;&lt;a href=&quot;#Pmcs类图理解&quot; class=&quot;headerlink&quot; title=&quot;Pmcs类图理解&quot;&gt;&lt;/a&gt;Pmcs类图理解&lt;/h1&gt;&lt;h3 id=&quot;1-名词定义&quot;&gt;&lt;a href=&quot;#1-名词定义&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="android" scheme="https://zaizizaizai.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://zaizizaizai.github.io/tags/android/"/>
    
      <category term="通信机制" scheme="https://zaizizaizai.github.io/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>图像处理算法</title>
    <link href="https://zaizizaizai.github.io/2020/05/06/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zaizizaizai.github.io/2020/05/06/图像处理算法/</id>
    <published>2020-05-06T06:52:18.000Z</published>
    <updated>2020-05-06T07:02:37.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-模糊-滤波"><a href="#A-模糊-滤波" class="headerlink" title="A.模糊(滤波)"></a>A.模糊(滤波)</h2><h3 id="1-归一化盒子滤波-BoxFilter"><a href="#1-归一化盒子滤波-BoxFilter" class="headerlink" title="1.归一化盒子滤波(BoxFilter)"></a>1.归一化盒子滤波(BoxFilter)</h3><ul><li><p>主要功能：在给定的滑动窗口下，对每个窗口内的像素值进行快速相加求和</p></li><li><p>缺点：无法克服边缘像素信息丢失缺陷，原因是均值滤波是基于平均权重</p></li><li><p>原理：</p><p><img src="../images/opencv/boxFilter.png" alt=""></p><ol><li>给定图像，宽高为(M,N)，确定待求矩形模板的宽高(m,n)，如图紫色矩形。图中黑色方块代表像素点，红色方块代表假象像素。</li><li>开辟一段大小为M的数组，记为buff，用来储存计算过程中的，存在红色假象像素点中</li><li>将矩形模板(紫色)从左上角，从左往右，从上往下单元素移动，每移动到新位置，计算矩形内的像素和保存在数组A(输出图片)中。以(0,0)位置为例：<ul><li>将绿色矩形内的每一列像素求和，结果放在buff内(红色方块)</li><li>对蓝色矩形内的像素点求和，结果即为紫色特征矩形内的像素和，把它存放到数组A</li></ul></li><li>每次紫色矩形向右移动时，实际上就是求对应的蓝色矩形的像素和，此时只需把上次的求和结果减去蓝色矩形内的第一个红色快，再加上其右边的红色块，就是当提前位置的和，公式表达为：sum[i] = sum[i-1] - buf[x-1] + buff[x+m-1]</li><li>当紫色矩形移动到行末时，需对buff进行更新。因整个绿色矩形下移一个像素，所以对于每个buff[i]需要加一个新进来的像素，再减去一个出去的像素，开始新一行的计算</li></ol></li><li><p>此处为原理流程，源码见代码部分</p></li></ul><h3 id="2-高斯滤波"><a href="#2-高斯滤波" class="headerlink" title="2.高斯滤波"></a>2.高斯滤波</h3><ul><li>功能：</li><li>缺点：部分克服边缘像素信息丢失缺陷，但无法完全避免，因为没有考虑像素值的不同</li><li>原理：</li></ul><h3 id="3-中值滤波"><a href="#3-中值滤波" class="headerlink" title="3.中值滤波"></a>3.中值滤波</h3><ul><li>功能：</li><li>缺点：部分克服边缘像素信息丢失缺陷，但无法完全避免，因为没有考虑像素值的不同</li><li>原理：</li></ul><h3 id="4-双边滤波"><a href="#4-双边滤波" class="headerlink" title="4.双边滤波"></a>4.双边滤波</h3><ul><li>功能：</li><li>优缺点：避免边缘信息丢失，保留图像轮廓不变</li><li>原理：</li></ul><h2 id="B-形态学操作"><a href="#B-形态学操作" class="headerlink" title="B.形态学操作"></a>B.形态学操作</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><table><thead><tr><th style="text-align:center">形态学定义</th><th style="text-align:center">函数定义</th><th style="text-align:center">原理</th><th style="text-align:center">应用</th></tr></thead><tbody><tr><td style="text-align:center">膨胀</td><td style="text-align:center">dilate</td><td style="text-align:center">取领域内最大值作为中心点新像素值</td><td style="text-align:center">前景为黑，变小；前景为白，变大</td></tr><tr><td style="text-align:center">腐蚀</td><td style="text-align:center">erode</td><td style="text-align:center">取领域内最小值作为中心点新像素值</td><td style="text-align:center">前景为黑，变大；前景为白，变小</td></tr><tr><td style="text-align:center">开操作</td><td style="text-align:center">open</td><td style="text-align:center">先腐蚀后膨胀(注意：结构元素需设置为包含部分目标对象)</td><td style="text-align:center">假设对象是前景色，背景是黑色，可以去掉小的对象</td></tr><tr><td style="text-align:center">闭操作</td><td style="text-align:center">close</td><td style="text-align:center">先膨胀后腐蚀</td><td style="text-align:center">假设对象是前景色，背景是黑色，可以填补小的洞</td></tr><tr><td style="text-align:center">形态学梯度</td><td style="text-align:center">Morphological Gradient</td><td style="text-align:center">膨胀减腐蚀，dst = morph(src, element) = dilate(src, element) - erode(src, element)</td><td style="text-align:center">又称为基本梯度(其他还包括内部梯度、方向梯度)</td></tr><tr><td style="text-align:center">顶帽</td><td style="text-align:center">top hat</td><td style="text-align:center">源图像与开操作之间的差值图像</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">黑帽</td><td style="text-align:center">black hat</td><td style="text-align:center">闭操作与源图像的差值图像</td></tr></tbody></table><h2 id="2-提取水平与垂直线"><a href="#2-提取水平与垂直线" class="headerlink" title="2.提取水平与垂直线"></a>2.提取水平与垂直线</h2><ul><li>提取步骤<ul><li>输入彩色图像-imread</li><li>转换为灰度图像-cvtColor</li><li>转换为二值图像-adaptiveThreshold</li><li>定义结构元素</li><li>开操作(腐蚀+膨胀)提取水平与垂直线</li></ul></li><li>启示：<ul><li>卷积核可根据需要更改形状，从原图提取想要的形状</li><li>提取文字、图像(去除干扰点)，可用不同卷积核</li></ul></li></ul><h2 id="C-图像上采样和降采样"><a href="#C-图像上采样和降采样" class="headerlink" title="C.图像上采样和降采样"></a>C.图像上采样和降采样</h2><ul><li><strong>图像金字塔</strong>：<ul><li>高斯金字塔：用来对图像进行降采样<ul><li>从底向上，逐层降采样得到</li><li>降采样之后，图像大小是原图M<em>N的M/2 </em> N/2（1/4），即对原图像删除偶数行与列，得到降采样后上一层的图片</li><li>两步生成过程：<ul><li>对当前层进行高斯模糊</li><li>删除当前层的偶数行与列</li></ul></li></ul></li><li>高斯不同：<ul><li>定义：把同一张图像在不同的参数下做高斯模糊之后的结果相减，得到的输出图像成为高斯不同(DOG)</li><li>高斯不同是图像的内在特征，在灰度图像增强‘角点检测中常用到 </li></ul></li><li>拉普拉斯金字塔：用来重建一张图片，根据它的上层降采样图片</li></ul></li></ul><h2 id="D-基本阈值操作"><a href="#D-基本阈值操作" class="headerlink" title="D.基本阈值操作"></a>D.基本阈值操作</h2><ul><li>图像阈值<ul><li>定义：图像分割的标尺</li><li>阈值产生的算法<ul><li>THRESH_OTSU</li><li>THRESH_TRIANGLE</li></ul></li><li>阈值类型<ul><li>阈值二值化(threshold binary)：大于取阈值，小于取零</li><li>阈值反二值化(threshold binary inverted)：大于取零，小于取阈值</li><li>截断(truncate)：大于处取阈值，小于不变</li><li>阈值取零(threshold to zero)：大于不变，小于取零</li><li>阈值反取零(threshold to zero inverted)：大于取零，小于不变</li></ul></li></ul></li></ul><h2 id="E-自定义线性滤波"><a href="#E-自定义线性滤波" class="headerlink" title="E.自定义线性滤波"></a>E.自定义线性滤波</h2><ul><li>卷积概念<ul><li>卷积是图像处理中一个操作，是kernrl在图像的每个像素上的操作</li><li>kerner本质上是一个固定大小的矩阵数组，其中中心点为锚点(anchor point)</li><li>求锚点周围覆盖的像素乘积之和(包括锚点)，除以卷积数组大小，用来替代锚点下像素点值</li></ul></li><li>常见算子<ul><li>Robert算子：2*2，{1, 0, 0, -1}或{0, 1, -1, 0}，寻找梯度、边缘</li><li>Sobel算子：3*3，{-1, 0, 1, -2, 0, 2, -1, 0, 1}或{-1, -2, -1, 0, 0, 0, 1, 2, 1}，常用于边缘检测</li><li>拉普拉斯算子：3*3，{0, -1, 0, -1, 4, -1, 0, -1, 0},寻找梯度、边缘</li></ul></li><li>自定义卷积模糊</li></ul><h2 id="F-边缘处理"><a href="#F-边缘处理" class="headerlink" title="F.边缘处理"></a>F.边缘处理</h2><ul><li>卷积边缘问题：<ul><li>图像卷积的时候边界像素不能被卷积操作</li><li>原因在于边界像素没有完全跟kernel重叠</li></ul></li><li>边缘处理<ul><li>在卷积开始之前增加边缘像素，填充像素值为0或RGB黑色</li><li>opencv中默认方法为：BORDER_DEFAULT<ul><li>BORDER_CONSTANT - 用指定像素值填充边缘</li><li>BORDER_REPLICATE - 用已知的边缘像素值填充边缘像素</li><li>BORDER_WRAP - 用另外一边的像素来补偿填充</li></ul></li></ul></li></ul><h2 id="G-sobel算子"><a href="#G-sobel算子" class="headerlink" title="G.sobel算子"></a>G.sobel算子</h2><ul><li>卷积应用-图像边缘提取<ul><li>图像像素值渐变或突变，求导取最高点即为跃迁点(变化最大)</li></ul></li><li>Sobel算子<ul><li>Sobel算子：3*3，{-1, 0, 1, -2, 0, 2, -1, 0, 1}或{-1, -2, -1, 0, 0, 0, 1, 2, 1}，常用于边缘检测</li><li>是离散微分算子(discrete differentiation operator)，用来计算图像灰度的近似梯度</li><li>Sobel算子功能集合高斯平滑和微分求导</li><li>又称为一阶微分算子，求导算子，在水平和垂直两方向求导，再平方和开根号(绝对值之和)，得到(图像x与y方向)梯度图像</li></ul></li><li>Schar函数<ul><li>求取导数的近似值，kernel=3时不准确，opencv使用改进版本Scharr函数，3*3，{-3, 0, 3, -10, 0, 10, -3, 3}或{-3, -10, 3, 0, 0, 0, 3, 10, 3}</li></ul></li><li>代码流程<ul><li>高斯平滑：使图像像素平滑变化</li><li>转灰度</li><li>求梯度x和y</li><li>混合xy</li></ul></li><li>个人理解：<ul><li>用卷积和扩大水平/垂直像素差异</li></ul></li></ul><h2 id="H-laplance算子"><a href="#H-laplance算子" class="headerlink" title="H.laplance算子"></a>H.laplance算子</h2><ul><li>原理<ul><li>比sobel算子更进一步，这里采用 二阶导为零处即为像素值变化最大处</li></ul></li><li>流程<ul><li>高斯模糊-去噪声GaussianBlur()</li><li>转灰度cvtColor()</li><li>拉普拉斯-二阶导计算Laplance()</li><li>取绝对值convertScaleAbs()</li></ul></li></ul><h2 id="I-Canny边缘检测"><a href="#I-Canny边缘检测" class="headerlink" title="I.Canny边缘检测"></a>I.Canny边缘检测</h2><ul><li>流程：<ul><li>高斯模糊GaussianBlur<ul><li>将高斯算子与原图像卷积</li></ul></li><li>灰度转换cvtColor</li><li>计算梯度Sobel/Scharr：像素值差异的地方</li><li>非最大信号抑制<ol><li>将当前像素的梯度强度与沿正负方向梯度方向上的两个像素比较</li><li>若当前像素的梯度强度与另外两个像素相比最大，则该像素点保留位边缘点，否则该像素点会被抑制</li></ol></li><li>高低阈值输出二值图像：抑制噪声引起的弱边缘</li></ul></li></ul><h2 id="J-霍夫变换"><a href="#J-霍夫变换" class="headerlink" title="J.霍夫变换"></a>J.霍夫变换</h2><ul><li><p>霍夫直线变换</p><ul><li>简介<ul><li>用来做直线检测</li><li>前提条件：边缘检测已完成</li><li>平面空间到极坐标空间转换</li></ul></li><li>原理<ul><li>图形原理在notability中，后续整理</li><li>r = x <em> cos(theta) + y </em> sin(theta)<ol><li>canny边缘检测</li><li>逐像素点进行霍夫空间变换：由像素坐标系(x,y)变换到笛卡尔坐标系(r, theta)</li><li>局部非极大值抑制：去除噪声点</li><li>对笛卡尔坐标系中的点排序</li><li>求得笛卡尔坐标系中点极大值对应的角度和距离</li><li>将笛卡尔坐标转为像素坐标，画线</li></ol></li></ul></li></ul></li><li><p>霍夫圆变换(21HT)</p><ul><li><p>$r^2 = (x-a)^2 + (y-b)^2$</p></li><li><p>第一阶段：检测圆心</p><ul><li>（中值滤波：去除噪声）</li></ul><ol><li>canny边缘检测</li><li>sobel计算图形梯度，并确定圆周线，其中圆周的梯度就是其法线</li><li>在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心 </li><li>在霍夫空间的4邻域内进行非最大值抑制 </li><li>设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心 </li></ol></li><li><p>第二阶段：检测半径</p><ol><li>计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量</li><li>设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小 </li><li>对保留下来的距离进行排序</li><li>找到距离相同的那些值，并计算相同值的数量 </li><li>设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径 </li><li>对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径 </li></ol></li></ul></li></ul><h2 id="K-像素重映射"><a href="#K-像素重映射" class="headerlink" title="K.像素重映射"></a>K.像素重映射</h2><ul><li>定义：g(x, y) = f(h(x, y))<ul><li>把输入图像中各个像素按照一定规则映射到另一张图像对应位置</li></ul></li><li>cv::remap()</li></ul><h2 id="L-直方图均衡化"><a href="#L-直方图均衡化" class="headerlink" title="L.直方图均衡化"></a>L.直方图均衡化</h2><ul><li>图像直方图<ul><li>定义：统计整个图像在灰度范围内的像素值(0-255)出现的频率次数</li><li>反映：图像灰度的分布情况</li></ul></li><li>流程<ol><li>计算原图像素值概率</li><li>从小到大累加像素值概率</li><li>用 累加概率 * 像素最大值 之积 替换原图像像素值</li></ol></li><li>cv::equalizeHist(src, dst)<ul><li>输入为灰度图</li></ul></li><li>应用：提高图像对比度、拉伸图像灰度值范围，同时图像的细节更为丰富 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A-模糊-滤波&quot;&gt;&lt;a href=&quot;#A-模糊-滤波&quot; class=&quot;headerlink&quot; title=&quot;A.模糊(滤波)&quot;&gt;&lt;/a&gt;A.模糊(滤波)&lt;/h2&gt;&lt;h3 id=&quot;1-归一化盒子滤波-BoxFilter&quot;&gt;&lt;a href=&quot;#1-归一化盒子滤波-Bo
      
    
    </summary>
    
      <category term="图像处理" scheme="https://zaizizaizai.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="opencv" scheme="https://zaizizaizai.github.io/tags/opencv/"/>
    
      <category term="图像处理，人工智障" scheme="https://zaizizaizai.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>Learning OpenCV3</title>
    <link href="https://zaizizaizai.github.io/2020/05/06/Learning-OpenCV3/"/>
    <id>https://zaizizaizai.github.io/2020/05/06/Learning-OpenCV3/</id>
    <published>2020-05-06T06:47:06.000Z</published>
    <updated>2020-05-06T07:01:34.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Learning-OpenCV3"><a href="#Learning-OpenCV3" class="headerlink" title="Learning OpenCV3"></a>Learning OpenCV3</h1><h2 id="一、Overview"><a href="#一、Overview" class="headerlink" title="一、Overview"></a>一、Overview</h2><h3 id="1-计算机视觉概念"><a href="#1-计算机视觉概念" class="headerlink" title="1.计算机视觉概念"></a>1.计算机视觉概念</h3><p>类比于人在道路两侧停放的车中寻找特定的车，图像信号通过眼睛传输到大脑，大脑有注意力识别系统：通过任务依赖的方式，检查图像重要区域，抑制其他区域。利用人生活多年来形成的交叉关联的感觉识别重要信息，再由大脑的反馈回路返回到传感器(眼睛肌肉)，进一步去获取需要的图像。</p><p>###2.遇到的问题</p><p>用2D去描绘3D世界的误差，数据的失真和噪声破坏。具体如下：</p><ul><li><p><strong>上下文信息</strong>：</p><ul><li><p>例子：</p><p>机器人在房子里捡起订书机，首先机器人可能会用到以下事实：办公桌是办公室内的对象，而订书机是最大可能在办公桌上找到，这是一个隐式的大小位置参考；且机器人需要忽略相同大小形状的小木盒、以及墙画上的订书机图片。</p><p>相反，对于图像检索任务，机器人查询的数据库里都是真实的订书机，很可能就只拍摄了正常尺寸的订书机；在拍摄这些图片时，也隐藏这很多无意的隐式信息。</p></li><li><p>解决：</p><p>使用机器学习进行显示建模，对隐藏变量(大小、形状、重力方向等)用与他们值相关的标签训练集中进行校正。或者使用其他传感器测量隐藏的偏差分量。</p></li></ul></li><li><p><strong>噪音</strong></p><ul><li><p>例子：</p><p>仅通过几个点比较无法检查出物体边缘，有些像素点可能在生成、传输的途中遭到破坏，不能准确识别。</p></li><li><p>解决</p><p>统计局部区域可较准确的进行边缘检测</p><p>通过建立直接从数据中学到的显式模型来描述，如人们已经很了解镜头畸变，只需建立一个多项式模型参数，通过调整参数从而更正失真。</p></li></ul></li></ul><h2 id="二、opencv入门示例"><a href="#二、opencv入门示例" class="headerlink" title="二、opencv入门示例"></a>二、opencv入门示例</h2><p>简单的入门示例，这里有一个正好前段时间涉及到的边缘检测算法(二值化-&gt;区分前后景)，效果如下：</p><p>​    阈值为1、10，可以看到边缘检测很不清晰，把很多rgb值高的点也包含进来</p><p><img src="../images/opencv/1-10.png" alt="阈值为1，10"></p><p>​    阈值为10、100，可以看到颜色较重的区域也能区分出来</p><p><img src="../images/opencv/10-100.png" alt="阈值10,100"></p><p>​    阈值为100、500，这样小鱼的边缘就很清晰了</p><p><img src="../images/opencv/100-500.png" alt="阈值100，500"></p><h2 id="三、OpenCV数据类型"><a href="#三、OpenCV数据类型" class="headerlink" title="三、OpenCV数据类型"></a>三、OpenCV数据类型</h2><p>从组织的角度来看，数据分为以下三类：</p><ul><li>c++原语(int, float等)：简单向量和矩阵、简单几何概念(点、矩阵、尺寸等)</li><li>辅助对象：抽象概念，如垃圾回收指针、切片对象、终止条件等</li><li>大数组类型</li></ul><h3 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h3><ul><li><p><strong>Point</strong></p><p>基于模板结构实现的，可以是任何类型的点</p><ul><li><p>分类：</p><ul><li>二维、三维、四维点</li><li>cv::Point2i，最后一个字母表示构造点的原语类型。（b:无符号字符，s:短整型，i:32位整数，f:32位浮点数，d:64位浮点数）</li></ul></li><li><p>操作：</p><p>|       运行方式       |           例子            |<br>| :——————: | :———————–: |<br>|     默认构造函数     |      cv::Point2i p;       |<br>|     复制构造函数     |    cv::Point3f p2(p1)     |<br>|      值构造函数      | cv::Point3d p(x0, x1, x2) |<br>|   转换为固定向量类   |        (cv::Vec3f)        |<br>|       访问成员       |           p.x;            |<br>|         点乘         |   float x = p1.dot(p2);   |<br>|      双精度点乘      |  double x = p1.ddot(p2);  |<br>|         叉乘         |       p1.cross(p2);       |<br>| 查询点p是否在矩形r里 |       p.inside(r);        |</p></li><li><p>cv::Scalar类  </p><p>四维点类，所有成员时双精度浮点数</p><p>|     运行方式      |                        示例                         |<br>| :—————: | :————————————————-: |<br>|   默认构造函数    |                    cv::Scalar s;                    |<br>|   复制构造函数    |                 cv::Scalar s2(s1);                  |<br>|    值构造函数     |            cv::Scalar s(x0, x1, x2, x3);            |<br>|    逐元素乘法     |                     s1.mul(s2);                     |<br>|   (四元数)共轭    | s.conj(); // (return cv::Scalar(s0, -s1, -s2, -s3)) |<br>| (四元数)real test |   s.isReal(); // (returns true if s1==s2==s3==0)    |</p><p>该类操作强制转换到固定向量类，与point类不同，cv::Scalar直接从固定向量类模板的实例化中继承</p></li></ul></li><li><p><strong>size</strong></p><p>size类类似于point类，类型有Size、Size2i、Size2f,唯一区别就是命名区别(x、y与width、height)</p><p>|   运行方式   |         示例         |<br>| :———-: | :——————: |<br>| 默认构造函数 |     cv::Size sz;     |<br>| 复制构造函数 |  cv::Size sz2(sz1);  |<br>|  值构造函数  | cv::Size2f sz(w, h); |<br>|   访问成员   | sz.width; sz.height; |<br>|   计算面积   |      sz.area();      |</p></li><li><p><strong>Rect</strong></p><p>矩形类包含point类的成员x，y(代表矩形左上角坐标)，和宽高类(矩形的大小)，但矩形不继承点类</p><p>|           运作方式           |               示例                |<br>| :————————–: | :——————————-: |<br>|       r1、r2矩形的交点       |  cv::Rect r3 = r1&r2; r1 &amp;= r2;   |<br>| 包含矩形r1、r2的最小面积矩形 | cv::Rect r3 = r1 ! r2; r1 |= r2; |<br>|         用x平移矩形r         |   cv::Rect rx = r + x; r += x;    |<br>|      将矩形r按大小s增大      |   cv::Rect rs = r + s; r += s;    |<br>|       比较矩形是否相等       |       bool eq = (r1 == r2);       |<br>|        比较矩形是否不        |       bool eq = (r1 != r2);       |</p></li></ul><ul><li><p><strong>RotatedRect</strong></p><p>c++ Opencv接口中为数不多的没有模板的类之一，相反，这是一个容器，保存了一个cv::Point2f(中心)，一个cv::Size2f(大小)和一个额外的浮点数(角度)，角度表示矩形围绕中心的旋转</p><p>|          运行方式          |              示例              |<br>| :————————: | :—————————-: |<br>|        默认构造函数        |     cv::RotatedRect rr();      |<br>|        复制构造函数        |   cv::RotatedRect rr2(rr1);    |<br>|       从两个角度构建       |    cv::RotatedRect(p1, p2);    |<br>| 值构造函数(点，大小，角度) | cv::RotatedRect(p, sz, theta); |<br>|          访问成员          | rr.center; rr.size; rr.angle;  |<br>|         返回角列表         |       rr.points(pts[4]);       |</p></li></ul><ul><li><p><strong>fixed matrix</strong></p><p>固定矩阵类是指在编译时位数已知的矩阵，其数据的所有内存都分配在堆栈上，意味着可以快速地分配和清理。在c++ Opencv接口中，固定矩阵类实际上是一个模板，是许多其他基本类的核心(固定向量类派自固定矩阵类，其他类则派生自固定向量类)。</p><p>|             运作方式             |                             示例                             |<br>| :——————————: | :———————————————————-: |<br>|           默认构造函数           |             cv::Matx33f m33f; cv::MAtx43d m43d;              |<br>|           复制构造函数           |                   cv::Matx22d m22d(n22d);                    |<br>|            值构造函数            |                    cv::Matx21f m(x0, x1);                    |<br>|          相同元素的矩阵          |                 m33f = cv::Matx33f::all(x);                  |<br>|              零矩阵              |                 m23d = cv::Matx23d::zeros();                 |<br>|             一个矩阵             |                 m16f = cv::Matx16f::ones();                  |<br>|           创建单位矩阵           |                  m33f = cv::Matx33f::eye();                  |<br>| 创建一个可容纳另一个对角线的矩阵 |            m31f = cv::Matx33f:diag(); //3<em>1的矩阵            |<br>|   创建一个具有均匀分布项的矩阵   |              m33f = cv::Matxf::randu(min, max);              |<br>|  创建一个具有正态分布条项的矩阵  |          m33f = cv::Matx33f::nrandn(mean, virance);          |<br>|             访问成员             |                        m(i, j); m(i);                        |<br>|             矩阵代数             |             m1 = m0;  m0 </em> m1; m0 + m1; m0 -m1;              |<br>|             单例代数             |                     m <em> a; a </em> m; m / a;                     |<br>|               比较               |                     m1 == m2; m1 != m2;                      |<br>|               点积               |                    m1.dot(m2); //m的精度                     |<br>|               点积               |                    m1.ddot(m2); //双精度                     |<br>|             重塑矩阵             |                 m91f = m33f.reshape<9, 1="">();                 |<br>|             类型转换             |                    m44f = (Matx44f)m44d;                     |<br>|            提取子矩阵            |                  m44f.get_minor<2,2>(i,j);                   |<br>|            提取第i行             |                     m14f = m44f.row(i);                      |<br>|            提取第j列             |                     m14f = m44f.col(j);                      |<br>|          提取矩阵对角线          |                     m41f = m44f.diag();                      |<br>|             计算转置             |                       n44f = m44f.t();                       |<br>|             求逆矩阵             |      n44f = m44f.inv(method); //默认方法为cv::DECOMP_LU      |<br>|           解线性方程组           | m31f = m33f.solve(rhs31f, method); m32f = m33f.solve2(rhs32f, method); // 模板表单，默认方法为DECOMP_LU |<br>|            逐元素乘法            |                         m1.mul(m2);                          |</2,2></9,></p><p>注意，许多固定矩阵函数相对于类都是静态的(作为类的成员而不是特定的成员直接访问他们)，如构造3*3的矩阵，cv::Mat33f::eye()。</p></li><li><p><strong>fixed vector</strong></p><p>固定向量类是从固定矩阵类派生的，可以看作cv::Matx&lt;&gt;的便捷功能。</p><p>|   运作方式   |         示例          |<br>| :———-: | :——————-: |<br>| 默认构造函数 | Vec2s v2s; Vec6f v6s; |<br>| 复制构造函数 |    Vec3s u3f(v3f);    |<br>|  值构造函数  |  Vec2f v2f(x0, x1);   |<br>|   访问成员   |    v4f[i]; v3w(j);    |<br>|   向量叉乘   |    v3f.cross(u3f);    |</p><p>主要便利是使用单顺序访问元素</p></li><li><p><strong>complex number</strong></p><p>复数类与STL复合体关联的类最实质的区别在于：在STL类中，通过real()和image()访问实数和虚数；而在OpenCV类中，直接访问公共成员变量re和im</p></li><li></li></ul><h3 id="2-辅助对象"><a href="#2-辅助对象" class="headerlink" title="2.辅助对象"></a>2.辅助对象</h3><ul><li><p><strong>TermCriteria</strong></p><p>停止条件</p></li><li><p><strong>Range</strong></p><p>范围</p></li><li><p><strong>Ptr模板和垃圾回收</strong></p><p>c++中智能指针，该指针是我们能创建对对象的引用，所有引用被计数，当引用超出范围时，智能指针的引用计数将减少，一旦所有引用(指针的实例)减到0，实例对象将被自动清除(已分配)。</p><p>与c++中智能指针类似，为想要“包装”的类对象实例化一个指针模板(cv::Ptr<matx33f> p = makePtr<cv::matx33f>())，模板对象的构造函数指向对象的指针。此操作后，智能指针p可像普通指针一样传递和使用(即，支持运算符operator*()和operator-&gt;()),可创建其他相同类型的对象，而不需要向它们传递新对象的指针。如：Ptr<mat33f> q，并将p的值赋给q。这里只有一个实际的p和q指向的cv::Mat33f对象，p和q都知道他们各自为1.若p消失(超出范围)，则q知道它时唯一剩下的对源实矩阵的引用；若q消失，且其析构函数被调用，q就知道它时唯一引用的指针，q会取消分配原始矩阵。</mat33f></cv::matx33f></matx33f></p></li><li><p><strong>Exception类和异常处理</strong></p></li><li><p><strong>DataType</strong></p><p>当OpenCV库函数需要传递特殊概念的数据类型时，可通过创建cv::DataType&lt;&gt;类型的对象来实现。传递的实际对象时这个模板的实例对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OpenCV中DataType的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">DataType</span>&lt;float&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type   work_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type channel_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type vec_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">      generix_type = <span class="number">0</span>,</span><br><span class="line">      depth        = DataDepth&lt;channel_type&gt;::value,</span><br><span class="line">      channels     = <span class="number">1</span>,</span><br><span class="line">      fmt          = DataDepth&lt;channel_type&gt;::fmt,</span><br><span class="line">      type         = CV_MAKETYPE(depth, channels)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>InputArray和OutputArray</strong></p><p>输入、输出对象</p></li></ul><h3 id="3-实用函数"><a href="#3-实用函数" class="headerlink" title="3.实用函数"></a>3.实用函数</h3><p>除了上述专用原始数据类型，OpenCV还提供一些有效处理数学运算和其他运算的专用功能，该使用功能包含数学工具、测试、错误生成、内存和线程处理、优化等</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">cv::aliginPtr()</td><td style="text-align:center">将指针对齐到给定的字节数</td></tr><tr><td style="text-align:center">cv::aliginSize()</td><td style="text-align:center">将缓冲区大小与给定的字节数对齐</td></tr><tr><td style="text-align:center">cv :: allocate()</td><td style="text-align:center">分配c样式的对象数组</td></tr><tr><td style="text-align:center">cvCeil()</td><td style="text-align:center">将浮点数向上取整</td></tr><tr><td style="text-align:center">cv::cubeRoot()</td><td style="text-align:center">计算立方根</td></tr><tr><td style="text-align:center">cv::CV_Assert()</td><td style="text-align:center">若给定条件不成立，则引发异常</td></tr><tr><td style="text-align:center">CV_Error()</td><td style="text-align:center">宏以构建cv :: Exception （从固定字符串）并将其抛出</td></tr><tr><td style="text-align:center">CV<em>Errpr</em>()</td><td style="text-align:center">宏来构建cv :: Exception （从格式化的字符串）并抛出它</td></tr><tr><td style="text-align:center">cv::deallocate()</td><td style="text-align:center">取消分配c样式的对象数组</td></tr><tr><td style="text-align:center">cv::error()</td><td style="text-align:center">提示错误并引发异常</td></tr><tr><td style="text-align:center">cv::fastAtan2()</td><td style="text-align:center">计算向量的二维角度</td></tr><tr><td style="text-align:center">cv::fastFree()</td><td style="text-align:center">取消分配内存缓冲区</td></tr><tr><td style="text-align:center">cv::fastMalloc()</td><td style="text-align:center">分配对齐的内存缓冲区</td></tr><tr><td style="text-align:center">cvFloor()</td><td style="text-align:center">将浮点数向下取整</td></tr><tr><td style="text-align:center">cv::format()</td><td style="text-align:center">使用类似sprintf的格式，创建STL字符串</td></tr><tr><td style="text-align:center">cv::getCPUTickCount()</td><td style="text-align:center">从内部cpu计时器获得滴答计数</td></tr><tr><td style="text-align:center">cv::getNumThreads()</td><td style="text-align:center">计算OpenCV当前使用的线程</td></tr><tr><td style="text-align:center">cv::getOptimalDFTSize()</td><td style="text-align:center">为计划传递给cv::DFT()的数组计算最佳大小</td></tr><tr><td style="text-align:center">cv::getThreadNum()</td><td style="text-align:center">获取当前线程的索引</td></tr><tr><td style="text-align:center">cv::getTickCount()</td><td style="text-align:center">从系统获取滴答计数</td></tr><tr><td style="text-align:center">cv::getTickFrequency()</td><td style="text-align:center">每秒获取数字/刻度</td></tr><tr><td style="text-align:center">cvIsInf()</td><td style="text-align:center">检查浮点数x是否为无穷大</td></tr><tr><td style="text-align:center">cvIsNan()</td><td style="text-align:center">检查浮点数是否为“非数字“</td></tr><tr><td style="text-align:center">cvRound()</td><td style="text-align:center">将浮点数舍入到最近的整数</td></tr><tr><td style="text-align:center">cv::setNumThreads()</td><td style="text-align:center">设置OpenCV使用的线程数</td></tr><tr><td style="text-align:center">cv::setUseOptimized()</td><td style="text-align:center">启/禁用代码优化</td></tr><tr><td style="text-align:center">cv::useOptimized()</td><td style="text-align:center">指示代码优化启用的状态</td></tr></tbody></table><p>具有旧版界面的功能，为c定义的。</p><h3 id="4-模板结构"><a href="#4-模板结构" class="headerlink" title="4.模板结构"></a>4.模板结构</h3><h2 id="四、图像和大数组类型"><a href="#四、图像和大数组类型" class="headerlink" title="四、图像和大数组类型"></a>四、图像和大数组类型</h2><h3 id="1-动态和可变存储"><a href="#1-动态和可变存储" class="headerlink" title="1.动态和可变存储"></a>1.动态和可变存储</h3><ul><li><p><strong>cv::Mat类：N维密集数组</strong></p><p>cv::mat类可用于任何数目维度的阵列，数据储存在数组中，可以认为是一个n维“光栅扫描”的模拟。每个矩阵包含一个表示数组内容的flags元素、一个表示维度的dims元素、行列元素、一个表示位置的数据指针、以及一个引用计数器 .可把数组理解为.</p></li><li><p><strong>生成一个数组</strong></p><p>实例化一个cv::Mat类，并通过其成员函数create()来分配数据，其所需参数：行数、列数、类型、以及数组代表二维对象的配置。有效数组类型指定元素的基本类型和通道数量，所有这些类型都在库头文件中定义，其形式为:CV_{8U,16S,16U,32S,32F,64F}C{1,2,3}.如：CV_32FC3代表一个32位浮点三通道数组.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">cv</span>::Mat m;</span><br><span class="line"><span class="selector-tag">m</span><span class="selector-class">.create</span>(<span class="number">3</span>, <span class="number">10</span>, CV_32FC3);<span class="comment">// 为一个3行10列3通道的32位浮点数组分配数据</span></span><br><span class="line"><span class="selector-tag">m</span><span class="selector-class">.setTo</span>(<span class="attribute">cv</span>::Scalar(<span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f));<span class="comment">// 三通道值分别为1.0, 0.0, 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效上三行</span></span><br><span class="line"><span class="selector-tag">cv</span><span class="selector-pseudo">::Mat</span> <span class="selector-tag">m</span>( <span class="number">3</span>, <span class="number">10</span>, CV_32FC3, <span class="attribute">cv</span>::Scalar( <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f ) );</span><br></pre></td></tr></table></figure><ul><li><p>构造函数</p><p>|                             函数                             |                   功能                    |<br>| :———————————————————-: | :—————————————: |<br>|                          cv::Mat();                          |               默认构造函数                |<br>|            cv::Mat(int rows, int cols, int type);            |                 二维数组                  |<br>|   cv::Mat(int rows, int cols, int type, const Scalar&amp; s);    |            带初始值的二维数组             |<br>| cv::Mat(int rows, int cols, int type, void data, size_t step=AUTO_STEP); |    具有类型的二维数组，预先存在的数据     |<br>|               cv::Mat(cv::Size sz, int type);                |             二维数组，sz大小              |<br>|       cv::Mat(cv::Size sz, int type, const Scalar&amp; s);       |         带初始值的二维数组,sz大小         |<br>| cv::Mat(cv::Size sz, int type, void<em> data, size_t step=AUTO_STEP); | 具有类型的二维数组，预先存在的数据,sz大小 |<br>|       cv::Mat(int ndims, const int</em> sizes, int type);        |                 多维数组                  |<br>| cv::Mat(int ndims, const int<em> sizes, int type, const Scalar&amp; s); |                                           |<br>| cv::Mat(int ndims, const int</em> sizes, int type, const Scalar&amp; s, size_t step=AUTO_STEP); |                                           |</p></li></ul></li></ul><ul><li><p>复制构造函数</p><p>|                             函数                             |                       功能                        |<br>| :———————————————————-: | :———————————————–: |<br>|                   cv::Mat(const Mat&amp; mat);                   |                   复制构造函数                    |<br>| cv::Mat(const Mat&amp; mat, const cv::Range&amp; rows, const cv::Range&amp; cols); |           复制构造函数，仅能复制行和列            |<br>|        cv::Mat(const Mat&amp; mat, const cv::Rect&amp; roi);         |   复制构造函数，仅能复制感兴趣区域(roi)的行和列   |<br>|      cv::Mat(const Mat&amp; mat, const cv::Range* ranges);       |      通用区域复制构造函数，复制一块范维数组       |<br>|              cv::Mat(const cv::MatExpr&amp; expr);               | 复制用其他矩阵的代数表达式的结果初始化m的构造函数 |</p></li></ul><ul><li><p>模板构造函数</p><p>|                             函数                             |                          功能                           |<br>| :———————————————————-: | :—————————————————–: |<br>|   cv::Mat(const cv::vec<t, n="">&amp; vec, bool copyData = true);   | 从同一类型的cv::Vec中构造一个类型为T、大小为n的一维数组 |<br>| cv::Mat(const cv::Matx<t, m,="" n="">&amp; vec, bool copyData = true); |  从同一类型的cv::Matx中构造一个尺寸为m×n的T型二维数组   |<br>|  cv::Mat(const std::vector<t>&amp; vec, bool copyData = true);   |     从包含相同类型元素的STL向量构造T类型的一维数组      |</t></t,></t,></p></li><li><p>静态函数</p><p>|                函数                |                           功能                           |<br>| :——————————–: | :——————————————————: |<br>| scv::Mat::zeros(rows, cols, type); |     创建rows行cols列的cv::Mat,初始全为0，类型为type      |<br>| scv::Mat::ones(rows, cols, type);  |     创建rows行cols列的cv::Mat,初始全为1，类型为type      |<br>|  scv::Mat::eye(rows, cols, type);  | 创建rows行cols列的cv::Mat,初始为identity矩阵，类型为type |</p></li></ul><ul><li><p><strong>分别访问数组元素</strong></p><ul><li><p>几种访问函数</p><p>|         函数          |                功能                |<br>| :——————-: | :——————————–: |<br>|     M.at<int>(i);     |        整数数组M中第i个元素        |<br>|  M.at<float>(i, j);   |      浮点数组M中(i,j)位置元素      |<br>|    M.at<int>(pt);     | 整数矩阵M中(pt.x, pt.y)位置的元素  |<br>| M.at<float>(i, j, k); | 三维浮点数组M中(i, j, k)位置的元素 |<br>|   M.at<uchar>(idx);   |    uchar数组M中idx[]位置的元素     |</uchar></float></int></float></int></p><p>还可通过怕c样式的指针访问二维数组</p><p>对于矩阵，有两种方法获取其数据指针：</p><ul><li>成员函数ptr&lt;&gt;()</li><li>M.at&lt;&gt;()</li></ul></li></ul></li><li><p><strong>N元数组迭代器:NAryMatlterator</strong></p><p>一次遍历多个数组，返回数组块，称为planes，常用于多数组计算(多点代表面)</p></li><li><p><strong>按快访问数组元素</strong></p></li></ul><p>未完待续！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Learning-OpenCV3&quot;&gt;&lt;a href=&quot;#Learning-OpenCV3&quot; class=&quot;headerlink&quot; title=&quot;Learning OpenCV3&quot;&gt;&lt;/a&gt;Learning OpenCV3&lt;/h1&gt;&lt;h2 id=&quot;一、Overvie
      
    
    </summary>
    
      <category term="图像处理" scheme="https://zaizizaizai.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="opencv" scheme="https://zaizizaizai.github.io/tags/opencv/"/>
    
      <category term="图像处理，人工智障" scheme="https://zaizizaizai.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%8C%E4%BA%BA%E5%B7%A5%E6%99%BA%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>c知识点</title>
    <link href="https://zaizizaizai.github.io/2019/08/24/c-plus/"/>
    <id>https://zaizizaizai.github.io/2019/08/24/c-plus/</id>
    <published>2019-08-24T09:03:04.000Z</published>
    <updated>2019-08-24T11:35:40.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><!-- TOC --><ul><li><a href="#%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93">知识点总结</a><ul><li><a href="#%e6%95%b0%e6%8d%ae%e5%ad%98%e6%94%be%e4%bd%8d%e7%bd%ae">数据存放位置</a></li><li><a href="#c%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b">c++内存模型</a></li><li><a href="#class">class</a></li><li><a href="#const">const</a></li><li><a href="#static">static</a></li><li><a href="#">&amp;</a></li><li><a href="#%e5%88%9d%e5%a7%8b%e5%8c%96">初始化</a></li><li><a href="#volatile">volatile</a></li><li><a href="#templatetypename-t">template<typename t=""></typename></a></li><li><a href="#virtual">virtual</a></li><li><a href="#%e6%9e%84%e9%80%a0%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0">构造/析构函数</a></li><li><a href="#operator">operator</a></li><li><a href="#%e6%8c%87%e9%92%88%e5%bc%95%e7%94%a8">指针、引用</a></li><li><a href="#%e5%8f%8c%e6%8c%87%e9%92%88%e6%8c%87%e9%92%88%e5%bc%95%e7%94%a8">双指针、指针引用</a></li><li><a href="#%e6%9d%a1%e4%bb%b6%e7%bc%96%e8%af%91">条件编译</a></li><li><a href="#%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86">资源管理</a><ul><li><a href="#%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae">提供对原始资源的访问</a></li></ul></li></ul></li></ul><h2 id="数据存放位置"><a href="#数据存放位置" class="headerlink" title="数据存放位置"></a>数据存放位置</h2><ol><li>本地变量：栈</li><li>new出的对象：堆</li><li>static/全局变量：全局数据区</li></ol><h2 id="c-内存模型"><a href="#c-内存模型" class="headerlink" title="c++内存模型"></a>c++内存模型</h2><ul><li>存放对象的地方<ol><li>栈</li><li>堆</li><li>全局数据区</li></ol></li><li>访问对象的方式<ol><li>变量访问对象</li><li>指针访问对象</li><li>引用访问对象</li></ol></li></ul><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><ul><li>struct默认public</li><li>class默认private</li><li>其他用法完全一样，都包含成员函数、继承、多态</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>只需看其右侧最近的类型<ul><li>*前后<ul><li>前：指针指向变量</li><li>后：指针本身是变量</li></ul></li><li>函数前后<ul><li>前：函数返回值为const</li><li>后：函数成员为const</li><li>最后：此成员函数不改变类中的成员变量(mutable可变的)</li></ul></li></ul></li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>静态局部变量：<ul><li>全局数据区分配内存</li><li>随函数第一次调用时初始化，程序结束时销毁</li><li>声明处初始化，若无显式初始化，会自动初始化为0</li><li>作用域为局部作用域</li></ul></li><li>静态全局变量：</li><li>静态函数：<ul><li>本文件可见(文件隔离)</li></ul></li><li>静态数据成员：<ul><li>只有class有一份，而普通数据成员是每一个实例有一份</li></ul></li><li>静态成员函数：<ul><li>静态成员函数不能访问非静态(成员函数、数据成员)</li><li>非静态成员函数可以访问静态(成员函数、数据成员)</li><li>解释：静态是属于类的，它不知道创建了多少对象；而对象中的数据对类中数据一清二楚</li></ul></li></ul><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><ul><li>引用<ul><li>在赋值＝右侧</li><li>和变量在一起</li></ul></li><li>取地址<ul><li>在赋值＝左侧</li><li>和类型在一起</li></ul></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li>A::A(int m, int n) : x(m), y(n) {}    //初始化</li><li>A::A(int m, int n){x = m; y = n;}    //赋值</li><li>singleton模式：local static对象替换non-local static对象<ul><li>基础在于：c++保证，函数内的local static对象会在”该函数被调用期间“”首次遇上该对象之定义式“时被初始化。</li></ul></li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><ul><li>声明的变量可能随时变化，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</li><li>从所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li><li>应用在共享变量</li></ul><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template<typename t=""></typename></h2><p>  // TODO:</p><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><ul><li>virtual析构函数用于多态基类的声明</li><li>被用作base class的类声明为virtual析构函数，其他类不要声明virtual析构函数(对象体积增大，不能将其传给其他语言写的函数－无移植性)</li><li>类的设计目的如果不是base class或具有多态性，就不该声明virtual析构函数</li><li>别让异常逃出析构函数<ul><li>结束程序　try{…}catch{…;std::abort;}</li><li>吞掉异常  　try{…}catch{…;}</li><li>前两者的优化：　</li></ul></li></ul><h2 id="构造-析构函数"><a href="#构造-析构函数" class="headerlink" title="构造/析构函数"></a>构造/析构函数</h2><ul><li>构造函数调用顺序：base -&gt; derived</li><li>析构函数调用顺序：derived -&gt; base</li><li>在构造/析构函数中不要调用虚函数，因为这类的调用不会下降至derived class(相对的)</li></ul><h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><ul><li>令重载操作符返回一个reference to *this</li><li>处理自我赋值(赋值时两个为同一个对象，删除一个就都删除了)<ul><li>证同测试，并跳过处理流程</li><li>用副本去操作</li><li>copy and swap</li></ul></li><li>copy函数<ul><li>确保复制”对象内的所有成员变量” 和 “所有base class成分”</li><li>不要用一个copy函数实现另一个copy函数，应该将共同机能放入第三函数，并由两个函数共同调用</li></ul></li></ul><h2 id="指针、引用"><a href="#指针、引用" class="headerlink" title="指针、引用"></a>指针、引用</h2><ul><li>指针<ul><li>概述：指针传递参数本质上是值传递的方式，其传递一个<strong>地址值</strong></li><li>流程：值传递的过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为实参的一个副本</li><li>特点：被调函数对形参的任何操作都是作为局部参数进行，不影响主调函数是参变量的值</li><li>应用：<ul><li>不改变指针指向，形参指向实参，可操作实参</li><li>改变指针指向，则形参作为副本，与实参无关，不可操作实参</li></ul></li></ul></li><li>引用<ul><li>概述：引用传递本质是地址传递，传递的是<strong>实参变量的地址</strong></li><li>流程：被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</li></ul></li><li><strong>区别</strong><ul><li>指针传递参数时，指针中存放的也是实参的地址，但是在被调函数内部指针存放的内容可以被改变，即可能改变指向的实参，所以并不安全</li><li>而引用则不同，它引用的对象的地址一旦赋予，则不能改变</li></ul></li></ul><h2 id="双指针、指针引用"><a href="#双指针、指针引用" class="headerlink" title="双指针、指针引用"></a>双指针、指针引用</h2><p>// TODO:</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><ul><li>当标识符定义过了,编译程序段1,否则编译程序段2<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">程序段<span class="number">1</span></span><br><span class="line"><span class="built_in">else</span></span><br><span class="line">程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><ul><li>以对象管理资源<ul><li>为防止资源泄露，请使用RAII对象(tr1::shared_ptr、auto_ptr)，它们在构造函数中获得资源并在析构函数中释放资源</li></ul></li></ul><h3 id="提供对原始资源的访问"><a href="#提供对原始资源的访问" class="headerlink" title="提供对原始资源的访问"></a>提供对原始资源的访问</h3><ul><li><p>问题:如何调用一个对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt;pInv(createInvestment());</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;   <span class="comment">// 返回投资天数</span></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pInv);   <span class="comment">// 调用出错</span></span><br></pre></td></tr></table></figure><p>编译不通过,daysHeld需要Investment*指针,传入的却是类型为tr1::shared_ptr<investment>的对象</investment></p></li><li><p>解决办法:</p><ul><li>智能指针<ul><li>显示转换:　trl::shared_ptr和auto_ptr都提供了一个get成员函数，它会返回只能指针内部原始资源指针（的复件）</li><li>隐式转换：　利用重载了的取值操作符（operator-&gt;和operator*)，其允许隐式转换至内部原始指针</li></ul></li><li><p>类</p><ul><li><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span>(<span class="params"></span>)</span>;   <span class="comment">//API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span>(<span class="params">FontHandle fh</span>)</span>;   <span class="comment">// API</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span>(<span class="params">FontHandle fh</span>) : <span class="title">f</span>(<span class="params">fh</span>)</span>&#123;&#125;   <span class="comment">// 获取资源,pass-by-value</span></span><br><span class="line">  ~Font() &#123;releaseFont(f);&#125;   <span class="comment">// 释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  FontHande f;  <span class="comment">// 原始字体资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>font类中添加两种解决办法</p></li><li><p>显式转换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">FontHandle <span class="title">get</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123;retun f;&#125;   <span class="comment">//显示转换</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeFontSize</span>(<span class="params">FontHandle f, <span class="keyword">int</span> newSize</span>)</span>;    <span class="comment">// API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span>(<span class="params">getFont(</span>))</span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">cangeFontSize(f.<span class="keyword">get</span>(), newFontSize);    <span class="comment">//显示将Font转换为FontHandle</span></span><br></pre></td></tr></table></figure><p>问题: 增加泄漏字体的可能性,而Font类的主要设计目的是为了防止资源(字体)泄露</p></li><li><p>隐式转换</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Font &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> f;&#125;   <span class="comment">// 隐式转换</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">Font <span class="title">f</span>(<span class="params">getFont(</span>))</span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">changeFontSize(f, newFontSize);   <span class="comment">// 将Font隐式转换为FontHandle</span></span><br></pre></td></tr></table></figure><p>问题: </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Font</span> <span class="built_in">f1</span>(getFont())<span class="comment">;</span></span><br><span class="line"><span class="symbol">FontHandle</span> <span class="built_in">f2</span> = <span class="built_in">f1</span><span class="comment">;   // 原意是要拷贝一个Font对象</span></span><br><span class="line">                      //却反将<span class="built_in">f1</span>隐式转换为FontHandle对象,然后才复制它</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识点总结&quot;&gt;&lt;a href=&quot;#知识点总结&quot; class=&quot;headerlink&quot; title=&quot;知识点总结&quot;&gt;&lt;/a&gt;知识点总结&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%9f%a5%e8%af%86%e7%82%b9%e
      
    
    </summary>
    
      <category term="c++" scheme="https://zaizizaizai.github.io/categories/c/"/>
    
    
      <category term="笔记" scheme="https://zaizizaizai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="https://zaizizaizai.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="c++" scheme="https://zaizizaizai.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>所为所得</title>
    <link href="https://zaizizaizai.github.io/2019/08/13/%E6%89%80%E4%B8%BA%E6%89%80%E5%BE%97/"/>
    <id>https://zaizizaizai.github.io/2019/08/13/所为所得/</id>
    <published>2019-08-12T16:06:30.000Z</published>
    <updated>2019-08-12T16:10:15.435Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>clox编译器</title>
    <link href="https://zaizizaizai.github.io/2019/07/19/clox-compiler/"/>
    <id>https://zaizizaizai.github.io/2019/07/19/clox-compiler/</id>
    <published>2019-07-19T11:20:16.000Z</published>
    <updated>2019-07-19T11:55:17.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clox"><a href="#clox" class="headerlink" title="clox"></a><strong>clox</strong></h1><h3 id="持续更新中，目前到scanner"><a href="#持续更新中，目前到scanner" class="headerlink" title="(持续更新中，目前到scanner)"></a>(持续更新中，目前到scanner)</h3><p>clox是由Bob Nystrom基于ｃ编写的编译器，最终解释结果编译成字节码，通过编写学习，可以了解编译器的基本原理<br>主流程主要分为三步：</p><ol><li>扫描</li><li>编译</li><li>执行(虚拟机)</li></ol><p><a href="https://github.com/zaizizaizai/work/tree/master/c/clox" target="_blank" rel="noopener">github代码库:zaizizaizai</a></p><p><a href="http://www.craftinginterpreters.com/chunks-of-bytecode.html#chunks-of-instructions" target="_blank" rel="noopener">推荐：原文教程请戳这里</a></p><p><a href="https://github.com/tuvtran/project-based-learning" target="_blank" rel="noopener">极度推荐项目库：project-based-learning</a></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li><a href="#文件说明">文件说明</a></li><li><a href="#流程">流程</a><ul><li><a href="#clox编译器整个代码逻辑流程">clox编译器整个代码逻辑流程</a></li><li><a href="#执行减法的流程">执行减法(3-1)的流程</a></li></ul></li><li><a href="#结构">结构</a><ul><li><a href="#chunk结构">chunk结构</a></li><li><a href="#ValueArray结构">ValueArray结构</a></li><li><a href="#VM结构">VM结构</a></li></ul></li><li><a href="#函数以及参数说明">函数以及参数说明</a><ul><li><a href="#reallocate函数">reallocate()</a></li><li><a href="#OP_CONSTANT">OP_CONSTANT</a></li></ul></li></ul><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a><strong>文件说明</strong></h2><table><thead><tr><th>文件名</th><th>功能</th></tr></thead><tbody><tr><td>common</td><td>通用引用库文件</td></tr><tr><td>memory</td><td>数组增删的逻辑，基础的内存管理</td></tr><tr><td>chunk</td><td>chunk节点：结构定义,属性的更改;储存源代码</td></tr><tr><td>value</td><td>常量池，常量类型结构的定义及实现</td></tr><tr><td>debug</td><td>反汇编提示信息</td></tr><tr><td>main</td><td>主函数</td></tr><tr><td>vm</td><td>虚拟机－指令执行器;解释执行源代码</td></tr><tr><td>compiler</td><td>编译</td></tr><tr><td>scanner</td><td>扫描代码段</td></tr></tbody></table><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h2><h3 id="clox编译器整个代码逻辑流程"><a href="#clox编译器整个代码逻辑流程" class="headerlink" title="clox编译器整个代码逻辑流程"></a>clox编译器整个代码逻辑流程</h3><p><img src="/images/clox/pipeline.png" alt="clox整个流程"></p><h3 id="执行减法的流程"><a href="#执行减法的流程" class="headerlink" title="执行减法的流程"></a>执行减法的流程</h3><p><img src="/images/clox/reverse.png" alt="计算器(执行操作码)"></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><h3 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a><strong>chunk结构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">//实际使用大小</span></span><br><span class="line">    <span class="keyword">int</span> capacity;   <span class="comment">//分配数组的容量</span></span><br><span class="line">    <span class="keyword">uint8_t</span>* code;  <span class="comment">//指令</span></span><br><span class="line">    <span class="keyword">int</span>* lines;     <span class="comment">//线信息</span></span><br><span class="line">    ValueArray constants;   <span class="comment">//常量列表</span></span><br><span class="line">&#125; Chunk;</span><br></pre></td></tr></table></figure><p><img src="/images/clox/insert.png" alt="chunk"><br><img src="/images/clox/grow.png" alt="chunk扩展容量过程"></p><ol><li>分配具有更多容量的新数组</li><li>将现有元素从旧数组复制到新数组</li><li>更新capacity</li><li>删除旧数组</li><li>更新code指向新数组</li><li>既有空间，也可将元素储存在新数组中</li><li>更新cout</li></ol><h3 id="ValueArray结构"><a href="#ValueArray结构" class="headerlink" title="ValueArray结构"></a>ValueArray结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;   <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">int</span> count;      <span class="comment">//实际使用大小</span></span><br><span class="line">    Value* values;   <span class="comment">//数值</span></span><br><span class="line">&#125; ValueArray;</span><br></pre></td></tr></table></figure><h3 id="VM结构"><a href="#VM结构" class="headerlink" title="VM结构"></a>VM结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Chunk* chunk;</span><br><span class="line">    <span class="keyword">uint8_t</span>* ip;    <span class="comment">//指令指针(PC机中的程序计数器)</span></span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><h2 id="函数以及参数说明"><a href="#函数以及参数说明" class="headerlink" title="函数以及参数说明"></a><strong>函数以及参数说明</strong></h2><h3 id="reallocate函数"><a href="#reallocate函数" class="headerlink" title="reallocate函数"></a>reallocate函数</h3><p>传递两个参数给reallocate()控制要实现的操作</p><table><thead><tr><th>oldsize</th><th>newSize</th><th>操作</th></tr></thead><tbody><tr><td>0</td><td>非0</td><td>　分配新块</td></tr><tr><td>非0</td><td>0</td><td>重置为空</td></tr><tr><td>非0</td><td>&lt; oldSize</td><td>缩小现有分配</td></tr><tr><td>非0</td><td>&gt; oldSize</td><td>增加现有分配</td></tr></tbody></table><h3 id="OP-CONSTANT"><a href="#OP-CONSTANT" class="headerlink" title="OP_CONSTANT"></a>OP_CONSTANT</h3><p>OP_CONSTANT采用单字节操作数制定从块的常量数组加载哪个常量<br><img src="./pic/format.png" alt="format"></p><ul><li><a href="#clox">文章顶部</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;clox&quot;&gt;&lt;a href=&quot;#clox&quot; class=&quot;headerlink&quot; title=&quot;clox&quot;&gt;&lt;/a&gt;&lt;strong&gt;clox&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;持续更新中，目前到scanner&quot;&gt;&lt;a href=&quot;#持续更新中，目前到sca
      
    
    </summary>
    
      <category term="c" scheme="https://zaizizaizai.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://zaizizaizai.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>python核心(一)</title>
    <link href="https://zaizizaizai.github.io/2019/01/19/python%E6%A0%B8%E5%BF%83-%E4%B8%80/"/>
    <id>https://zaizizaizai.github.io/2019/01/19/python核心-一/</id>
    <published>2019-01-19T05:54:01.000Z</published>
    <updated>2019-01-19T05:54:01.377Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大海与生活</title>
    <link href="https://zaizizaizai.github.io/2018/09/22/%E5%A4%A7%E6%B5%B7%E4%B8%8E%E7%94%9F%E6%B4%BB/"/>
    <id>https://zaizizaizai.github.io/2018/09/22/大海与生活/</id>
    <published>2018-09-22T06:24:55.000Z</published>
    <updated>2018-09-22T06:49:47.998Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19ususyN/YPm1Ysu29v/GO8s6Ny/tvBJJDNB7YxL88MnVYVoQcERisWP3EGE8cv0JC90onmrAoszjSNzfgcpOrvoZ8SI9Cwm74gqfn6DkVqCKu/YS7GHC+x7sXpcv6KHHN+UkajyN+naPGdTRCzS4JZLo8gT1Z2y2ULHZwq96yTG/ahD+/vmgfIcrO10sPVdurZESFMCHXhbogli3hI1yqi2AkvDtmjLt/i9+M5Y5+7MOY0xh5BmbCHJVYZyqRg1Kxnm/d+L9cUgAo0HQhFbiDIdgt5cDR6bAkzgkip5JZGQIFNtZhCHL5xFml97xBfc/SW5sl4pRxFRC5GzbEaHdKyRjLMNXmIqutCpPbtL57iKFnX9wZFnxat3AGQAjJwcS2cv7H6QFAB9c4QlCl6pTHdG6KX8xOT6r4=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>电影</title>
    <link href="https://zaizizaizai.github.io/2018/09/22/%E7%94%B5%E5%BD%B1/"/>
    <id>https://zaizizaizai.github.io/2018/09/22/电影/</id>
    <published>2018-09-22T05:33:36.000Z</published>
    <updated>2018-09-22T06:55:36.034Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+pdtr3a4tVWUkkUTqU/DB01WtU2u61OoflsvS3YDvMOka+468qUI+zFB+QGs/dbvDIzT1GFdksJhh+GjL7tal3EQ8rBFmwuFXeVz/u3LNS+FU0b1C/4Hg/vdNS7aGly9QLzSVd5eKFD2iUcp1sE25e5BbZI/YPl7Hji9NiSKjNGmp2LbnaXPCxLrwbxkAKQ/hhq1uOZ3nOY2PWV7AFk3P4gDT0aGsOff//K0uAOtKYEkL8zSDOKWKg90UjsRnobRkl9Vhj4KJbfv17zYHH/at7VLUtAoCFlkzazQnKq0D5VtvFz92aEjNafzlxxTaSWeYibvtFTmo0RA9ml6TO3eUoUfqG3EEtlZG2UrHlUfarhJV9JPafSvX8sSTZCTbGfbzE0eGZZvrpO8PWcFbfMpsQFz49HVOMPHw+bEyifiKbct2cq9SDmJ/w4WDmcFOO/jqDJhBK2OZDZ/tmhOh0BwgZiZ+ArSmItVbILbUu1ptfNGb8WpVZgKLU2uyQs19U4fBevYoRnBGUrA==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「喜欢的电影，人物」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于自信</title>
    <link href="https://zaizizaizai.github.io/2018/08/04/%E5%85%B3%E4%BA%8E%E8%87%AA%E4%BF%A1/"/>
    <id>https://zaizizaizai.github.io/2018/08/04/关于自信/</id>
    <published>2018-08-04T06:21:05.000Z</published>
    <updated>2018-09-22T06:56:25.012Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「胡说八道一通」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>致未来的你</title>
    <link href="https://zaizizaizai.github.io/2018/07/07/%E8%87%B4%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0/"/>
    <id>https://zaizizaizai.github.io/2018/07/07/致未来的你/</id>
    <published>2018-07-07T06:12:27.000Z</published>
    <updated>2018-09-22T06:57:55.918Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+tbD+Uu8OUu9LEMwL+wKkQ0aN9hw7+NofyCCPdh72adOO7zE4bpEHvR1Ismxepa2DTHOpFgMieRKiB2RDu1t9pTGAecVBRqGl0ztPgNxEs++6u+JMmReQldz1NTmxq2lm47aQvAbi1k/5aDfPC6C6z3opTKKbOFvfM8BWaFNX44eqkpb2dUmtNKsR3pHfhps7iV/rEH+v+eho3LOiziFYp3nYJCH5enQ7hv19EYlan9EvVpxC/3ZqswEGngPKgui1yoxIpfWngMB0YqKcv0wUAGsMyNXkAIfpcGa6gj5ruQApSl3G/GK3eOwHsekhG8wrh2ZUXBfNjQaIzY4qIrBOiqQ/4x/8NX2SGtJ56J1eaXiQeoSsHOCxVkMiEm9UUPO2y8Ux5kamEAfXU3SMdGSyjuK+ietW5KqcKBKh1rAC7s5n7tv8LAhDkT3qC1D2maPz2t2WDaJ27Ev6VDah+8U4i/zVOC3oK/V8l2sy9AXRC27BTR41gsL9SSKd+HjpkO8E915tKZJ2PpR8VgSeKZE6abiT95G/MHHF7tjXVHGbn5Hp2mzNbvJGglLDlsn4Qwa0cj7fOBCWoQkz/6IauehMqa74FP+J5VuXQGiipz7tNebrUBOTPKiDVPnoy79Wg5visk2xxb0vJnyOjD5yOZrAxqF66qVJZVa2M51a3pAw3+49999RX5dGFY/lQQQuEaWcp71/G9lZJV/kfOK5nmQdnmwlDB1A0+pwisfujcoufjgsXBCl1W/wiLeHVGTJsF5qoxtq/KE9nfZdCL+Sa+C+My7A88wzi+QHV3hbSRwuLxqZoGYY6bPCKaad35Fe6cUTaELuODQL7S5ezVU5Laau9dE9RCKNgyyXQ/fJf0/sNDN/rSelTtDzXHLLGkxUnkXU4InlFBQZt1naZuqvAG3SOMY0+n0mmCpLHRDqKIyr24dH0Q86z6kzmqbuqxQUp49fIi3TMqk8RzySUQoqVpJwdsfPTrPV5WlUxCpmSwYIZtVbIZzj1mv+COvWBNhMl96tydVEqVdzJnnT80VCFJIr7FUPhYmpOqnjF7iMQoVoUGEZD4U0E1zTWTSDiNiMFWbJ4TYzztAsx3biABsPUJM5aHXITlA1Rb1Rm+5QyRCBcJQYqraID8UoDsxlCpmAiOVDDRlp6uWne3FjESL2vEY422iQI/JZTzEYmDH7RzopdGx7s7xH2zJ5LeEpxVY3MXODMxDkYaln1fRfCVm11BR8QY8pBcRSbJkJGxbRpD1/aDcN5sca00MHThgl1tgv5SdqeqsoGHm1FoKND0l4MVcOriqalOP02W8fH8aj6cEMq2rwkt1pgYeGTtvAiqQipZa5sZA8waAzmYNBaED04oHkxv9AgNAnkT31Y97D52oOUvQ4h4QVIz88SrkhhmUs59LooazNa72/4jAK+9BuC3mStKpjYDBfc7vGvgz+TyLpFpm3DNCQnCuCGX7kxVsYKPM2LmA616yMPEKGH4ulsRpuQ7ejYuWE/aWzEgNaPvEjwbpjCPyJcf091Oem9OJl9E8PNHOPh/5ZGpU0bC1RM6rA26wXT1v2J59KyckW5qGkmwWNLkk+cca1MXkAbfAn7Uh6GrR09h8a/m9OImvgUutnWy1I4jP/rqjieiRItIy1tqbO+qvDvn3IjKvq2BW7MjdF0ezzS560kdo8toSKGVWFNpOOa1ZfmdH3W7OjAsjUauKXAYi+J1xeG9K+ib1WTC7r1QwlsKZEHf38SfUnOcewFu6+6annZOnf/RiXGL19C0093YxSXkfY7SIV3eF8cT8llUaWAQoik/uR5XzcHEM+cVuiXyP0aCGnkHzEtaf5qL9VJIZI1sZp0JHSOuNu2q8Iu9MYnAOxXpeIZTziwK4ywzvHqRxczTf7aojMHU+JyA0O1WqaNCqvE0XgLUq1MrKKlw8spBV5Ptxm2ksVod2oGcNb7vZPC9VI=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「期待」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>做饭</title>
    <link href="https://zaizizaizai.github.io/2018/07/04/%E5%81%9A%E9%A5%AD/"/>
    <id>https://zaizizaizai.github.io/2018/07/04/做饭/</id>
    <published>2018-07-04T06:04:32.000Z</published>
    <updated>2018-09-22T06:58:04.406Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19wHMU8VnciaDwQNl1+KJAKHk/mReUsLjRblIHB/+zzVDF9221A0z+rK+CDMtPvh0sUx7f/viLe1D8ag+yYG7yV6iLjDxxLFYX854LezYaqEnrGWt/oWfPirnMHZVQYulRBe6L3R9+XJHbkKjBOBFh387tn2IlQgv2Jm5Bm5V3Th/Nhu1WoH64tHFh5QH63qxgyUcnEHcr83xyvX8Wcacww+F4RwGfv3nWbvLQIccY+Qo9DV+ZY8U1ERMX4VtvT8xj5HlgfJVkfrEGMc7ZMBNSH7JtaXa5Ro9+yh+7g2Cp7GkZv6oX3JWrekb52pIhzJ7bvibOC++evCSoc5Tdhm5PPVwQxGyf9FaLhyAV+DyrHlk1KI4mIXDlkfoi6U3smjAPTriwF1C8winDOoZbEW0YrIaxWP+f3DVO8Y6hdED3ieuxf99ASc9kIkp9Ibii5hFSaM8pyEMA3BU6gFjqrAe2o236joD9RLRUwR19Zixi3fmB+cYwZR575uHQDS+sl9/dqBOC2su/oKf8n7GHRFvh0fu1Qx+ULyJP76cvj87XdCzVeZjPNcfKIWC5WS1UFVx8kt8ml1v3d3aS/vT/5u30uU52//qwpffzHzkKfeA78LMZUr8jcV92IOG79w4XHPhp+HQYdK2fYpvlhzwcYQ2kybA2ClMDL1q9lHvrsX/n9F6LMg5Hrkereusi6nawi8LOnTSeue59fd+4zoPE1cn42vI90EDrJyxIufzvowOP8Rpng7y+D/eKyw/Zn/BOTptNMPLlfCQtBOfwVzFAfZh8+zKx9YZWhgtI+k5txIa8KnCanwU/JF1cT</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>未来的自己</title>
    <link href="https://zaizizaizai.github.io/2018/06/24/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <id>https://zaizizaizai.github.io/2018/06/24/未来的自己/</id>
    <published>2018-06-24T05:54:58.000Z</published>
    <updated>2019-03-07T07:35:26.707Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>姨爹</title>
    <link href="https://zaizizaizai.github.io/2018/06/17/%E5%A7%A8%E7%88%B9/"/>
    <id>https://zaizizaizai.github.io/2018/06/17/姨爹/</id>
    <published>2018-06-17T05:53:48.000Z</published>
    <updated>2018-09-22T06:57:33.346Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19fs4J0pCi6JknD7UlPpEg+e23Da96PhIkmMAaxXgyM5pMhyQT+0kVYVm/sfj/no+aHXiF088W4Q4ceVZp2OiQq3uNmIldt91DSP8S80mcLQcq8oyh+S8bf17Vw+yrIpuMmegXoaW/9ZY/eJlifQu5+x/HqCqkSBpQTUAUhr9JeR5qSVKlKH1LsS432zegRx7PQjJiGHj6rY2PX8rToWMc3bRSV5+ZuiBkQlbqUnv/GBbYf57tgbOjH6SxUxiEcXRLYL4OIy/TzotncSIPkFJGQwBj/mEoCSa80PI0qzAWSzI4ZqI1LHm5vnocpHhXRcfH+MjuRqgwAjg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>office online</title>
    <link href="https://zaizizaizai.github.io/2018/06/10/office-online/"/>
    <id>https://zaizizaizai.github.io/2018/06/10/office-online/</id>
    <published>2018-06-10T05:38:04.000Z</published>
    <updated>2018-06-10T05:40:20.919Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="软件分享" scheme="https://zaizizaizai.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="软件分享" scheme="https://zaizizaizai.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018.06.04</title>
    <link href="https://zaizizaizai.github.io/2018/06/06/2018-06-04/"/>
    <id>https://zaizizaizai.github.io/2018/06/06/2018-06-04/</id>
    <published>2018-06-06T01:41:05.000Z</published>
    <updated>2018-06-06T01:43:47.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="看山是山，看山不是山，看山还是山，为什么越看越伤心呢？"><a href="#看山是山，看山不是山，看山还是山，为什么越看越伤心呢？" class="headerlink" title="看山是山，看山不是山，看山还是山，为什么越看越伤心呢？"></a>看山是山，看山不是山，看山还是山，为什么越看越伤心呢？</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot;&gt;&lt;a href=&quot;#看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot; class=&quot;headerlink&quot; title=&quot;看山是山，看山不是山，看山还是山，为什么越看越伤心呢？&quot;&gt;&lt;/a&gt;看山是山，
      
    
    </summary>
    
      <category term="人言" scheme="https://zaizizaizai.github.io/categories/%E4%BA%BA%E8%A8%80/"/>
    
    
      <category term="人言" scheme="https://zaizizaizai.github.io/tags/%E4%BA%BA%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>天堂电影院</title>
    <link href="https://zaizizaizai.github.io/2018/05/31/%E5%A4%A9%E5%A0%82%E7%94%B5%E5%BD%B1%E9%99%A2/"/>
    <id>https://zaizizaizai.github.io/2018/05/31/天堂电影院/</id>
    <published>2018-05-31T05:51:16.000Z</published>
    <updated>2018-09-22T06:57:07.909Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19jaGBlT8sjnSOxClxmmh027Pj3ikhtyWRbb+N8Z5BczlYjZSCU5BIAgWvKaX12eetBjnBtDMXoGpU8VLotPy4fGufTRQNNxv3605PeAyePXTRh6gvMMGkjILb9+TOw6Uxna4HA2sCeUzPNxMQNSZ/js8PV++HMaIrxNw+Xw373R4TSuLilALVhg1ZyejpAX5WaS1gcJOZ4xKCB4zrSwlm+owFehrAn6cb7UC6IyfCkKDRybJofm2VZk7oxZDMknVaWnlyMArtvar67cw9fx14vgRyIdwuliMBlN7ZcK+HwPBz29/ZyFuvJZ+6IIzdJnC8AhrS1J19ybj87OPeSWgLmRD64djq+LpV5tzGSeMIBTxIH/IeGZZ1g6Y2FKSo4P/FZUNim1kZBj+P0I+peB6YMjKBvRWloYO0=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「梦想的事」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>与姐姐</title>
    <link href="https://zaizizaizai.github.io/2018/05/21/%E4%B8%8E%E5%A7%90%E5%A7%90/"/>
    <id>https://zaizizaizai.github.io/2018/05/21/与姐姐/</id>
    <published>2018-05-21T05:47:37.000Z</published>
    <updated>2018-09-22T06:57:39.574Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「密码不能告诉你」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>交流</title>
    <link href="https://zaizizaizai.github.io/2018/05/04/%E4%BA%A4%E6%B5%81/"/>
    <id>https://zaizizaizai.github.io/2018/05/04/交流/</id>
    <published>2018-05-04T05:42:17.000Z</published>
    <updated>2018-09-22T06:56:50.380Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="security">  <div class="input-container">  <input type="password" class="form-control" id="pass" placeholder="请输入密码" />    <label for="pass">请输入密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+e4HdaK4zDbPi5zCdvnteicihduD8Dj9+/yquCK7J7xVoPOoNzkuXwtTeF4rRyiZ1nRxhgpIfY7yE+iEamnFom80FrYrj0lb5JiMEVHzTUH4+zupwl5QCm3DVyXqmYOkBBHBKJU7b3UQl/f3uKDsxEqJxFGNpJMKhPSEtPQfc26HLeV714MTDe+QtafdGxCopem0kiBhDwBlqKcSFQcKYYJfMBJDz6c1oiH2ZohY9DZBEJjSauZqcRoFmQvWgTp2OBb/qowDTdA7gYUpwZx4jwOYdX21pQxvedw9BstOAV3kvZ/ykseiNSnxlFeKs+Z4eRR2l7xwSeTefBXFLG/M9204ZB9o1424aujQODkIswh5a1k1ylg/O/0O8byRvAnUQpLfuHhtS+INEk4NDWLJ443GX352RS3byFeWsEel/Y14UnpFHbH9NHDeWOKUio1z4K4qrjvGwnEg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      「大致如此」
    
    </summary>
    
      <category term="随想" scheme="https://zaizizaizai.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="https://zaizizaizai.github.io/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
