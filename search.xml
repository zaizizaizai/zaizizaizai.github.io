<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[binder监测连接状态]]></title>
    <url>%2F2020%2F05%2F06%2Fbinder%E7%9B%91%E6%B5%8B%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[Binder监测连接状态，以及断开后的重连一、监测连接状态1. binder对象死亡通知机制1.1. 注册死亡通知client和server通过binder通信，且binder提供一个方法，即传入死亡代理binder.linkToDeath(IBinder.DeathRecipient) ，当client于server断开的时候，client收到DeathRecipient的binderDied()方法回调 ，从而知道连接断开，以下为binder源码： BBinder::linkToDeath () 123456status_t BBinder::linkToDeath( const sp&lt;DeathRecipient&gt;&amp; /*recipient*/, void* /*cookie*/, uint32_t /*flags*/)&#123; return INVALID_OPERATION; // 返回无效操作&#125; server端的linkToDeath只返回无效操作 BpBinder::linkToDeath () 123456789101112131415161718192021222324252627282930313233status_t BpBinder::linkToDeath( const sp&lt;DeathRecipient&gt;&amp; recipient, void* cookie, uint32_t flags)&#123; Obituary ob; ob.recipient = recipient; ob.cookie = cookie; //标识死亡接收者 ob.flags = flags; // LOG_ALWAYS_FATAL_IF(recipient == NULL, "linkToDeath(): recipient must be non-NULL"); &#123; AutoMutex _l(mLock); if (!mObitsSent) &#123; //mObitsSent用来表示Binder驱动程序是否已经向它发送过死亡通知，如果是，直接返回DEAD_OBJECT if (!mObituaries) &#123; //第一次注册 mObituaries = new Vector&lt;Obituary&gt;; //死亡通知对象列表 if (!mObituaries) &#123; return NO_MEMORY; &#125; ALOGV("Requesting death notification: %p handle %d\n", this, mHandle); getWeakRefs()-&gt;incWeak(this); //增加了弱引用计数 IPCThreadState* self = IPCThreadState::self(); self-&gt;requestDeathNotification(mHandle, this); // 记录对象 self-&gt;flushCommands(); //促使当前线程马上通过IO控制命令BINDER_WRITE_READ进入到Binder驱动程序中，以便可以执行注册死亡接受通知的操作 &#125; ssize_t res = mObituaries-&gt;add(ob); //非第一个注册 return res &gt;= (ssize_t)NO_ERROR ? (status_t)NO_ERROR : res; &#125; &#125; return DEAD_OBJECT;&#125; Binder代理对象内部的成员变量mObitsSent用来表示Binder驱动程序是否已经向它发送过死亡通知 若是，表示Binder本地对象已经死亡，返回DEAD_OBJECT 若否， 若第一次注册，记录Binder代理对象的地址，并立马调用Binder Driver执行注册死亡通知 非第一次注册，直接加入死亡通知对象列表mObituaries binderDied() 123456789101112class IBinder : public virtual RefBase&#123;public: class DeathRecipient : public virtual RefBase &#123; public: virtual void binderDied(const wp&lt;IBinder&gt;&amp; who) = 0;//重写父类DeathRecipient的成员函数binderDied &#125;; ......&#125;; 自定义的死亡通知接受者必须要重写父类DeathRecipient的成员函数binderDied。当Binder驱动程序通知一个Binder代理对象它所引用的Binder本地对象已经死亡时，就会调用它所指定的死亡通知接受者的成员函数binderDied 简述流程 Binder代理对象将一个死亡接收通知注册到Binder驱动程序中 当Binder驱动程序监控到它所引用的Binder本地对象死亡时，Binder驱动程序就会向Binder代理对象发送一个死亡通知 由BBinder::linkToDeath ()和BpBinder::linkToDeath ()代码可见 server进程死亡时，运行在其里的Binder对象就死亡，通过比较Binder代理存在，本地对象为空可知server端死亡，会通知到client代理对象，pmcs模块中即为BnPmcsProxy对象 client进程死亡时，没有通知任何对象。这时候Binder驱动程序就应该向那些引用了它的Binder代理对象发送死亡接受通知，以便它们可以知道自己引用了一个无效的Binder本地对象 一句话总结 client可以知道连接断开，server不知道什么时候断开，只有通过连接它的client来获得连接状态 1.2. 发送死亡接收通知​ 暂略 2. client检测连接状态由 binder对象死亡通知机制 可知，client端(PmcsProxy )可通过binder.linkToDeath(IBinder.DeathRecipient)获得连接状态，即server挂掉，通知Binder代理对象 1234567891011121314bool PmcsProxy::attachServer()&#123; const sp&lt;IPmcsService&gt;&amp; service(getPmcsService()); if(service.get() != NULL) &#123; if (mDeathNotifier == NULL) &#123; mDeathNotifier = new DeathNotifier&lt;PmcsProxy&gt;(this); &#125; service-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier); // 注册死亡通知 return true; &#125; return false;&#125; 3. server检测连接状态由 binder对象死亡通知机制 可知，server自身无法检测连接状态，只能通过与server端连接的client端来获取连接状态，即通过client端(PmcsProxy )的binder.linkToDeath(IBinder.DeathRecipient)，那么server端只要获取到client对象就可以检测连接状态 server如何获取和区分client？两种方法 server端给每个连接上的client端一个标识token client类增加一个token属性 当创建一个client时，server给其分配一个token标识 利用Binder的static方法，Binder.getCallingPid()来拿到client端的pid 二、连接断开后的重连由上文 监测连接状态 可知，在重写binderDied函数时，再次连接就好了 client检测到server断开，client重启server server检测到client断开，server重创建一个client]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binder-LinkToDeath]]></title>
    <url>%2F2020%2F05%2F06%2Fbinder-LinkToDeath%2F</url>
    <content type="text"><![CDATA[Pmcs类图理解1. 名词定义 名词 含义 BBinder 服务端接口 BpBinder 客户端接口 2. 使用Binder流程 开发native service 定义服务端接口文件，即IPmcsService类，其继承于IInterface类 定义BnPmcsService类，继承于BnInterface 实现一个PmcsService类，继承于BnPmcsService类，并实现响应客户端请求onTransact() 开发client BpBinder(客户端)如何把请求发送给BBinder(服务端)，BBinder又如何将响应传回给客户端的呢? 3. BBinder服务端 BBinder 实现了大部分的IBinder 接口，除了onTransact() 和 queryLocalInterface()， getInterfaceDescriptor() IInterface 实现queryLocalInterface()，该函数可查询服务端提供的服务 INTERFACE模板继承和实现IInterface BnInterface BnInterface 对象将自己强制转换成 IInterface对象返回给客户端 BnInterface是一个模板类，继承了BBinder和模板INTERFACE BnInterface 实现了IBinder的queryLocalInterface()和getInterfaceDescriptor() BnPmcsServer同时继承IInterface和IBinder，定义了onTransact()，没有实现 PmcsService里具体实现了onTransact() 4. BpBinder客户端​ 目标：找到一个类，它必须同时拥有IBinder 和 IIterface的特性 BpRefBase里有IBinder成员变量 BpInterface BpInterface继承于BpRefBase，而BpRefBase里有IBinder成员变量，从而获取到IBinder特性 BpInterface继承于INTRFACE，这里INTRFACE就是IPmcsService IInterface中函数asBinder()-&gt;BpInterface::onAsBinder()-&gt;BpInterface::remote()，返回得到mRemote BpPmcsService为客户端，具体向服务端发起请求 PmcsProxy为客户端的回调，服务端响应完请求后，调用回调向调用发起者通知执行结果 BpRefbase的mRemote是如何被赋值的？ 最后追溯到 IPmcsService.cpp 1interface_cast&lt;IMediaPlayer&gt;(reply.readStrongBinder()); //reply里读出IBinder,然后转成IMediaPlayer接口对象 通过子类一级一级注入，即new一个BpPmcsService，然后将其转换为父父类IPmcsService 客户端流程 ​ 客户端从远端生成一个IBinder对象，再生成BpPmcsService，将其转换为IpmcsService接口对象，调用其接口方法，最终调用到BpBinder的transact() ​ 而客户端的transact()函数通过Binder Driver获取到BBinder对象(IBinder的实现)，并调用onTransact() 5. 总流程 应用程序的角度 已知服务名，APP通过getService() 从ServiceManager 获取存储在Parcel对象的服务的信息 APP收到Parcel对象 (通过kernel)，获取到服务对应的服务号，mHandle 以mHandle作为参数输入生成一个IBinder对象(实际是BpBinder) APP获取到IBinder对象，通过asInterface(IBinder)生成服务对应的Proxy对象(BpPmcsService)，将其强转到*IPmcsService，调用接口函数 所有的接口对象调用最终会走到BpBinder-&gt;transact()函数，这个函数调用IPCThreadState-&gt;transact()并以Service号作为参数之一 最终通过系统调用ioctrl() 进入内核空间，Binder驱动根据传进来的Service 号寻找该Service正处于等待状态的Binder Thread, 唤醒它并在该线程内执行相应的函数，并返回结果给APP]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>通信机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理算法]]></title>
    <url>%2F2020%2F05%2F06%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[A.模糊(滤波)1.归一化盒子滤波(BoxFilter) 主要功能：在给定的滑动窗口下，对每个窗口内的像素值进行快速相加求和 缺点：无法克服边缘像素信息丢失缺陷，原因是均值滤波是基于平均权重 原理： 给定图像，宽高为(M,N)，确定待求矩形模板的宽高(m,n)，如图紫色矩形。图中黑色方块代表像素点，红色方块代表假象像素。 开辟一段大小为M的数组，记为buff，用来储存计算过程中的，存在红色假象像素点中 将矩形模板(紫色)从左上角，从左往右，从上往下单元素移动，每移动到新位置，计算矩形内的像素和保存在数组A(输出图片)中。以(0,0)位置为例： 将绿色矩形内的每一列像素求和，结果放在buff内(红色方块) 对蓝色矩形内的像素点求和，结果即为紫色特征矩形内的像素和，把它存放到数组A 每次紫色矩形向右移动时，实际上就是求对应的蓝色矩形的像素和，此时只需把上次的求和结果减去蓝色矩形内的第一个红色快，再加上其右边的红色块，就是当提前位置的和，公式表达为：sum[i] = sum[i-1] - buf[x-1] + buff[x+m-1] 当紫色矩形移动到行末时，需对buff进行更新。因整个绿色矩形下移一个像素，所以对于每个buff[i]需要加一个新进来的像素，再减去一个出去的像素，开始新一行的计算 此处为原理流程，源码见代码部分 2.高斯滤波 功能： 缺点：部分克服边缘像素信息丢失缺陷，但无法完全避免，因为没有考虑像素值的不同 原理： 3.中值滤波 功能： 缺点：部分克服边缘像素信息丢失缺陷，但无法完全避免，因为没有考虑像素值的不同 原理： 4.双边滤波 功能： 优缺点：避免边缘信息丢失，保留图像轮廓不变 原理： B.形态学操作1.定义 形态学定义 函数定义 原理 应用 膨胀 dilate 取领域内最大值作为中心点新像素值 前景为黑，变小；前景为白，变大 腐蚀 erode 取领域内最小值作为中心点新像素值 前景为黑，变大；前景为白，变小 开操作 open 先腐蚀后膨胀(注意：结构元素需设置为包含部分目标对象) 假设对象是前景色，背景是黑色，可以去掉小的对象 闭操作 close 先膨胀后腐蚀 假设对象是前景色，背景是黑色，可以填补小的洞 形态学梯度 Morphological Gradient 膨胀减腐蚀，dst = morph(src, element) = dilate(src, element) - erode(src, element) 又称为基本梯度(其他还包括内部梯度、方向梯度) 顶帽 top hat 源图像与开操作之间的差值图像 黑帽 black hat 闭操作与源图像的差值图像 2.提取水平与垂直线 提取步骤 输入彩色图像-imread 转换为灰度图像-cvtColor 转换为二值图像-adaptiveThreshold 定义结构元素 开操作(腐蚀+膨胀)提取水平与垂直线 启示： 卷积核可根据需要更改形状，从原图提取想要的形状 提取文字、图像(去除干扰点)，可用不同卷积核 C.图像上采样和降采样 图像金字塔： 高斯金字塔：用来对图像进行降采样 从底向上，逐层降采样得到 降采样之后，图像大小是原图MN的M/2 N/2（1/4），即对原图像删除偶数行与列，得到降采样后上一层的图片 两步生成过程： 对当前层进行高斯模糊 删除当前层的偶数行与列 高斯不同： 定义：把同一张图像在不同的参数下做高斯模糊之后的结果相减，得到的输出图像成为高斯不同(DOG) 高斯不同是图像的内在特征，在灰度图像增强‘角点检测中常用到 拉普拉斯金字塔：用来重建一张图片，根据它的上层降采样图片 D.基本阈值操作 图像阈值 定义：图像分割的标尺 阈值产生的算法 THRESH_OTSU THRESH_TRIANGLE 阈值类型 阈值二值化(threshold binary)：大于取阈值，小于取零 阈值反二值化(threshold binary inverted)：大于取零，小于取阈值 截断(truncate)：大于处取阈值，小于不变 阈值取零(threshold to zero)：大于不变，小于取零 阈值反取零(threshold to zero inverted)：大于取零，小于不变 E.自定义线性滤波 卷积概念 卷积是图像处理中一个操作，是kernrl在图像的每个像素上的操作 kerner本质上是一个固定大小的矩阵数组，其中中心点为锚点(anchor point) 求锚点周围覆盖的像素乘积之和(包括锚点)，除以卷积数组大小，用来替代锚点下像素点值 常见算子 Robert算子：2*2，{1, 0, 0, -1}或{0, 1, -1, 0}，寻找梯度、边缘 Sobel算子：3*3，{-1, 0, 1, -2, 0, 2, -1, 0, 1}或{-1, -2, -1, 0, 0, 0, 1, 2, 1}，常用于边缘检测 拉普拉斯算子：3*3，{0, -1, 0, -1, 4, -1, 0, -1, 0},寻找梯度、边缘 自定义卷积模糊 F.边缘处理 卷积边缘问题： 图像卷积的时候边界像素不能被卷积操作 原因在于边界像素没有完全跟kernel重叠 边缘处理 在卷积开始之前增加边缘像素，填充像素值为0或RGB黑色 opencv中默认方法为：BORDER_DEFAULT BORDER_CONSTANT - 用指定像素值填充边缘 BORDER_REPLICATE - 用已知的边缘像素值填充边缘像素 BORDER_WRAP - 用另外一边的像素来补偿填充 G.sobel算子 卷积应用-图像边缘提取 图像像素值渐变或突变，求导取最高点即为跃迁点(变化最大) Sobel算子 Sobel算子：3*3，{-1, 0, 1, -2, 0, 2, -1, 0, 1}或{-1, -2, -1, 0, 0, 0, 1, 2, 1}，常用于边缘检测 是离散微分算子(discrete differentiation operator)，用来计算图像灰度的近似梯度 Sobel算子功能集合高斯平滑和微分求导 又称为一阶微分算子，求导算子，在水平和垂直两方向求导，再平方和开根号(绝对值之和)，得到(图像x与y方向)梯度图像 Schar函数 求取导数的近似值，kernel=3时不准确，opencv使用改进版本Scharr函数，3*3，{-3, 0, 3, -10, 0, 10, -3, 3}或{-3, -10, 3, 0, 0, 0, 3, 10, 3} 代码流程 高斯平滑：使图像像素平滑变化 转灰度 求梯度x和y 混合xy 个人理解： 用卷积和扩大水平/垂直像素差异 H.laplance算子 原理 比sobel算子更进一步，这里采用 二阶导为零处即为像素值变化最大处 流程 高斯模糊-去噪声GaussianBlur() 转灰度cvtColor() 拉普拉斯-二阶导计算Laplance() 取绝对值convertScaleAbs() I.Canny边缘检测 流程： 高斯模糊GaussianBlur 将高斯算子与原图像卷积 灰度转换cvtColor 计算梯度Sobel/Scharr：像素值差异的地方 非最大信号抑制 将当前像素的梯度强度与沿正负方向梯度方向上的两个像素比较 若当前像素的梯度强度与另外两个像素相比最大，则该像素点保留位边缘点，否则该像素点会被抑制 高低阈值输出二值图像：抑制噪声引起的弱边缘 J.霍夫变换 霍夫直线变换 简介 用来做直线检测 前提条件：边缘检测已完成 平面空间到极坐标空间转换 原理 图形原理在notability中，后续整理 r = x cos(theta) + y sin(theta) canny边缘检测 逐像素点进行霍夫空间变换：由像素坐标系(x,y)变换到笛卡尔坐标系(r, theta) 局部非极大值抑制：去除噪声点 对笛卡尔坐标系中的点排序 求得笛卡尔坐标系中点极大值对应的角度和距离 将笛卡尔坐标转为像素坐标，画线 霍夫圆变换(21HT) $r^2 = (x-a)^2 + (y-b)^2$ 第一阶段：检测圆心 （中值滤波：去除噪声） canny边缘检测 sobel计算图形梯度，并确定圆周线，其中圆周的梯度就是其法线 在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心 在霍夫空间的4邻域内进行非最大值抑制 设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心 第二阶段：检测半径 计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量 设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小 对保留下来的距离进行排序 找到距离相同的那些值，并计算相同值的数量 设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径 对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径 K.像素重映射 定义：g(x, y) = f(h(x, y)) 把输入图像中各个像素按照一定规则映射到另一张图像对应位置 cv::remap() L.直方图均衡化 图像直方图 定义：统计整个图像在灰度范围内的像素值(0-255)出现的频率次数 反映：图像灰度的分布情况 流程 计算原图像素值概率 从小到大累加像素值概率 用 累加概率 * 像素最大值 之积 替换原图像像素值 cv::equalizeHist(src, dst) 输入为灰度图 应用：提高图像对比度、拉伸图像灰度值范围，同时图像的细节更为丰富]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>图像处理，人工智障</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning OpenCV3]]></title>
    <url>%2F2020%2F05%2F06%2FLearning-OpenCV3%2F</url>
    <content type="text"><![CDATA[Learning OpenCV3一、Overview1.计算机视觉概念类比于人在道路两侧停放的车中寻找特定的车，图像信号通过眼睛传输到大脑，大脑有注意力识别系统：通过任务依赖的方式，检查图像重要区域，抑制其他区域。利用人生活多年来形成的交叉关联的感觉识别重要信息，再由大脑的反馈回路返回到传感器(眼睛肌肉)，进一步去获取需要的图像。 ###2.遇到的问题 用2D去描绘3D世界的误差，数据的失真和噪声破坏。具体如下： 上下文信息： 例子： 机器人在房子里捡起订书机，首先机器人可能会用到以下事实：办公桌是办公室内的对象，而订书机是最大可能在办公桌上找到，这是一个隐式的大小位置参考；且机器人需要忽略相同大小形状的小木盒、以及墙画上的订书机图片。 相反，对于图像检索任务，机器人查询的数据库里都是真实的订书机，很可能就只拍摄了正常尺寸的订书机；在拍摄这些图片时，也隐藏这很多无意的隐式信息。 解决： 使用机器学习进行显示建模，对隐藏变量(大小、形状、重力方向等)用与他们值相关的标签训练集中进行校正。或者使用其他传感器测量隐藏的偏差分量。 噪音 例子： 仅通过几个点比较无法检查出物体边缘，有些像素点可能在生成、传输的途中遭到破坏，不能准确识别。 解决 统计局部区域可较准确的进行边缘检测 通过建立直接从数据中学到的显式模型来描述，如人们已经很了解镜头畸变，只需建立一个多项式模型参数，通过调整参数从而更正失真。 二、opencv入门示例简单的入门示例，这里有一个正好前段时间涉及到的边缘检测算法(二值化-&gt;区分前后景)，效果如下： ​ 阈值为1、10，可以看到边缘检测很不清晰，把很多rgb值高的点也包含进来 ​ 阈值为10、100，可以看到颜色较重的区域也能区分出来 ​ 阈值为100、500，这样小鱼的边缘就很清晰了 三、OpenCV数据类型从组织的角度来看，数据分为以下三类： c++原语(int, float等)：简单向量和矩阵、简单几何概念(点、矩阵、尺寸等) 辅助对象：抽象概念，如垃圾回收指针、切片对象、终止条件等 大数组类型 1.基本类型 Point 基于模板结构实现的，可以是任何类型的点 分类： 二维、三维、四维点 cv::Point2i，最后一个字母表示构造点的原语类型。（b:无符号字符，s:短整型，i:32位整数，f:32位浮点数，d:64位浮点数） 操作： | 运行方式 | 例子 || :——————: | :———————–: || 默认构造函数 | cv::Point2i p; || 复制构造函数 | cv::Point3f p2(p1) || 值构造函数 | cv::Point3d p(x0, x1, x2) || 转换为固定向量类 | (cv::Vec3f) || 访问成员 | p.x; || 点乘 | float x = p1.dot(p2); || 双精度点乘 | double x = p1.ddot(p2); || 叉乘 | p1.cross(p2); || 查询点p是否在矩形r里 | p.inside(r); | cv::Scalar类 四维点类，所有成员时双精度浮点数 | 运行方式 | 示例 || :—————: | :————————————————-: || 默认构造函数 | cv::Scalar s; || 复制构造函数 | cv::Scalar s2(s1); || 值构造函数 | cv::Scalar s(x0, x1, x2, x3); || 逐元素乘法 | s1.mul(s2); || (四元数)共轭 | s.conj(); // (return cv::Scalar(s0, -s1, -s2, -s3)) || (四元数)real test | s.isReal(); // (returns true if s1==s2==s3==0) | 该类操作强制转换到固定向量类，与point类不同，cv::Scalar直接从固定向量类模板的实例化中继承 size size类类似于point类，类型有Size、Size2i、Size2f,唯一区别就是命名区别(x、y与width、height) | 运行方式 | 示例 || :———-: | :——————: || 默认构造函数 | cv::Size sz; || 复制构造函数 | cv::Size sz2(sz1); || 值构造函数 | cv::Size2f sz(w, h); || 访问成员 | sz.width; sz.height; || 计算面积 | sz.area(); | Rect 矩形类包含point类的成员x，y(代表矩形左上角坐标)，和宽高类(矩形的大小)，但矩形不继承点类 | 运作方式 | 示例 || :————————–: | :——————————-: || r1、r2矩形的交点 | cv::Rect r3 = r1&r2; r1 &amp;= r2; || 包含矩形r1、r2的最小面积矩形 | cv::Rect r3 = r1 ! r2; r1 |= r2; || 用x平移矩形r | cv::Rect rx = r + x; r += x; || 将矩形r按大小s增大 | cv::Rect rs = r + s; r += s; || 比较矩形是否相等 | bool eq = (r1 == r2); || 比较矩形是否不 | bool eq = (r1 != r2); | RotatedRect c++ Opencv接口中为数不多的没有模板的类之一，相反，这是一个容器，保存了一个cv::Point2f(中心)，一个cv::Size2f(大小)和一个额外的浮点数(角度)，角度表示矩形围绕中心的旋转 | 运行方式 | 示例 || :————————: | :—————————-: || 默认构造函数 | cv::RotatedRect rr(); || 复制构造函数 | cv::RotatedRect rr2(rr1); || 从两个角度构建 | cv::RotatedRect(p1, p2); || 值构造函数(点，大小，角度) | cv::RotatedRect(p, sz, theta); || 访问成员 | rr.center; rr.size; rr.angle; || 返回角列表 | rr.points(pts[4]); | fixed matrix 固定矩阵类是指在编译时位数已知的矩阵，其数据的所有内存都分配在堆栈上，意味着可以快速地分配和清理。在c++ Opencv接口中，固定矩阵类实际上是一个模板，是许多其他基本类的核心(固定向量类派自固定矩阵类，其他类则派生自固定向量类)。 | 运作方式 | 示例 || :——————————: | :———————————————————-: || 默认构造函数 | cv::Matx33f m33f; cv::MAtx43d m43d; || 复制构造函数 | cv::Matx22d m22d(n22d); || 值构造函数 | cv::Matx21f m(x0, x1); || 相同元素的矩阵 | m33f = cv::Matx33f::all(x); || 零矩阵 | m23d = cv::Matx23d::zeros(); || 一个矩阵 | m16f = cv::Matx16f::ones(); || 创建单位矩阵 | m33f = cv::Matx33f::eye(); || 创建一个可容纳另一个对角线的矩阵 | m31f = cv::Matx33f:diag(); //31的矩阵 || 创建一个具有均匀分布项的矩阵 | m33f = cv::Matxf::randu(min, max); || 创建一个具有正态分布条项的矩阵 | m33f = cv::Matx33f::nrandn(mean, virance); || 访问成员 | m(i, j); m(i); || 矩阵代数 | m1 = m0; m0 m1; m0 + m1; m0 -m1; || 单例代数 | m a; a m; m / a; || 比较 | m1 == m2; m1 != m2; || 点积 | m1.dot(m2); //m的精度 || 点积 | m1.ddot(m2); //双精度 || 重塑矩阵 | m91f = m33f.reshape(); || 类型转换 | m44f = (Matx44f)m44d; || 提取子矩阵 | m44f.get_minor(i,j); || 提取第i行 | m14f = m44f.row(i); || 提取第j列 | m14f = m44f.col(j); || 提取矩阵对角线 | m41f = m44f.diag(); || 计算转置 | n44f = m44f.t(); || 求逆矩阵 | n44f = m44f.inv(method); //默认方法为cv::DECOMP_LU || 解线性方程组 | m31f = m33f.solve(rhs31f, method); m32f = m33f.solve2(rhs32f, method); // 模板表单，默认方法为DECOMP_LU || 逐元素乘法 | m1.mul(m2); | 注意，许多固定矩阵函数相对于类都是静态的(作为类的成员而不是特定的成员直接访问他们)，如构造3*3的矩阵，cv::Mat33f::eye()。 fixed vector 固定向量类是从固定矩阵类派生的，可以看作cv::Matx&lt;&gt;的便捷功能。 | 运作方式 | 示例 || :———-: | :——————-: || 默认构造函数 | Vec2s v2s; Vec6f v6s; || 复制构造函数 | Vec3s u3f(v3f); || 值构造函数 | Vec2f v2f(x0, x1); || 访问成员 | v4f[i]; v3w(j); || 向量叉乘 | v3f.cross(u3f); | 主要便利是使用单顺序访问元素 complex number 复数类与STL复合体关联的类最实质的区别在于：在STL类中，通过real()和image()访问实数和虚数；而在OpenCV类中，直接访问公共成员变量re和im 2.辅助对象 TermCriteria 停止条件 Range 范围 Ptr模板和垃圾回收 c++中智能指针，该指针是我们能创建对对象的引用，所有引用被计数，当引用超出范围时，智能指针的引用计数将减少，一旦所有引用(指针的实例)减到0，实例对象将被自动清除(已分配)。 与c++中智能指针类似，为想要“包装”的类对象实例化一个指针模板(cv::Ptr p = makePtr())，模板对象的构造函数指向对象的指针。此操作后，智能指针p可像普通指针一样传递和使用(即，支持运算符operator*()和operator-&gt;()),可创建其他相同类型的对象，而不需要向它们传递新对象的指针。如：Ptr q，并将p的值赋给q。这里只有一个实际的p和q指向的cv::Mat33f对象，p和q都知道他们各自为1.若p消失(超出范围)，则q知道它时唯一剩下的对源实矩阵的引用；若q消失，且其析构函数被调用，q就知道它时唯一引用的指针，q会取消分配原始矩阵。 Exception类和异常处理 DataType 当OpenCV库函数需要传递特殊概念的数据类型时，可通过创建cv::DataType&lt;&gt;类型的对象来实现。传递的实际对象时这个模板的实例对象。 1234567891011121314151617// OpenCV中DataType的定义template&lt;&gt; class DataType&lt;float&gt;&#123;public: typedef float value_type; typedef value_type work_type; typedef value_type channel_type; typedef value_type vec_type; enum &#123; generix_type = 0, depth = DataDepth&lt;channel_type&gt;::value, channels = 1, fmt = DataDepth&lt;channel_type&gt;::fmt, type = CV_MAKETYPE(depth, channels) &#125;;&#125;; InputArray和OutputArray 输入、输出对象 3.实用函数除了上述专用原始数据类型，OpenCV还提供一些有效处理数学运算和其他运算的专用功能，该使用功能包含数学工具、测试、错误生成、内存和线程处理、优化等 函数 功能 cv::aliginPtr() 将指针对齐到给定的字节数 cv::aliginSize() 将缓冲区大小与给定的字节数对齐 cv :: allocate() 分配c样式的对象数组 cvCeil() 将浮点数向上取整 cv::cubeRoot() 计算立方根 cv::CV_Assert() 若给定条件不成立，则引发异常 CV_Error() 宏以构建cv :: Exception （从固定字符串）并将其抛出 CVErrpr() 宏来构建cv :: Exception （从格式化的字符串）并抛出它 cv::deallocate() 取消分配c样式的对象数组 cv::error() 提示错误并引发异常 cv::fastAtan2() 计算向量的二维角度 cv::fastFree() 取消分配内存缓冲区 cv::fastMalloc() 分配对齐的内存缓冲区 cvFloor() 将浮点数向下取整 cv::format() 使用类似sprintf的格式，创建STL字符串 cv::getCPUTickCount() 从内部cpu计时器获得滴答计数 cv::getNumThreads() 计算OpenCV当前使用的线程 cv::getOptimalDFTSize() 为计划传递给cv::DFT()的数组计算最佳大小 cv::getThreadNum() 获取当前线程的索引 cv::getTickCount() 从系统获取滴答计数 cv::getTickFrequency() 每秒获取数字/刻度 cvIsInf() 检查浮点数x是否为无穷大 cvIsNan() 检查浮点数是否为“非数字“ cvRound() 将浮点数舍入到最近的整数 cv::setNumThreads() 设置OpenCV使用的线程数 cv::setUseOptimized() 启/禁用代码优化 cv::useOptimized() 指示代码优化启用的状态 具有旧版界面的功能，为c定义的。 4.模板结构四、图像和大数组类型1.动态和可变存储 cv::Mat类：N维密集数组 cv::mat类可用于任何数目维度的阵列，数据储存在数组中，可以认为是一个n维“光栅扫描”的模拟。每个矩阵包含一个表示数组内容的flags元素、一个表示维度的dims元素、行列元素、一个表示位置的数据指针、以及一个引用计数器 .可把数组理解为. 生成一个数组 实例化一个cv::Mat类，并通过其成员函数create()来分配数据，其所需参数：行数、列数、类型、以及数组代表二维对象的配置。有效数组类型指定元素的基本类型和通道数量，所有这些类型都在库头文件中定义，其形式为:CV_{8U,16S,16U,32S,32F,64F}C{1,2,3}.如：CV_32FC3代表一个32位浮点三通道数组. 12345678//示例cv::Mat m;m.create(3, 10, CV_32FC3); // 为一个3行10列3通道的32位浮点数组分配数据m.setTo(cv::Scalar(1.0f, 0.0f, 1.0f)); // 三通道值分别为1.0, 0.0, 1.0// 等效上三行cv::Mat m( 3, 10, CV_32FC3, cv::Scalar( 1.0f, 0.0f, 1.0f ) ); 构造函数 | 函数 | 功能 || :———————————————————-: | :—————————————: || cv::Mat(); | 默认构造函数 || cv::Mat(int rows, int cols, int type); | 二维数组 || cv::Mat(int rows, int cols, int type, const Scalar&amp; s); | 带初始值的二维数组 || cv::Mat(int rows, int cols, int type, void data, size_t step=AUTO_STEP); | 具有类型的二维数组，预先存在的数据 || cv::Mat(cv::Size sz, int type); | 二维数组，sz大小 || cv::Mat(cv::Size sz, int type, const Scalar&amp; s); | 带初始值的二维数组,sz大小 || cv::Mat(cv::Size sz, int type, void data, size_t step=AUTO_STEP); | 具有类型的二维数组，预先存在的数据,sz大小 || cv::Mat(int ndims, const int sizes, int type); | 多维数组 || cv::Mat(int ndims, const int sizes, int type, const Scalar&amp; s); | || cv::Mat(int ndims, const int sizes, int type, const Scalar&amp; s, size_t step=AUTO_STEP); | | 复制构造函数 | 函数 | 功能 || :———————————————————-: | :———————————————–: || cv::Mat(const Mat&amp; mat); | 复制构造函数 || cv::Mat(const Mat&amp; mat, const cv::Range&amp; rows, const cv::Range&amp; cols); | 复制构造函数，仅能复制行和列 || cv::Mat(const Mat&amp; mat, const cv::Rect&amp; roi); | 复制构造函数，仅能复制感兴趣区域(roi)的行和列 || cv::Mat(const Mat&amp; mat, const cv::Range* ranges); | 通用区域复制构造函数，复制一块范维数组 || cv::Mat(const cv::MatExpr&amp; expr); | 复制用其他矩阵的代数表达式的结果初始化m的构造函数 | 模板构造函数 | 函数 | 功能 || :———————————————————-: | :—————————————————–: || cv::Mat(const cv::vec&amp; vec, bool copyData = true); | 从同一类型的cv::Vec中构造一个类型为T、大小为n的一维数组 || cv::Mat(const cv::Matx&amp; vec, bool copyData = true); | 从同一类型的cv::Matx中构造一个尺寸为m×n的T型二维数组 || cv::Mat(const std::vector&amp; vec, bool copyData = true); | 从包含相同类型元素的STL向量构造T类型的一维数组 | 静态函数 | 函数 | 功能 || :——————————–: | :——————————————————: || scv::Mat::zeros(rows, cols, type); | 创建rows行cols列的cv::Mat,初始全为0，类型为type || scv::Mat::ones(rows, cols, type); | 创建rows行cols列的cv::Mat,初始全为1，类型为type || scv::Mat::eye(rows, cols, type); | 创建rows行cols列的cv::Mat,初始为identity矩阵，类型为type | 分别访问数组元素 几种访问函数 | 函数 | 功能 || :——————-: | :——————————–: || M.at(i); | 整数数组M中第i个元素 || M.at(i, j); | 浮点数组M中(i,j)位置元素 || M.at(pt); | 整数矩阵M中(pt.x, pt.y)位置的元素 || M.at(i, j, k); | 三维浮点数组M中(i, j, k)位置的元素 || M.at(idx); | uchar数组M中idx[]位置的元素 | 还可通过怕c样式的指针访问二维数组 对于矩阵，有两种方法获取其数据指针： 成员函数ptr&lt;&gt;() M.at&lt;&gt;() N元数组迭代器:NAryMatlterator 一次遍历多个数组，返回数组块，称为planes，常用于多数组计算(多点代表面) 按快访问数组元素 未完待续！]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>图像处理，人工智障</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c知识点]]></title>
    <url>%2F2019%2F08%2F24%2Fc-plus%2F</url>
    <content type="text"><![CDATA[知识点总结 知识点总结 数据存放位置 c++内存模型 class const static &amp; 初始化 volatile template virtual 构造/析构函数 operator 指针、引用 双指针、指针引用 条件编译 资源管理 提供对原始资源的访问 数据存放位置 本地变量：栈 new出的对象：堆 static/全局变量：全局数据区 c++内存模型 存放对象的地方 栈 堆 全局数据区 访问对象的方式 变量访问对象 指针访问对象 引用访问对象 class struct默认public class默认private 其他用法完全一样，都包含成员函数、继承、多态 const 只需看其右侧最近的类型 *前后 前：指针指向变量 后：指针本身是变量 函数前后 前：函数返回值为const 后：函数成员为const 最后：此成员函数不改变类中的成员变量(mutable可变的) static 静态局部变量： 全局数据区分配内存 随函数第一次调用时初始化，程序结束时销毁 声明处初始化，若无显式初始化，会自动初始化为0 作用域为局部作用域 静态全局变量： 静态函数： 本文件可见(文件隔离) 静态数据成员： 只有class有一份，而普通数据成员是每一个实例有一份 静态成员函数： 静态成员函数不能访问非静态(成员函数、数据成员) 非静态成员函数可以访问静态(成员函数、数据成员) 解释：静态是属于类的，它不知道创建了多少对象；而对象中的数据对类中数据一清二楚 &amp; 引用 在赋值＝右侧 和变量在一起 取地址 在赋值＝左侧 和类型在一起 初始化 A::A(int m, int n) : x(m), y(n) {} //初始化 A::A(int m, int n){x = m; y = n;} //赋值 singleton模式：local static对象替换non-local static对象 基础在于：c++保证，函数内的local static对象会在”该函数被调用期间“”首次遇上该对象之定义式“时被初始化。 volatile 声明的变量可能随时变化，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问 从所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。 应用在共享变量 template // TODO: virtual virtual析构函数用于多态基类的声明 被用作base class的类声明为virtual析构函数，其他类不要声明virtual析构函数(对象体积增大，不能将其传给其他语言写的函数－无移植性) 类的设计目的如果不是base class或具有多态性，就不该声明virtual析构函数 别让异常逃出析构函数 结束程序 try{…}catch{…;std::abort;} 吞掉异常 try{…}catch{…;} 前两者的优化： 构造/析构函数 构造函数调用顺序：base -&gt; derived 析构函数调用顺序：derived -&gt; base 在构造/析构函数中不要调用虚函数，因为这类的调用不会下降至derived class(相对的) operator 令重载操作符返回一个reference to *this 处理自我赋值(赋值时两个为同一个对象，删除一个就都删除了) 证同测试，并跳过处理流程 用副本去操作 copy and swap copy函数 确保复制”对象内的所有成员变量” 和 “所有base class成分” 不要用一个copy函数实现另一个copy函数，应该将共同机能放入第三函数，并由两个函数共同调用 指针、引用 指针 概述：指针传递参数本质上是值传递的方式，其传递一个地址值 流程：值传递的过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为实参的一个副本 特点：被调函数对形参的任何操作都是作为局部参数进行，不影响主调函数是参变量的值 应用： 不改变指针指向，形参指向实参，可操作实参 改变指针指向，则形参作为副本，与实参无关，不可操作实参 引用 概述：引用传递本质是地址传递，传递的是实参变量的地址 流程：被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 区别 指针传递参数时，指针中存放的也是实参的地址，但是在被调函数内部指针存放的内容可以被改变，即可能改变指向的实参，所以并不安全 而引用则不同，它引用的对象的地址一旦赋予，则不能改变 双指针、指针引用// TODO: 条件编译 当标识符定义过了,编译程序段1,否则编译程序段212345#ifdef 标识符程序段1else程序段2#endif 资源管理 以对象管理资源 为防止资源泄露，请使用RAII对象(tr1::shared_ptr、auto_ptr)，它们在构造函数中获得资源并在析构函数中释放资源 提供对原始资源的访问 问题:如何调用一个对象 123std::tr1::shared_ptr&lt;Investment&gt;pInv(createInvestment());int daysHeld(const Investment* pi); // 返回投资天数int days = daysHeld(pInv); // 调用出错 编译不通过,daysHeld需要Investment*指针,传入的却是类型为tr1::shared_ptr的对象 解决办法: 智能指针 显示转换: trl::shared_ptr和auto_ptr都提供了一个get成员函数，它会返回只能指针内部原始资源指针（的复件） 隐式转换： 利用重载了的取值操作符（operator-&gt;和operator*)，其允许隐式转换至内部原始指针 类 123456789FontHandle getFont(); //APIvoid releaseFont(FontHandle fh); // APIclass Font &#123;public: explicit Font(FontHandle fh) : f(fh)&#123;&#125; // 获取资源,pass-by-value ~Font() &#123;releaseFont(f);&#125; // 释放资源private: FontHande f; // 原始字体资源&#125;; font类中添加两种解决办法 显式转换 123456789101112class Font &#123;public: ... FontHandle get() const &#123;retun f;&#125; //显示转换 ...&#125;;//调用void changeFontSize(FontHandle f, int newSize); // APIFont f(getFont());int newFontSize;cangeFontSize(f.get(), newFontSize); //显示将Font转换为FontHandle 问题: 增加泄漏字体的可能性,而Font类的主要设计目的是为了防止资源(字体)泄露 隐式转换 1234567891011Class Font &#123;public: ... operator FontHandle() const &#123;return f;&#125; // 隐式转换 ...&#125;;// 调用Font f(getFont());int newFontSize;changeFontSize(f, newFontSize); // 将Font隐式转换为FontHandle 问题: 123Font f1(getFont());FontHandle f2 = f1; // 原意是要拷贝一个Font对象 //却反将f1隐式转换为FontHandle对象,然后才复制它]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>总结</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所为所得]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%89%80%E4%B8%BA%E6%89%80%E5%BE%97%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clox编译器]]></title>
    <url>%2F2019%2F07%2F19%2Fclox-compiler%2F</url>
    <content type="text"><![CDATA[clox(持续更新中，目前到scanner)clox是由Bob Nystrom基于ｃ编写的编译器，最终解释结果编译成字节码，通过编写学习，可以了解编译器的基本原理主流程主要分为三步： 扫描 编译 执行(虚拟机) github代码库:zaizizaizai 推荐：原文教程请戳这里 极度推荐项目库：project-based-learning 目录结构 文件说明 流程 clox编译器整个代码逻辑流程 执行减法(3-1)的流程 结构 chunk结构 ValueArray结构 VM结构 函数以及参数说明 reallocate() OP_CONSTANT 文件说明 文件名 功能 common 通用引用库文件 memory 数组增删的逻辑，基础的内存管理 chunk chunk节点：结构定义,属性的更改;储存源代码 value 常量池，常量类型结构的定义及实现 debug 反汇编提示信息 main 主函数 vm 虚拟机－指令执行器;解释执行源代码 compiler 编译 scanner 扫描代码段 流程clox编译器整个代码逻辑流程 执行减法的流程 结构chunk结构1234567typedef struct &#123; int count; //实际使用大小 int capacity; //分配数组的容量 uint8_t* code; //指令 int* lines; //线信息 ValueArray constants; //常量列表&#125; Chunk; 分配具有更多容量的新数组 将现有元素从旧数组复制到新数组 更新capacity 删除旧数组 更新code指向新数组 既有空间，也可将元素储存在新数组中 更新cout ValueArray结构12345typedef struct&#123; int capacity; //容量 int count; //实际使用大小 Value* values; //数值&#125; ValueArray; VM结构1234typedef struct &#123; Chunk* chunk; uint8_t* ip; //指令指针(PC机中的程序计数器)&#125; VM; 函数以及参数说明reallocate函数传递两个参数给reallocate()控制要实现的操作 oldsize newSize 操作 0 非0 分配新块 非0 0 重置为空 非0 &lt; oldSize 缩小现有分配 非0 &gt; oldSize 增加现有分配 OP_CONSTANTOP_CONSTANT采用单字节操作数制定从块的常量数组加载哪个常量 文章顶部]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python核心(一)]]></title>
    <url>%2F2019%2F01%2F19%2Fpython%E6%A0%B8%E5%BF%83-%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[大海与生活]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%A4%A7%E6%B5%B7%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19ususyN/YPm1Ysu29v/GO8s6Ny/tvBJJDNB7YxL88MnVYVoQcERisWP3EGE8cv0JC90onmrAoszjSNzfgcpOrvoZ8SI9Cwm74gqfn6DkVqCKu/YS7GHC+x7sXpcv6KHHN+UkajyN+naPGdTRCzS4JZLo8gT1Z2y2ULHZwq96yTG/ahD+/vmgfIcrO10sPVdurZESFMCHXhbogli3hI1yqi2AkvDtmjLt/i9+M5Y5+7MOY0xh5BmbCHJVYZyqRg1Kxnm/d+L9cUgAo0HQhFbiDIdgt5cDR6bAkzgkip5JZGQIFNtZhCHL5xFml97xBfc/SW5sl4pRxFRC5GzbEaHdKyRjLMNXmIqutCpPbtL57iKFnX9wZFnxat3AGQAjJwcS2cv7H6QFAB9c4QlCl6pTHdG6KX8xOT6r4=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+pdtr3a4tVWUkkUTqU/DB01WtU2u61OoflsvS3YDvMOka+468qUI+zFB+QGs/dbvDIzT1GFdksJhh+GjL7tal3EQ8rBFmwuFXeVz/u3LNS+FU0b1C/4Hg/vdNS7aGly9QLzSVd5eKFD2iUcp1sE25e5BbZI/YPl7Hji9NiSKjNGmp2LbnaXPCxLrwbxkAKQ/hhq1uOZ3nOY2PWV7AFk3P4gDT0aGsOff//K0uAOtKYEkL8zSDOKWKg90UjsRnobRkl9Vhj4KJbfv17zYHH/at7VLUtAoCFlkzazQnKq0D5VtvFz92aEjNafzlxxTaSWeYibvtFTmo0RA9ml6TO3eUoUfqG3EEtlZG2UrHlUfarhJV9JPafSvX8sSTZCTbGfbzE0eGZZvrpO8PWcFbfMpsQFz49HVOMPHw+bEyifiKbct2cq9SDmJ/w4WDmcFOO/jqDJhBK2OZDZ/tmhOh0BwgZiZ+ArSmItVbILbUu1ptfNGb8WpVZgKLU2uyQs19U4fBevYoRnBGUrA==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自信]]></title>
    <url>%2F2018%2F08%2F04%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致未来的你]]></title>
    <url>%2F2018%2F07%2F07%2F%E8%87%B4%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+tbD+Uu8OUu9LEMwL+wKkQ0aN9hw7+NofyCCPdh72adOO7zE4bpEHvR1Ismxepa2DTHOpFgMieRKiB2RDu1t9pTGAecVBRqGl0ztPgNxEs++6u+JMmReQldz1NTmxq2lm47aQvAbi1k/5aDfPC6C6z3opTKKbOFvfM8BWaFNX44eqkpb2dUmtNKsR3pHfhps7iV/rEH+v+eho3LOiziFYp3nYJCH5enQ7hv19EYlan9EvVpxC/3ZqswEGngPKgui1yoxIpfWngMB0YqKcv0wUAGsMyNXkAIfpcGa6gj5ruQApSl3G/GK3eOwHsekhG8wrh2ZUXBfNjQaIzY4qIrBOiqQ/4x/8NX2SGtJ56J1eaXiQeoSsHOCxVkMiEm9UUPO2y8Ux5kamEAfXU3SMdGSyjuK+ietW5KqcKBKh1rAC7s5n7tv8LAhDkT3qC1D2maPz2t2WDaJ27Ev6VDah+8U4i/zVOC3oK/V8l2sy9AXRC27BTR41gsL9SSKd+HjpkO8E915tKZJ2PpR8VgSeKZE6abiT95G/MHHF7tjXVHGbn5Hp2mzNbvJGglLDlsn4Qwa0cj7fOBCWoQkz/6IauehMqa74FP+J5VuXQGiipz7tNebrUBOTPKiDVPnoy79Wg5visk2xxb0vJnyOjD5yOZrAxqF66qVJZVa2M51a3pAw3+49999RX5dGFY/lQQQuEaWcp71/G9lZJV/kfOK5nmQdnmwlDB1A0+pwisfujcoufjgsXBCl1W/wiLeHVGTJsF5qoxtq/KE9nfZdCL+Sa+C+My7A88wzi+QHV3hbSRwuLxqZoGYY6bPCKaad35Fe6cUTaELuODQL7S5ezVU5Laau9dE9RCKNgyyXQ/fJf0/sNDN/rSelTtDzXHLLGkxUnkXU4InlFBQZt1naZuqvAG3SOMY0+n0mmCpLHRDqKIyr24dH0Q86z6kzmqbuqxQUp49fIi3TMqk8RzySUQoqVpJwdsfPTrPV5WlUxCpmSwYIZtVbIZzj1mv+COvWBNhMl96tydVEqVdzJnnT80VCFJIr7FUPhYmpOqnjF7iMQoVoUGEZD4U0E1zTWTSDiNiMFWbJ4TYzztAsx3biABsPUJM5aHXITlA1Rb1Rm+5QyRCBcJQYqraID8UoDsxlCpmAiOVDDRlp6uWne3FjESL2vEY422iQI/JZTzEYmDH7RzopdGx7s7xH2zJ5LeEpxVY3MXODMxDkYaln1fRfCVm11BR8QY8pBcRSbJkJGxbRpD1/aDcN5sca00MHThgl1tgv5SdqeqsoGHm1FoKND0l4MVcOriqalOP02W8fH8aj6cEMq2rwkt1pgYeGTtvAiqQipZa5sZA8waAzmYNBaED04oHkxv9AgNAnkT31Y97D52oOUvQ4h4QVIz88SrkhhmUs59LooazNa72/4jAK+9BuC3mStKpjYDBfc7vGvgz+TyLpFpm3DNCQnCuCGX7kxVsYKPM2LmA616yMPEKGH4ulsRpuQ7ejYuWE/aWzEgNaPvEjwbpjCPyJcf091Oem9OJl9E8PNHOPh/5ZGpU0bC1RM6rA26wXT1v2J59KyckW5qGkmwWNLkk+cca1MXkAbfAn7Uh6GrR09h8a/m9OImvgUutnWy1I4jP/rqjieiRItIy1tqbO+qvDvn3IjKvq2BW7MjdF0ezzS560kdo8toSKGVWFNpOOa1ZfmdH3W7OjAsjUauKXAYi+J1xeG9K+ib1WTC7r1QwlsKZEHf38SfUnOcewFu6+6annZOnf/RiXGL19C0093YxSXkfY7SIV3eF8cT8llUaWAQoik/uR5XzcHEM+cVuiXyP0aCGnkHzEtaf5qL9VJIZI1sZp0JHSOuNu2q8Iu9MYnAOxXpeIZTziwK4ywzvHqRxczTf7aojMHU+JyA0O1WqaNCqvE0XgLUq1MrKKlw8spBV5Ptxm2ksVod2oGcNb7vZPC9VI=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做饭]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%81%9A%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19wHMU8VnciaDwQNl1+KJAKHk/mReUsLjRblIHB/+zzVDF9221A0z+rK+CDMtPvh0sUx7f/viLe1D8ag+yYG7yV6iLjDxxLFYX854LezYaqEnrGWt/oWfPirnMHZVQYulRBe6L3R9+XJHbkKjBOBFh387tn2IlQgv2Jm5Bm5V3Th/Nhu1WoH64tHFh5QH63qxgyUcnEHcr83xyvX8Wcacww+F4RwGfv3nWbvLQIccY+Qo9DV+ZY8U1ERMX4VtvT8xj5HlgfJVkfrEGMc7ZMBNSH7JtaXa5Ro9+yh+7g2Cp7GkZv6oX3JWrekb52pIhzJ7bvibOC++evCSoc5Tdhm5PPVwQxGyf9FaLhyAV+DyrHlk1KI4mIXDlkfoi6U3smjAPTriwF1C8winDOoZbEW0YrIaxWP+f3DVO8Y6hdED3ieuxf99ASc9kIkp9Ibii5hFSaM8pyEMA3BU6gFjqrAe2o236joD9RLRUwR19Zixi3fmB+cYwZR575uHQDS+sl9/dqBOC2su/oKf8n7GHRFvh0fu1Qx+ULyJP76cvj87XdCzVeZjPNcfKIWC5WS1UFVx8kt8ml1v3d3aS/vT/5u30uU52//qwpffzHzkKfeA78LMZUr8jcV92IOG79w4XHPhp+HQYdK2fYpvlhzwcYQ2kybA2ClMDL1q9lHvrsX/n9F6LMg5Hrkereusi6nawi8LOnTSeue59fd+4zoPE1cn42vI90EDrJyxIufzvowOP8Rpng7y+D/eKyw/Zn/BOTptNMPLlfCQtBOfwVzFAfZh8+zKx9YZWhgtI+k5txIa8KnCanwU/JF1cT]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来的自己]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19Q3ZpYvkTcD1tkIATQBfyJSiX/ngUQ2PdMPtdjXm1UFS6QzyN1/vGO7nbLjK5BKSiFLzTPkVoWxpYJ2SlRTyModR9/Dr+yk1Mi4FDslP4nCfxwxBUrSpJvjGBTgFgmSYdG70ipD6WYWbihTZNDTyCsZ6EjLmKd/yqyad2jIHMEfylv2YlDUknaH9bu4kGsg1K23TdoZJj6jXYVpHR8K+S9zAnugWlDBeLMh5XBnSYWe42rIQNsYK5bTFlreNo6hOi2lpFRR7qGM9+602QI2hmvxzWSOi9POzlo9tKqECBQ4I+HC65DDWE8d9Zg0VwWXyWJcuP9keWpmpA4CURJyUHt4i9kagUduvpngvtRATqkxveKIMmBS8cESjhuw14PcHvFDN+Ab6PvnqELHXETzUL6cneW+CVo4jXU9SGgyd8mYaDA/lM6IPQN4Sg0eRKO1OClIMyfp8OtZiH3scim4ypdJC5YtTZA+fgBPgJHAJ77JizniEnPNDQxQd92rFxFFWT+J+Eo1PZ/oHZP3QYGsfcx356kFQYw8dsfWcrvDPClFIrZ3jWAoAQKWbAynY1rOSgQp/kHUaFiIyvIlwL4hGudk9pUrrAvHdXIc9zhJtMvWpkkrxJ5gcN/uUX78s9No+ZUM1TM44SNnlQQ/6DFqZzqA/uvzbKuQqROGyHRTxWQoraxuppkcersF0CcMj6xsKjRjnyTDVO7HRGis/VFgfw4ink4SIqWp18tBdO/peBhhW5y2Vospq1wKJDHX99HdEE2BFtiCL3ge2DvbVkNHjj1XmAsmKacvh5boLytUXOkVgu8BLBqSqhrYZ7Kg0+og99OXzZ3g8cr945RUrNihNzpP5L9lEb7qN6criy4rsCUoVq6CNoSfXegM1P4XSvv+N8lhAjAkITmyzjSZ/BTxBhr4/MQPqYLqfppXiBVTI2KwR5FVABZX/OhRqmA7CocU5Po1dymzhAdentC+a8ZQyGT/OhtmrKJV4+OZgE/dT93tPGyvs2sYCMfBcx+X0l/Fqj4JdWgHpTqjmtUDeVL/dqIiGwqQFHoBx2lLiWHZGNZtQ6FRzwGpc1z9GYlr8ZEhglxat1eeU/QW3/fI+n0o7WQrqqtKY6m63ud47oyKJIzQ0x3GDf8KVa1uRwSlwN5IBV/ZTI8fnUHVbg2Ez51Ot/Rwi2zolRn9SWzwzIsWiaqrZLzAQ7/jWN9Mz1IlDF4321zS9r5jjglYcketG7MW4Lo3lozHJFdRNZgZI8Gx+xGcpZdfyC/A+pwNMjNfcpKKccFbjnz/Qx8CggqWbM8MtmclLV4+DIWcnKY9l7P+sLt6SqecmZXhIOOQ//9X+You3U+K2hWDPRf5M4crVmhBY85hsWCZwMihfK+6K0qmrJYshLBqv9YVGGGKFVfd3IlHqOhdFBPFu3VF/2ircBB+Pi6+uv1Bc6UVfgCBrHBZVp60BCr4bMHH+CPiirlfARz28F0XsFyKR+lb4KzPWsGjr8NnwP3L3mKf1Q3BVQtH42A3FjSJ87mzJniVwuIXQJAEmNPgusna4KvY7rXvEdma37aW2jY7yHBrk2JFKqqXiNM/O/dygOiDPKek0c6H5QR9JaYrfcqEEIs078dbWGjWQbM4w7z7CFxTdJYPjPmWLKLDQ1HK/InQ91ujY6xKYPTWHAXvE3c01ZSVdD4Alh3hLFmnA80o8Drz5zK4sysgHW4XeZvAX1MnGxpCNthTobec3X1OizsauzC8I9vlhXchjWWDdz2l4xR+Dh4SXywYDusWrntm+c+Jv4EqbctEmXm4B9GtE81rMG/QXORal1YWr0Jut8XTW+0ERrwrm/WtRsC4/5Xl1t3msDqd0E1s3iZlbEilRqH40+p8Qg3V2+mqHDpLzRUCZ4dL/fv98qoJ4Z6OsvxOOBkVynw0mq6n24GtDOJIiFxfwvyvPHouHpULAGIJEp6zDFnza5iOLP7RiPvoeFIPJlIxsNKstIvMJ58np1I0P3xLPURiEVfvaIXQ4ktfpyzef/RCxAvJz0LDYlle+qcysmrjplmRurSFWyYswD6NOYL5ND8GiX2M2ei5Ig0319XCJOzpZyaQQI0sT06EJC2msWsgwj6SGdqTUgF3zC7B4eGDHHF/UJ/vHi7tKIDx4PHiN4rNfCbpSh/1ZdL5tTrd1NWhfvHbvvCuOudh5374h7va0RfRiH+/hzcYT61NDvBeX/qcE6ACvPWIaATD6qJ8DsjYXxbxHX7ee68lUch1TUHtaHoJAQGFLhmNTLvHN6xHjOEgN6CwEjGplm53TgxLjI9uO48hNHOBfrei+7LOtRJM0ytiMSKUfdndCnMUQs1SYNKMPO0Fv4GlmGMAI9CJCNYQqknzsmY6BC1V5SIUmv2bDb0C6C90h7CSamxFxlQk/twWM900AvdxIMdC45vqAw0Tzp4vJ6pxm6DmuuVgiuceJLR5VqcPr1rmLdiz8h8bX/aoevOky73bY/0/Fi7db5CLgObkV6g/RdzTkSW21o+1vL7vSMIOnwM4TPU4HbPL4uSRnNInjAy6PDuv3WXVz/6rpFM7xVTdiZBzLIAjBG7k8zJ7FR0pk+Aldpjl1mZ1+IfIwJCKArDmvM39jJyJphI6pYOT/xJcnZC/NpHcYArEwRlb4iCm7phM0AegG/dTUJ2OhuHHi77Zo8Xvm30TnjwrrG4SVOANQXVsbTtz1PH/GmVpTJCn0keOZf0WgOyXlmxOMdf3+MTFPQVJHYWKew0V5XjjU31gD/uNQ8eC+yOv7uFjPgfvXsD3zhjwPv2SyXCkoJ8oZ2pK1cu/a16sq1OY2Y/I+j40VFLHoFbT2tEdGQub+3JHSjWA+IT9IFygKZvK5GmDY9aoX7bN/NXSywaFTzH9fGXLUMCpedf6vMEovwn07RAOw6VpQ2TD5kbUo/RqKoMYDGsQwI8hbT9ltv2SIrVLavttFI3ds8dKdExh8X1kU/3VNALrHMHdtGU9m/QA8JmgeuNzPjMiWmP/LyVzxrRz5+AoN3fkYkL0KShQSB1S2YC7483Pmezb6GpiOHKFymiKFJfrz5ce6qlnkN8N9xBUPkkmnDPYHsV1fg2HfHyCsJ6FAyKIcHiVqKqEguQpZV5/7D45fk3Z993Tg2wJsydGUNjvXfEP9e92adNspEvQ2tS0KHr0BFC5yIeoDkKcxd7vVTZcorODclMyfa4oRrDNA1zZdU8ftLQjHYu0TDmbPOY8Q2fMuchrcoMWoGaABkDXfdJXE24WJFSimElwaP8/s0KBUiaxhP4aS4HicAnuH3zqX5Wf1eCgkvOl37vTPL5KIBz4qLIOm8oUNVAcmrVVGBTapgiyNLAjasMbeBPeG8a3WPMJp0geX4jEmJm6FXUqud1T1gJ1BS002xVFqkyRfq1c3eybyJeSewVD2iFbcclSZDPYHpceElZ9SL8NAzg0Zh8HDiXUEXsEYLgct26wUoR8S1P+H2yLej2C7eAmcZtBR9WqeOhPWzWzeTKF3Ik6LAdZkxm9Q0EMgRA74SWcHh/EQmMpXjnKp2NpiKL+5oiXJaGa4u/nkJfdIg7PyyMi+cm2m0cEFY5NXzlxsQyMtMdueVkF1t6qIAo/9IzhgvzNDKpDXlEHkbXteAq3AKIpRlCxudo5KRzGKpGxV+H17y3e/m71xKbMV/myrVZxLmS/MdnZdpE75zdGBjeMVvuEw7k+OQVwDM9R3HONmz3udqb74vomaKzjq928rOvwg==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[姨爹]]></title>
    <url>%2F2018%2F06%2F17%2F%E5%A7%A8%E7%88%B9%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19fs4J0pCi6JknD7UlPpEg+e23Da96PhIkmMAaxXgyM5pMhyQT+0kVYVm/sfj/no+aHXiF088W4Q4ceVZp2OiQq3uNmIldt91DSP8S80mcLQcq8oyh+S8bf17Vw+yrIpuMmegXoaW/9ZY/eJlifQu5+x/HqCqkSBpQTUAUhr9JeR5qSVKlKH1LsS432zegRx7PQjJiGHj6rY2PX8rToWMc3bRSV5+ZuiBkQlbqUnv/GBbYf57tgbOjH6SxUxiEcXRLYL4OIy/TzotncSIPkFJGQwBj/mEoCSa80PI0qzAWSzI4ZqI1LHm5vnocpHhXRcfH+MjuRqgwAjg==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office online]]></title>
    <url>%2F2018%2F06%2F10%2Foffice-online%2F</url>
    <content type="text"></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.06.04]]></title>
    <url>%2F2018%2F06%2F06%2F2018-06-04%2F</url>
    <content type="text"><![CDATA[看山是山，看山不是山，看山还是山，为什么越看越伤心呢？]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天堂电影院]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%A4%A9%E5%A0%82%E7%94%B5%E5%BD%B1%E9%99%A2%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19jaGBlT8sjnSOxClxmmh027Pj3ikhtyWRbb+N8Z5BczlYjZSCU5BIAgWvKaX12eetBjnBtDMXoGpU8VLotPy4fGufTRQNNxv3605PeAyePXTRh6gvMMGkjILb9+TOw6Uxna4HA2sCeUzPNxMQNSZ/js8PV++HMaIrxNw+Xw373R4TSuLilALVhg1ZyejpAX5WaS1gcJOZ4xKCB4zrSwlm+owFehrAn6cb7UC6IyfCkKDRybJofm2VZk7oxZDMknVaWnlyMArtvar67cw9fx14vgRyIdwuliMBlN7ZcK+HwPBz29/ZyFuvJZ+6IIzdJnC8AhrS1J19ybj87OPeSWgLmRD64djq+LpV5tzGSeMIBTxIH/IeGZZ1g6Y2FKSo4P/FZUNim1kZBj+P0I+peB6YMjKBvRWloYO0=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与姐姐]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%B8%8E%E5%A7%90%E5%A7%90%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19o0lJ30zXFwyh1fq0va6Dv534EzbTSe41YANLhowgbRwmtIGXgb+4yg/hBdd9Q2g01YeXdRuCz1CEOsypuU6LMlDxtmXTG9+IlbH1RafSPSlYIh/oy8aQCKzbKAOZQ9aTDtos8/ZDUSTiyTyRE9yoE209aLy1SN77gqekDDQ6UISfApktSNqeFNSIUkvLPCH6inDNPEJPrxFFfX1KxGeMy8fSpBjZ38Q0DQ11zmDYkb0RffAwKitavqjyFWPnz13XUStmeKr8rGNcUvvCE3OEbOBaXfLudK9QHbkm6u28WxbjAGDCDFZ7nLpoQBFQwttBwi5bcDQm5VHJjgdo0jVeth50ImuosNeph7OUTLCgGxoNC7r6zjYbVDlNXCQeGDNB5v6IA+gI0jTb2p6yHWW/V0wc6JLGOMMZUpbjoaC0yNkfPR0AdslJeeZV+SmcatlIpd61dZjpAPxQLpUKT1Pg01t48PJFeO8P8JehK3sJUleZKgPlEUmiYOn+vtK09vtueSVlQ/SB65SiQv/np11evPC87XwHFmvYk85/UnloSJ+qehuIk5kF1ZBya93xdc2etKcgpZrwgRBcp97GPoiirJb9ojlfgXAHNdrcpap3/wbTSxhSXQGyxeyYACE+jpbOY8OOkWYvv7yfEthBfAYaFdaWpkLePpQfILu2zhm25JlFwhNHYPVjd2xKXOi8NhJsMwpUbqyEgMBfjGa+b4LmHsV59e1gmwr0CbiFQn1SR3Ic5pdgA7klbT8W6KgIzvv/JdNSjz1iUEorfuipezZ01cPL1W8XrVGpSMxTChX/+QOo1C5GkLsyCRseNPKcrwkeppwxCZM/KmYrpvzZqo447fisA9Vzx66PwhiKxMujbhzscbMBhq3yKlgtAGbhYbaWB6QB0CD9pcRQzMXvNWEKjpCQ8QX03hk2mFzockv2E0m4YW9BtZAfHusecVKVwqLUwjhEQF2CE3OHWLXytsijRGEexcfReE+AsDqmoJqcaNIueTuHnuCS004XAF/7c+r8P1TvSqFt4M5pZF3TfAJ9PyNtmYj7+xpnwk0gRg8ndZ0p8HluGufxxnhLdtO362ObQVIcPO0N6UFJEpXiZ3epLZsDCt6PvaA+c90QuERGYGEDmPw+52Z5hIo5OYU8neJIRcHQsR/F3i3J2B7wLB7j82A1Ji4XWuMqZLPbJGYeRrAl8gArnRXnZ5+t/tGf9/ZTLgWjT4yj2oNKcFnADIesGuw64qR+vuNQyXman3/+tjF9Jy6WNcNY/a279k42HAZgn2zHCB45wdMYf+iyHi9Q2Ui4MOSDDkey+cz5e0Sg6ZXvzx/lV0orwEd8IyxuWfhLUxwK1L+p02BFM/w3aTA+WLnyQbs9U5TfBpcIW4iNzhKLg6q1dRJIYpueEDODnCAFEdlJP75x5tnNjQ6soLhgX2cWOkxFliQ/EjXZWjEXhmAM7oILZZRE07cl0BYgdxGnVZSBZ6KFvKEIcA38C2m7CLYJJzqdljDhItdjvRK9dWAqSTIEQwTnOIuFlsX4RCZSeJsuGD6xHqJGZejSjZSXXqzBYZl5DbDjWx+/Cs0wbb3AESkn8cCpW3shj0JDnbdFMYwGn+8uLjIO87yBKbF4/cR6WDy4XQzIBf0kvy3hji9KF6DazVGisNqFvDIav2sE2DITz4bXOMiHV2VP+ZDxfmzdn/HUVNZHedq98YqamGjQnSuIXqT0FoRNUm+lNtby0pbKQdRvhSGshEA5i4GsdoTldkKtP+nJ1zaOBgAEFMuwxIOtWHiLdIvWDCuVdpzgw6kAyGKGnpLpjihQI17w0fWkAj1Nu5ePxWw/Y3NCJMxU4oUtIXvTnAXZ8LGNe1Iqu2o43livQn6rDJAdzZNa1zTKCcRLCrx0C+K2DMIuMmBm350fbcCIAJq7Q336+pOQ+Nwn3o5MmyZoDfTQoPVnFWNiP3HsNcEwVLkvvpMXoo3VXAB0drKf8tHH48h5TYXQ4JIKN7zG3hv375dDqom38KnK1NCiMkJCeOffd6HWHZg+nkhVoPreio8rsqyeThrp5H/+/hIHCSxQgz7yRwCFzDqgzGYxF/mS8ZhswJsM9D/48pTmmV+xfrKMIxNQcu4n1jZ+oCM1gQsp+Mr2pGuQbB5I03aLndVF8lLT9NhV3OMSbOXhV8cayVlvhPeL0/WDiWRNEO+3j2s+p3DRFnTAjFK6MjQeZ7JckGgGB8CzMRdxybEY3RvAOPCs1Iy5MEo7emiMwEs+ui+YZKbKuNbGhKkNKVqNcwwo1Eig6E6uuLi5NFfqcBlXn7+IMv4iKvwZRF+Y98rgWlk785uNzWZqi8w5+HqDg0eosChFNTLN/CV6g8ZwIoqmUBF325TxA+01cASBRMloawTd3Ih5dgZvpr0GB+34BVafR3Viacgk/M4sWfpTFepyOF16UMtP/ihKXhafv2m1ZGq1j3Tr921cAJiZxHND61M2j2YUZ3OGS6ao7VXvhQlst8zBnWhOjgckZDTlSS+oU3nhXdV3cUTM0tsIYkN11GFngmswEZMwosdCfxLQrAFObuNYHeTKFPTgQ2VH42Kt26SKx7C3dUam52bxZoUNbs1oLU9jUZYaIrZrwgeo3hU4NMsOBDaKl/NIigtPE9hJI+yVa6S7L2Y2CzWVkjW3BU9vK0YpN8RD/pwjdBc0xRt1SXHm+G9HLLjUS8GuiEmqA+wsvvb/XtsNaDmB4N7EBz9Qd316LIgeQ69TSqOpkJZ2oEFo15W6TElEjwE6ucqCU2nsbLy3UKmluqCt/Cz6Jl7ei6K3PLE0YmrWHuVQEDuc01RAg2rcQhAKWI/nY1WGVeuQgkzfYwyZfkw3jO46Odx4Y9mDXwt9sqVgEKPnjNwjhat4NE06X5blNhHPjqZ3sdqaMR7JgO0auBhXYrPVUcQKeuLkmvIWgXYZnfzqZH1QPyLtC/6dGZvksrdDFeGZlB2O7IErAO4OWFiqoUIVYbOwFo4NVsoAZKW6NrlN6Hc8zpaQmeaoG3IiYKh7h6DWvB5Nz19ClEAz83xG4V7JrEpjUyIfWOU2rtx7y98mY2aIWY+ZNiL+oAW2X00DaVCYRFUGR2SsdVTfAyDav8kljsC4JDSXGk9nxzTCFCM9X/ijjhCZOUc8xhuH1OGSbpT4t0VAaC54SAaUFMQg4/Oj1NHL+R7pAXCPqf9CHiD7wixqs6HraXODaAs/mkw93U3k9nAQgW/mEGpXfsPatRCDIoqAiE8fnMyHFAiFE963cpsJaANCJi8FB95n4M9ZDxzasytcoqsRi6TB2SkCxYWM5MDlWHIhbsokEBIh9KV2P1zO9y+IueFaj27v/x5mREYLrstrN2815TcAma9A/QPAsmKa3wShMyV2k6p+3VlekhgS9b+9nU1De23JVauNDIqwrgTUQY+WpNRHYTrjqE/tKugTG2FqhCSGh/3Y30V4lXTIFAGrrBX+3ylU5vnBHOev4y7W9n9184N8z9Qt932pUvlBqBB0fKN23VDQXgqI7mZCIWkf8sPXGLVj3W7BC6NfAIf/cok5tUJIaYJjVkQPuJAZJ7UcXoPT/tiQGWFIGFsgkxsw7byr9AQFDdNO1R0mKp3wCv8DkRrseFDZr5i+zHtLwXQdRp2OAjTY3/rrfuy5suJPdHOdQjILI8oxjCcuyOFoSOUqNIqJ2NVgH/yr7rggCvTLA64rhof4ZVGU4/bu4Xnp6BbNlkYWIxwRt+NaIEHiVGS3hmpefYtxAG0Wifs3dam/Qy/CsHCxUfQrFwn6Ef9V3G0tkQWCH9rlQAxGwyNbfAgYFclJICJfRPLH069izXF27/cXTzCbbWgOKuMVDGt6G9i6f96hTYc6cT8z9Xag+ASXLUrtBtVY67nQteAhPXi6XP+SQEW2nALfIt+9vMg2IBJWtB3z6IoF2Eg3AY7XWovvPHveP8UXqRBNFHaSD7O4FHEjPPfwnmXEWk0OofMuNCLh+7qyPNHX12QIecRCGNBRiAEs3TDNaxwSvMvzBrN9QpfOQczAkgJBL+dCeya5en8oFyxvzL5S3+xbsKegRibSLxViSt2vn2cD7Dq5Nc2SCifFd7zxOSiGmnsQIPRVYdOXg2vhld/Qa8lRm0/NIdFbP+Hhr8da17w58nX+FmrbmfW8Rl4UlHFxC/3Ebm9gBkHOlI7+Y4tOlvmKvImWf6WblGdPbT2GeJe1Egt60sMXNSfZnD3MHPwEFDuIKeT9nLACbMVuSFpVikl1h2TL5i51zgU9tE2gtm1alORSdRCnoleVmmGVXALUvVdkcLzK6J6bHY3D7CBbcril3DeHp/nc61nPO/Ql+G34Ll8Qkzg1VhoaV4twJS/xemuedLkGk0sEWLqJQbrgwslB0u6OK8XeQtSD0h2DcjjuR31Y55yUPr/62YS7mAylWCtLJ25pNidzdLklY5zncuHiVPDYYPVtn5SsqIJAk+4TWalyyvANxSjiM9a3qVbKhA344q89yYM42MTNrSRcnVVFaWzRRBe73zsoDd13UPTuFo3TYn5CTZhO+lhGuhhOO6FXK3w3otQ24WWq01M8FEN4tksmSz3bZBP1Z9KGTCKjxPtvYWgRcIMKd/F25GcvLoHMQxTZnVUb1/TtMhOMo+ei0IPlDzXXy++5jImKIZVkeIr0EbovNyGZ2JsPe8303rIOdEvrCaGHBoW99tpd/aTxc5dJ7yZZ8eCwbwX7IZI9JaMwpBQ8H94IK5xLWshHaehnBDN7qLqj/RfC0qBC/nydoLLP6e0+0TKcpfTUHOmM0LcUzWNm1uHqkx9x7GaR648QIVlqZ4+YL25uynQWtshiIN1mxnGhJfLz40Z9aTwlgew95elq89sGz4w2hQRD7mKaBqUgRgUlLFEyotulL0q1yeSK8g+UTSqzLAztBj2Bn8X3Yl7nfv3GaneObu/vY2O3hs8PoFSLapddW6CUosq6RfUVe0mrlIBKs5DTdJngtLXVqFq6aSHKdve+7s0g1uZ60v3xd9ACz74b0dLFS5E3LM46ku1Q4dvqjs4KHqowBpKAiQZnWBplGLlGcRqKOM02kjkxAStiB0aOOdxy4c7wQ305H6X691+Ne0ZwQOWEImuV4kujnS4v4zYmZmxzi4DJJeBkweKhd7i++FPq0VejQqx0u6r1ke/+eOI6bWiV7H1MbsnpZO6YywHBiYuUeLRmMmApz+uUtAEZ7xylt5KJ9cddsk25rPtUPOS37bM8kOTVF6CnRCBXgJHE8uzeZpxbv+0RfqLtpbQzk7PtdSYVn96shRgXFU/YXMaF6bk3+1rkXVqaFYj1B+ndBQz146LgNrweBU3iuI3PyFCCvs6PwUpYup+HZLj60Evf04naVx9/OCUSyoSmzvSNl2H1no+AaE6t8xVdEoeSoqnBZXjAsMc50nSPo4tI+Z1302ZpS/SrdKrYWKh3QaqEkz9DdSGr+vANhJcqU8YzAuXIfcydTCzMkjheIsGgedJDZxMn7cH2qY/5jUMIMHXkedt/J3SzrB+DUvgdDkhZZMZ9u0VPQS5mM1LnPg25SJhILPDEKKwzkMghkszEgoPSJZd7rMN/fh6QR4X2alXQLbIhKnGSeNEIZ0kJ30Ob9Sibxgd0inI21mLLhUl2xAZVThJxucwSWd9bxWQ6xMx7Xp8mgO2K0rMiZ3ZpKaY45ljKbMTlIZG2am1o9T2dNuKx+std/GLfjFqNEF87h8MhPUsTiUMx5PY1181G8pDSh/ElzBM+UY4Ut2Umw13Sy8U2gGZGQu9TZrsEDp0l31GJR8fcJUkwErGOV8e6e5GZ/GTme5erFTcBOEpZBjdCl91GwjCV6rYwJJIGo5v2jqXcvt3Rp17meIgAN6GxtkSRI+LXVwi1ho6Sg1tO55nXNcQCSObrgb2iHiA8vzW08T16VJPSQqX9B2sj2W2JPZsB2/eopbgRKy13G/pR32SnfSNFMBwiAloFB0SuVHPAJ/CLkvKmE7yJL+dWuP5e8SdmlfMdhmiw5kyYeUAFikuKl3XIQK7r6Mf25aYCUIPnuVtCD4m+4URBG7c/yLglNJOwMccoE918lhvDzR6WsGdjLtZraw6g1j+wOZfsmHacP+CLgY9mgkV3BPovIvXcg79SIJalyj+c9ejxEYWTTz496Eslqbsx5qr1wVMcw2QItof1IMTEbdE+M8T+m1urVfyTG3xX7DK8oWKm9+H5BGCbzkGGjKYyVkKWbE/8sYTwy57qGBQmy9iLWDhvVovM8BP0Z6n8KjoZyobHXp2pJIzSi/gZHPJUVT7aM7y0GCVLqIJsHna4GS23R5w1wICfvUcUPPSQfIBrC9lzkjrln1YM9aedk+gJdB9NaHKrnzGQmuqrNi96LBCR9vFxK66i6ZZaThe0NtyGKFsJcSSlP2XBLT56Nq1xdtmp4cU/nEUgkuGTfKVRhrRfuI3Jvds+Ia17hEIzyP0RCCGaRh1e3Z0/83SsWBxEDNJBJMyx+iBkh3f8tfOG289BEFZb6RmQmp2YyqIUHwZOhNlCwh0m7XLPTXbdW32V+G37aD7QmsBDGGZO3q+Vm6q32xoFD/RgR2XLXYBYs03npXSa8DXJoPHFUIWGTWnrtjquyeb+9dpYrHe4KrzIsPlA49fgdRdSFaXMQOPgub7D6OPZNZRkw6nvIoODIyo3dESFQfz19fsRe0DHTAqqdS+WYtd1/znnYpw58hwNEjrN3FWY/7cP4GNDydEGZHPhFE0mzDN72pd9YB9nxkrwwLRYPAJZXes5ajhEwhsyVVCVZ3Rl/kf0e6JYmeyAOp5cOyDuj7kvwUo79dxQe1Xs4qmNaM5B+zGaTG/1yDuDKHLc29NfWzHel+r2w/VYxfREjBoBapOHsOzAn4RnwXS4rVYSHosmMuNWiuZ1Mpbe/v25w24AuEtAa6uZ2J4bz/vcA1aWWoW0U+NMVkIDvf9i+nxqhbWB1r2Os0+L4MGSqm7H3u515RzOc+7i7jZSVxbiaWSQFilOW4UJ7cTmb8Rf81pojcVe2B05kj5tnMX/xsTRwLTYgQ9Xg57mnZ8nIqwYvyMTZd1EwYpJAyyxRJmfY7bLXwgykXH503Uh+91esKuv7I7xUOgSI1T55VcyWSOsQVda4rChQDfed4P9n7s/a623cMS4vhguI/cpUjMROw1jaMSs49r0yngTXed+0xuv89hyXm1S89hg0UJoVpzcuqAMk5scXQd5QW7H/KT9RrrXkXuVS1sDl+qZWaMcZQDQ2/M5C0RKK1ZhtpaQU3eRARGXP+2Mq+jcWHeGp+NnLSNCh609iALGyopWR9DuPwAnhUk/H5j/E7PTJMEE/9EDxDstkYRDQ+FY+5X6DtftBy3X9PxmzciWnMkJcniBFEhpqhP/Qw8E2FV6n8nKia9vlSidn87qltzyxb30XUk4VLv7/raz4NQnvyYAZw6BYZe9Z5qYpO8uIrmb2BbKfRESTf8dpfFgUU4rRi4J34IGO78UYJPVVfZm7dSkYTKdkOZt1g1XGbVjNtnZeB5k4VpdQVFL6ejU0n1PvLCP73Pzh4OhmYyus4tZIimmthUOkOu81IGdBU91KXH0cOrMiasyKx8eBPkmtlL92zVSz8n8i6YziV/NGthhzDtAKkjj2mF6IfFwmY0rA4nc42BwqbKvbg4g0eU31Z4BU5849fK1yNUkP9x36evFxEV4mpCSI99FyG0fID2dzbXDtXBZdMqW/fS6hQhMZfNyo05LGtGjyLp3ad7VZOXEOR7+5khYEi+y1B4gcTEfNeKMO5LAhPmkE+/Y6dbd2Y10SuWrm3B2VyAyGGZMQvrdRfOpUuykRdrUTMp99HQDKS6oLL3pVoiOvmQeGJD6aoMs2reNZ8chGf7eo8SfDbTIoXbZG5oFIYL5joUuvuw8xIsPI7EMk1k6qDolsjxq1HvT1ezvSqHUIsnViwhAUf+A2PnY8nk2Llf5rVxuXv3GAzr2ZvBAZnM2zedSPYmGJxJZi8SVQJ0I3l5xZDBZPy3M+L1jV8aIOtY/Fw4QOJ1x1bbswB3RDa8Q2sx1RlnEkjkANL2JJrYDqFW6U94bieaisZza4OBYSI7F2WzHoJtGRWkjA+IJP7geYgenQjV4IhpUr/64gsL5bpOHCeJuE/yYyDjfewJOWrIrW2NXDHOsV+5aQQV+2/5T+up7VKdwGsx02VsVrpTvDlypKvMRjRJKNHhBN9YGe1YU3En957fGp8DAzCrHY/FoUNPKKjbgMp1127sL4S6E12jDJCPgCu+cTHJwsKZJLIohAHeURvwt1QGvs/7bp3526tsQyx4xyDrOsKy4Gy0M70BwdGthczRabQNF8aMwb58MU8lPPeMsd4Kft8HsaCTg9W4p+bxsh7cfrohKzJ7QpV8pQjU2b2YmFWzZqGnVYlayZf20m3QJbEYFcY52+TrSu2Vg1aeQTAf3zYrOuAncmxJmPL7dTB7m/wN0VFbDQA9SyfIyxj2TKW02l5zoJLREKR43m9K3PoirG9oqOazZ4ykQW7HCUGCx29+oMJPGiEU7L6KVKWiCRYN6aJBOTh9g5eJR4rE9M7/kFTLTkxMyFHY+ngVpD8YoYH2/dTqDOTzxtBxxNIDv82Q0e3C4UG43IIx9/Nbbg3zSPp7NdO6zHl8UgC/kR9tVQPRZrXXK8r9WCmcOC]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交流]]></title>
    <url>%2F2018%2F05%2F04%2F%E4%BA%A4%E6%B5%81%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+e4HdaK4zDbPi5zCdvnteicihduD8Dj9+/yquCK7J7xVoPOoNzkuXwtTeF4rRyiZ1nRxhgpIfY7yE+iEamnFom80FrYrj0lb5JiMEVHzTUH4+zupwl5QCm3DVyXqmYOkBBHBKJU7b3UQl/f3uKDsxEqJxFGNpJMKhPSEtPQfc26HLeV714MTDe+QtafdGxCopem0kiBhDwBlqKcSFQcKYYJfMBJDz6c1oiH2ZohY9DZBEJjSauZqcRoFmQvWgTp2OBb/qowDTdA7gYUpwZx4jwOYdX21pQxvedw9BstOAV3kvZ/ykseiNSnxlFeKs+Z4eRR2l7xwSeTefBXFLG/M9204ZB9o1424aujQODkIswh5a1k1ylg/O/0O8byRvAnUQpLfuHhtS+INEk4NDWLJ443GX352RS3byFeWsEel/Y14UnpFHbH9NHDeWOKUio1z4K4qrjvGwnEg==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.23]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-23%2F</url>
    <content type="text"><![CDATA[过了一会，青年人把右臂举起，把手抚上石碑，开口了： “法师认为，是法源寺的名字好呢，还是悯忠寺好？” 和尚对突如其来的问话，没有任何惊异。顺口就答了： “从对人的意义说，是法源寺好；从对鬼的意义说，是悯忠寺好；从对出家人的意义说，两个都好。” 青年人会心地一笑，法师也笑着。 “我觉得还是悯忠寺好，因为人早晚都要变成鬼。” “寺庙的用意并不完全为了超度死者，也是为了觉悟生者。” “但是悯忠寺盖的时候，却是为了超度死者。” “超度死者的目的，除了为了死者以外，也为了生者。唐太宗当年把阵亡的两千人，都埋在一起，又盖这座悯忠寺以慰亡魂，也未尝不是给生者看。”“对唐太宗说来，唐太宗杀了他弟弟元吉，又霸占了弟媳妇杨氏。后来，他把弟弟追封为巢刺王，把杨氏封为巢刺王妃。最妙的是，他把他跟弟媳妇奸生的儿子出继给死去的弟弟，而弟弟的五个儿子，却统统被他杀掉。照法师说来，这也是以慰亡魂，给生者看？” “也不能说不是。”和尚不以为奇。“在中国帝王中，像有唐太宗那么多优点的人很少，唐太宗许多优点都考第一，当然他也有考第一的缺点，他在父子兄弟之间，惭德太多。有些是逼得不做不行；有些却不该做他做了。做过以后，他的优点又来收场，我认为他在事情过后，收场收得意味很深。盖这悯忠寺，就是证明。他肯盖这悯忠寺，在我们出家人看来，是种善因。” “会不会是一种伪善？” “判定善的真伪，要从他的做出来的看。做出来的是善，我们就与人为善，认为那是善；如果他没做，只是他想去行善。说去行善，就都不算。我认为唐太宗做了，不管是后悔后做了、还是忏悔后做了、还是为了女人寡妇做了、还是为了收揽民心做了，不管是什么理由，他做了。你就很难说他是伪善。只能说他动机复杂、纯度不够而已。” “我所了解的善，跟法师不一样。谈到一个人的善，要追问到他本来的心迹，要看他心迹是不是为善。存心善，才算善，哪怕是转出恶果，仍旧无损于他的善行；相反的，存心恶，便算恶，尽管转出善果，仍旧不能不说是伪善；进一步说，不但存心恶如此，就便是存心不恶，但并没存心为善，转出善果，也不能说是善行；更进一步说，存心不善不恶，但若有心为善，转出的善果，也是不值得称道的，这就是俗话所说的‘有心为善，虽善不赏；无心为恶，虽恶不罚’。上面所说，重点是根本这个人要存心善，善是自然而然自内发出，而不是有心为善，有心为善是有目的的，跟善的本质有冲突，善的本质是没有别的目的的，善本身就是目的。至于无心为善，更不足道，只是碰巧有了善果而已，但比起存心为恶却反转出善果来的，当然也高明很多。天下最荒谬的事莫过于存心为恶，反而转出善果，这个作恶的人，反倒因此受人崇拜歌颂，这太不公道了！所以，唐太宗所作所为，是一种伪善。” “刚才我说过，判定善的真伪，要从一个人做出来的看，而不是想出来的说出来的看。这个标准，也许不理想，可是它很客观。你口口声声要问一个人本来的心迹，你悬格太高了，人是多么复杂的动物，他的心迹又多么复杂，人的心迹，不是那么单纯的，也不是非善即恶的，事实上，它是善恶混合的、善恶共处的，有好的、有坏的、有明的、有暗的、有高的、有低的、有为人的、有为我的。而这些好坏明暗高低人我的对立，在一个人心迹里，也不一定是对立状态，而是混成一团状态，连他自己也弄不太清楚。心迹既是这么不可捉摸的抽象标准，你怎么能用这种标准来评定他存心善、还是存心不善不恶、还是存心恶、还是有心为善呢？心迹状态是一团乱麻，是他本人和别人都难分得一清二楚的啊。所以，我的办法是回过头来，以做出来的做标准，来知人论世、来以实践检验真理。我的标准也许比较宽，宽得把你所指的存心善以外的三类——就是存心不善不恶、有心为善、甚至是存心恶的三类都包括进去了，只要这四类都有善行表现出来，不管是有意的无意的好意的恶意的，只要有善行，一律加以肯定。所以我才说，唐太宗肯盖这个悯忠寺，是种善因。” “法师真是佛心，喜欢与人为善，到了这样从宽录取的程度。” “宽是宽了一点，但也不是不讲究分寸。像我说唐太宗盖这个悯忠寺，是种善因，并不是做善行，这就是分寸。” “照法师这么说来，盖了这么个大庙都不算是善行，只算是善因，那么怎么才算是善行？” “这要看对谁来说。如果某甲有一两黄金，他出九钱盖庙，哪怕只能盖一砖一瓦，这是善行；如果某乙有十万两黄金，他出一千两盖了整个的庙，他的善行，比起来像善因，很难算是善行。” “所以唐太宗不算？” “唐太宗身为皇帝，当然不止是十万两的某乙，他盖悯忠寺，不能算是善行。何况，他有权力根本就不使盖悯忠寺的理由发生，那就是何必出兵打高丽？不打高丽，就不会死人，就无忠可悯，所以，唐太宗如根本不打高丽，那才算是他的善行。” “照法师这个因人而异的标准，我发现法师悬的格，简直比我还高。唐朝当时受到四边民族的压力，唐太宗不动手打别人，别人大了，就会打他，如今你法师竟用的是人类和平的标准、不杀不伐的佛教标准，来要求一个十九岁起兵、二十四岁灭群雄、二十九岁就君临天下的大人物，法师未免太苛求了。” “你说的不无道理，我悬格太高了。可是，大人物犯的错，都是大错。唐太宗若不是大人物，我也不会这么苛求了。因为，从历史上看，当时高丽并没有威胁到唐朝，高丽虽然欺负它南边的新罗，但对唐朝，还受唐朝的封、还对唐朝入贡，唐太宗打它没成功，盖悯忠寺回来，第二年高丽还遣使来谢罪、还送了唐太宗两个高丽美人。这些行为，都说明了你说的唐太宗不动手打别人，别人大了，就会打他的威胁性，至少对高丽来说，是担心得太过分。我认为唐太宗打高丽，主要的原因是他的‘天可汗’思想作祟，要君临天下，当然也就谈不到爱和平了。我承认，要求唐太宗那样雄才大略的皇帝不走武力征服别人的路线，那反倒不近人情了。” “这么说来，法师还是肯定唐太宗了？” “当然肯定，任何人做出来的善我都肯定，而不以人废善。至于想去行善、说去行善，那只是一念之善，并没有行，那是不算的。善和行善是两回事，善不行，不算是善。” “法师这样注意行、注意做、注意以实践检验真理，这种思想，跟孟子以至王阳明的，完全不一样。” “是不一样。孟子认为发善情就是善，所谓‘乃若其情，则可以谓善矣’；王阳明认为在内心就是善，所谓‘至善只是此心纯乎天理之极便是’，这些抽象的检定善的标准，我是不承认的。善必须要行，藏在心里是不行的。” “法师这种见解，我听了很奇怪，太不唯心了，佛教是讲唯心的。”青年人露出一点取笑的神气。 和尚好像有一点为难，想了一下，最后说： “真正的唯心是破除我执，释迦牟尼与何罗逻仙人辩道时说：‘若能除我及我执，一切尽舍，是名真解脱。’我执就是主观的心，善如果没行出来，只凭主观的心认为已经是善就善了，这是唯心的魔道，不是唯心的正道。唯心的正道是破除这种凭想凭说就算行了善的魔道。真正的唯心在告诉人什么是唯心的限度、什么是光凭唯心做不到的。比如说吃饭，必须吃，想吃和说吃并不算吃，一定要有吃的行为；善也是这类性质，善要有行为，没有行为的善才真是伪善。” “法师这一番话，我很佩服。只是最后免不掉有点奇怪，奇怪这些话，不像是一般佛门弟子的口气、不像是出家人的口气。我说这话，是佩服，不是挖苦，请法师别见怪。” 和尚笑起来，又合十为礼。然后伸出右手，向庙门外面指一指： “现在北京城都在过年，大年初二，外面正在赶热闹，而你这位年轻朋友居然有这么大的定力，不怕寂寞，一个人，到这冷清清的千年老庙来研究古碑龟趺，一看就不是凡品。” ——《北京法源寺》]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.20]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-20%2F</url>
    <content type="text"><![CDATA[我试着远离、忘记高中，也试着找回]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.08]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[Talk is cheap,show me code]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.06]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[人生不是百米赛跑，而是长途接力赛]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.05]]></title>
    <url>%2F2018%2F03%2F25%2F2018.03.05%2F</url>
    <content type="text"><![CDATA[软则柔，刚则折，刚柔并济，方圆之道]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学长考研]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%AD%A6%E9%95%BF%E8%80%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX19mofNxvG91hgZSRcP5G+5JdX7QjEoYU78R16/OQjDu5Ji/+RWJAh/ROdu/nWIaT2cuT6YW/UGdmQebvHGm2VNFU6jgoFhFbiqhVLg1/bQsmQ0QZT29a8Fy9T915vE0adKtF+YzWYw2xwaudf72K4Bu2GRk1dN0dcB0EPA6H5SOPt3c8/q2WU3rSvvd99EjFI8GD1N6IEUiesLZrwBUs72eI+gQGE4j/fdbGePED3s2COiLqHV5tA9KPELo3x4rBMR5xqiE6sw3pHwN1RNfUIMYH40iL9ASAOPaiuIa+LFL4Ot0fO5QS++lm4maTKVP7iN2yFJo+9B96F687X8v3EWmIAFA3VY0m8JY77VXuzbBa82DEzN1lDws35Y5drVzkcHG2vAYTwPU/53X+bFKDkaSQtm32AhNgpLbGGaYM4RhHTbp8qiHEqGtT0CBm21FIE1RNOvqLXIJSsAbKCbTXvZREYyQeOY+gb1nIWk9oM7mc1nX4mqhasfRMTjlDEge/41ecRGHMurrFJTOJ7F9wlOP0O+E1oftISGAV2BYYFZt79tVGJ9MU8BrKwR/AgPYGinHQd7AvxOwUlQKTfrbX6e1IMj5FvY8fwn4/POa/hPeEmiwCOtZuDs92z2e3K9y6e+bchNX5yfyedMiR8NSnGtVXvdmuMT211g+qQbpUe1rnaiPJcjDqsjZcNZMe3qMVvQfwEez09BFkcPnU/j04ZqnBTyOFTzcjBz44szIlZTjmQEEVbwk8qbAW6r9GVp/xWe+f5oZar556kshVsE+dZmkjCjvqVBW/CemzrlQQeLqtWoSeHdpdo/x628EiUqu+I9XzAhjdn4aBZQSkkEw1xWfyP8O1AyJi6bdHKy45v7FLnY+LzCLZP1l]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[途中加油]]></title>
    <url>%2F2018%2F03%2F25%2F%E9%80%94%E4%B8%AD%E5%8A%A0%E6%B2%B9%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[担子]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%8B%85%E5%AD%90%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+kAicpkWCu1oZf9lJ+Pn1k8+3AfUYAr9WEjNLKtjVqJ7D0hxGxzYwQ3s60UBcmbkRNCSr5u3EDNAOQr3aixI6lnnUA/rkpJRNAB/Mg0w/SI+XwFKtEJx+xxXxA8k8N5CuTm+gm7+9Id1TMq9iVMy1y+MJZ/W8Q6Rl2ashrEDpw+ctidp2lniXpFecwOi5lXsBW3aAl0nuEX0sPivA4l12Z7C3dwyCU7Qns3YtwLpJsQ4MlfCzOisOWY1+4Qz//+2UNoHRlOA9IuZCGSBI7HDC6hKoIikncAd50TLQQdiNMCqDCHfCAY6OGlmbsHB5dYcpFGVNkbvpQUbnbeybUkO+TE2gQuCOnsCXyI/Usk+0xSt8Wfd5C8qigKXhhGLxh5ZFqjEM0frsK93k2PgC1Pl7uGr9C11W5YNI=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出node读书笔记]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ES6]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%AD%A6%E4%B9%A0ES6%2F</url>
    <content type="text"><![CDATA[兼容性 ES6(ES2015)——IE10+ Chrome FireFox 移动端 Node.js 如何兼容老版本？(编译、转译) 1、在线转换(用户每次打开页面需重新转换，费时) 在线转换有很多工具，在这里以babel为例，在线转换只需要在加上browser.js就行，如下： 12345&lt;head&gt;...省略&lt;script src="browser.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="type/babel"&gt;&lt;/head&gt; 2、提前编译(babel/browser.js) ES6变化内容 1、变量 2、箭头函数 3、函数的参数 4、数组方法 5、字符串 6、Promise(串行化的数据请求、异步交互) 7、generator(将同步操作拆为异步操作) 8、JSON 9、面向对象 10、解构赋值 1、变量var存在的问题 可重复声明 123int a = 12;int a = 5;console.log(a); //5 无法限制修改也可以说无常量，会导致数据变动，出现问题但程序无报错。 无块级作用域var是函数作用域，导致块外面也可访问块内的数据。 1234&#123; var a = 3;&#125;console.log(a); //3 let、const性质 不可重复声明 123let a = 5;let a = 3;//报错，不可重复声明 123const a = 5;const a = 3;//报错，不可重复声明 123let a = 5;const a = 3;//报错，不可重复声明 let-变量，const-常量 123let a = 5;a =3;console.log(a); //3 块级作用域有什么用？ 经典问题： 123for(var i = 0; i &lt; 5; i++)&#123; console.log(i); //5,5,5,5,5&#125; 原始解决方法 用函数包起来——闭包 12345for (var i = 0; i&lt; 5; i++)&#123; (function (i)&#123; console.log(i); &#125;)(i); //0,1,2,3,4&#125; let解决 123for(let i = 0; i &lt; 5; i++)&#123; console.log(i); //0,1,2,3,4&#125; 2、箭头函数(方便) 区别 1234567//ES5function show()&#123; //...&#125;//ES6() =&gt; &#123;&#125; 1234567//ES5let show = function show(a,b)&#123; //...&#125;//ES6let show = (a,b) =&gt; &#123;&#125; 要点 如果只有一个参数，可省略() 如果只有一个return，可省略{} 以下例子，可说明两要点 12345678910111213141516171819202122 //ES5 let show = function(a)&#123; return a*2; &#125; //简写 let show = a =&gt; &#123; retuen a*2; &#125; //进一步简写 let show = a =&gt; a*2; ``` # # 7、generator(生成器)### 概念* 普通函数——一路到底 function show(){ alert(‘a’); alert(‘b’);} show()12* generator——中间能暂停(踹一脚走一步) function *show(){ alert(‘a’); yield; //放弃 alert(&apos;b&apos;); } let genObj = show(); genObj.next(); // agenObj.next(); // b12* generator原理 //以上一段代码为例function show_1(){ alert(‘a’);} function show_2(){ alert(‘b’);} genObj.next(); // show_1genObj.next(); // show_2123456789101112131415161718192021* yield* 应用场景 请求数据# 8、Json* 1、JSON对象 + JSON.stringify + Json.parse * 2、简写 + 名字一样 ```javascript let a = 2; let b = 5; let json = &#123;a, b, c: 6&#125;; //&#123;2,5,6&#125; 方法 1234567show function()&#123; //&#125;show ()&#123; //&#125; 3、json的标准写法 1.只能用双引号 2.所有名字都必须用引号包起来 {a: 12, b: 15} × {‘a’: 12, ‘b’: 15} × {“a”: 12, “b”: 15} √ 9、面向对象应用——React React特点 1、组件化2、强依赖于JSX=babel=browser.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;学习react-组件&lt;/title&gt; &lt;script src="react.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="react-dom.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="browser.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; class Item extends React.Component( constructor(...args)&#123; super(...args); &#125; render()&#123; return &lt;li&gt;&#123;this.props.str&#125;&lt;/li&gt;; &#125; ) class List extends React.Component( constructor(params) &#123; super(params); &#125; render()&#123; // let aItems=[]; // for(let i = 0; i &lt; this.props.arr.length; i++)&#123; // aItems.push(&lt;Item str = &#123;this.props.arr[i]&lt;/Item&gt;&#125;&gt;); // &#125; return &lt;ul&gt; &#123;this.props.arr.map(a =&gt; &lt;Item str = &#123;a&#125;&gt;&lt;/Item&gt;)&#125; &lt;/ul&gt;; &#125; ) window.onload = function()&#123; let oDiv = docum ent.getElementById('div1'); ReactDom.render( &lt;List arr=&#123;['123','abc','bxsa']&#125;&gt;&lt;/List&gt;, oDiv ); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次网站解析]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%AB%99%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言今天记起要选公选课，同学安利一个教务处app，打开一看发现界面和功能都挺不错的，突然有做教务处微信小程序版本的想法，第一想法就是去找官网api，可转眼一想，哪来的api？原作者说网站解析来的，于是开始第一次抓包过程。 1、去长大官网溜了一圈首先来到官网看了下 1.1、登录前 教务处登录页面 发送请求中的header 1.2、登陆后 1.3、测试 postman测试 一开始想到把请求数据拿到，再伪造不就行了吗？至于怎么发送、接受数据，后面再说嘛…结果转眼一想，这还有验证码，难道要把验证码都转发给客户端？我看到的教务处app中用户名和密码都是学号，不科学啊，难道他找到漏洞，把学校教务处数据爬下来了？我转向解析app 2、解析app app发送到服务器的数据 从截图中Request PostData这一栏中可以看到发送的数据，这个username(学号)没加密，password(密码)加密了，由于学号就是用户名和密码，我试着把密码用md5方法编码、URL编/解码…等一系列还有我没见过的编/解码方法，结果都不与password/原密码匹配，我猜应该加入了干扰字符吧，寻找编码方法失败。 但可以看到是发送到http://221.233.24.23/eams/login.action,就去这个网址看看。 3、 教学管理系统溜一圈3.1、登录前访问这个地址，有登录界面，这张图片是以错误的用户名密码登录时浏览器发送的数据 以错误的用户名密码登录时浏览器发送的数据 username是明文发送，password则加密了，可以看到也是发送了4个参数，这和app发送的请求参数相同，说明那个教务处app就是发送请求到这个教学管理系统的 3.2、登陆后 以正确的用户名密码登录时浏览器发送的数据 这里图片无法显示，图片内容就是与上一个图片内容类似，但就是没有post data，这是什么？没见过啊，为什么登陆成功不发送数据，登录错误还可以显示数据 留一个坑，不理解3.3、测试 结语]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎jade与ejs的区别与重点]]></title>
    <url>%2F2018%2F02%2F27%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8Ejade%E4%B8%8Eejs%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、模板引擎 //TODO 二、jade1、认识jade //TODO 2、基础语法2.1、根据缩进划分层级2.2、属性用()表示，用逗号分割 *style = [] *class = [] 2.3、内容123div xxx span xxx a(href="xxx")链接 2.4、渲染 jade.render(‘字符串’); jdde.renderFile(‘模板文件名’, 参数); 3、高级用法3.1原样输出123456789101112//1.jadehtml head body zaizi //转为对应html&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;zaizi&gt;&lt;/zaizi&gt; &lt;/body&gt; 从上面代码可以看出，原意是body的内容为zaizi，但实际转译把zaizi作为自定义标签。如何在标签里原样显示内容呢？如下: 加竖线|,原样输出 12345678910//1.jadehtml head body |zaizi //转为对应html&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;zaizi&lt;/body&gt; 此语法可用于在html代码中写js，例子： 12345678html head script | //js代码 | //js代码 body |zaizi |dog 以上情况满足写在html中js的需求，但每一行都需要加|，还是比较麻烦，更简单的方法是：在script后面加一个点.，例子： 在标签后加一个点.表示标签后的内容都原样输出 12345html head script. // js代码 body 若要文件结构更清楚，可以尝试引用外部js文件，但会增加http请求数，这里可以采用include，例子： include引用文件 12345html head script. include a.js body 3.2 使用变量12345678910111213141516171819//jade代码html head body div 我的名字: #&#123;name&#125; //js代码const jade = require('jade');const.log(jade.renderFile('`jade文件地址`', &#123;pretty: true, name: 'zaizi'&#125;));//编译效果&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;我的名字: zaizi&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>jade</tag>
        <tag>ejs</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析Promise内部结构]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%89%96%E6%9E%90Promise%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 阅读本文需要对promise有一定了解，可阅读详解promise Promise标准解读 1.只有一个then方法，没有catch，race，all等方法，甚至没有构造函数 Promise标准中仅指定了Promise对象的`then`方法的行为，其他常见的方法/函数都没有指定，包括`catch`，`race`，`all`等常用方法，甚至也没有指定该乳环构造一个Promise对象，而且`then`也没有一般实现中(Q,$q等)所支持的第三个参数，一般成为onProgress 2.then方法返回一个新的Promise Promise的`then`方法返回一个新的Promise，而不是返回this，此处下文会有更多解释 12promise2 = promise1.then(alert);promise2 != promise1 //true 3.不同Promise的实现需要可以相互调用(interoperable) 4.Promise的初始状态为pending，它可以由此状态转换为fulfilled(也叫resolved)或者rejected，一旦状态确定，就不可以再转换为其他状态，状态确定的过程成为settle 5.更具体的标准 一步一步实现一个Promise 一步一步实现一个Promise 构造函数标准中并没由指定如何构造一个Promise对象，在此以实现Promise的通用方法来构造一个Promise对象，即ES6原生Promise里所使用的方法: 1234567//Promise构造函数接收一个executor函数，execuyor函数执行完同步或者异步操作后，调用它的两个参数resolve和rejectvar promise = new Promise(function(resolve, reject) &#123; /* 如果操作成功，调用resolve并传入value 如果操作失败，调用reject并传入reason */&#125;); 先实现构造函数的框架： 123456789function Promise(executor) &#123; var self = this; self.status = 'pending'; //Promise当前的状态 self.data = undefined; //Promise的值 self.onResolvedCallback = []; //Promise resolve时的回调函数 self.onRejectedCallback = []; //Promise reject时的回调函数 executor(resolve, reject); //执行executor并传入相应的参数&#125; 上面代码基本实现了Promise构造函数的主体，但还是有两个问题： 1.我们给executor函数传了两个参数：resolve和reject，这两个参数尚未定义 2.executor也有可能出错(throw)，此时，Promise应该被其throw出的值reject： 123new Promise(function(resolve, reject) &#123; throw 2;&#125;) 所以我们需要在构造函数里定义resolve和reject这两个函数： 12345678910111213141516171819202122function Promise(executor) &#123; var self = this; var self = this self.status = 'pending' // Promise当前的状态 self.data = undefined // Promise的值 self.onResolvedCallback = [] // Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面 self.onRejectedCallback = [] // Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面 function resolve(value) &#123; // TODO &#125; function reject(reson) &#123; // TODO &#125; try &#123; //try/catch捕捉错误 executor(resolve, reject); //执行executor &#125; catch(e) &#123; reject(e); &#125;&#125; 原文]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文置顶测试]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用方法在文章中添加top值，数值越大文章越靠前，如：12345title: 博文置顶测试date: 2018-02-25 17:09:16tags: [测试,博客]categories: 博客说明top: 3]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章密码测试]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%96%87%E7%AB%A0%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+ah4mFu4UcNbrTRpG9Yw+t4lcbFCtjgTl90hcqZ3nyNAp081PyOW0Z1DQ/XK0/zyh/96HKHWXENjUbZIYVIueQawyspAaasnBdyfWwYKjXh3/J0fp3cXBsv7LrXWe/1dqLaCsV7u4jg2Mr3KfFw7Dj1K6mUEf1QAynSvEGP8fa5lD37GT6701ghSZbqAeGhsgHnA3iV8TkuaH07rZemD0vSSUsrhudJlLjw52grgMJwqkXHicMxW4Ixl1uLfMC5FgFd8HFWnhyAUDn1tu8R72HTlWuNIQe6hDB4Q5ty//gI4HbiaoFHPXsi0oxj96+BjUrDAmrAQvptPpyAtO4ZYueGj3ZCZBuF+TZXTG2G14R/9eBPWzlebjnQuxivHqpl24rBX12rfvY7CF9ktj29DvMbmFBrGJiZQVMHdc36zPDRzUHBZImRcVfszK2jF6Oa45Qit01jsX0myq3IvCQJaZZ7BE4lDhDH40WMI9+n6s87Bv8UVSyWyoUsxAkcoLL2e/6l33nVA8x3nLNoFH9d0fiMCMFXHEdWl05pHoFKGN0rbkSDgncQ2HU9otL437xO+gZ6dqQYDLOa6CHEVl/iKgYzKynF3LWqIkHv5D0fN87hEousZ8KqwFrNn0AMozSx7/DXPei4UcM7SWdNRGjv1RNgrhYsyop864FOUUHgmw2CIe/tYwOoPlgCxNHBJg8jm/QztQR8TDk0iDmC6wAX2nE2RG0OEyj1cM10asE2yjnyQmUnxj7U9wD3nJre9I4E47Enkl5Eh2pVPVXEchvuGoTAdzv5HKNigTI4xYPcIgl3fRxtXa1gs2q]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[heroku上部署ss先来占个坑 之前在github上发现了一个在heroku上搭建shadowsocks的项目，自己试着搭建，发现极好用。此时原项目已被作者删除，重新找了一个。特点： 1、快速，youtube上4k视频无压力2、无限流量3、免费！免费！ github项目地址]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>heroku</tag>
        <tag>ss</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--深克隆]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E6%B7%B1%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[八、在JavaScript中如何实现一个深克隆 前言在要实现一个深克隆之前我们需要了解一下javascript中的基础类型. javascript基础类型 JavaScript原始类型:Undefined、Null、Boolean、Number、String、SymbolJavaScript引用类型:Object 1.浅克隆 浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存. 123456789101112131415161718// 浅克隆函数function shallowClone(o) &#123; const obj = &#123;&#125;; for ( let i in o) &#123; obj[i] = o[i]; &#125; return obj;&#125;// 被克隆对象const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = shallowClone(oldObj);console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // true 我们可以看到,很明显虽然oldObj.c.h被克隆了,但是它还与oldObj.c.h相等,这表明他们依然指向同一段堆内存,这就造成了如果对newObj.c.h进行修改,也会影响oldObj.c.h,这就不是一版好的克隆. 12newObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 'change' &#125; 我们改变了newObj.c.h.i的值,oldObj.c.h.i也被改变了,这就是浅克隆的问题所在. 当然有一个新的apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了. 2.深克隆2.1 JSON.parse方法前几年微博上流传着一个传说中最便捷实现深克隆的方法,JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.1const newObj = JSON.parse(JSON.stringify(oldObj)); 我们依然用上一节的例子进行测试1234567891011const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // falsenewObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 2 &#125; 果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了. 确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑. 1.他无法实现对函数 、RegExp等特殊对象的克隆 2.会抛弃对象的constructor,所有的构造函数会指向Object 3.对象有循环引用,会报错 主要的坑就是以上几点,我们一一测试下. 1234567891011121314151617181920212223242526272829// 构造函数function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');// 函数function say() &#123; console.log('hi');&#125;;const oldObj = &#123; a: say, b: new Array(1), c: new RegExp('ab+c', 'i'), d: Messi&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined [Function: say]// 稀疏数组复制错误console.log(newObj.b[0], oldObj.b[0]); // null undefined// 无法复制正则对象console.log(newObj.c, oldObj.c); // &#123;&#125; /ab+c/i// 构造函数指向错误console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person] 我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。 123456const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON 对象的循环引用会抛出错误. 2.2 构造一个深克隆函数我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.(这个方法也会出现上一节提到的问题) 由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。 12345678910111213141516171819const isType = (obj, type) =&gt; &#123; if (typeof obj !== 'object') return false; const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case 'Array': flag = typeString === '[object Array]'; break; case 'Date': flag = typeString === '[object Date]'; break; case 'RegExp': flag = typeString === '[object RegExp]'; break; default: flag = false; &#125; return flag;&#125;; 这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略. 123const arr = Array.of(3, 4, 5, 2);console.log(isType(arr, 'Array')); // true 对于正则对象,我们在处理之前要先补充一点新知识. 我们需要通过正则的扩展了解到flags 属性 等等,因此我们需要实现一个提取flags的函数.1234567const getRegExp = re =&gt; &#123; var flags = ''; if (re.global) flags += 'g'; if (re.ignoreCase) flags += 'i'; if (re.multiline) flags += 'm'; return flags;&#125;; 做好了这些准备工作,我们就可以进行深克隆的实现了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** deep clone* @param &#123;[type]&#125; parent object 需要进行克隆的对象* @return &#123;[type]&#125; 深克隆后的对象*/const clone = parent =&gt; &#123; // 维护两个储存循环引用的数组 const parents = []; const children = []; const _clone = parent =&gt; &#123; if (parent === null) return null; if (typeof parent !== 'object') return parent; let child, proto; if (isType(parent, 'Array')) &#123; // 对数组做特殊处理 child = []; &#125; else if (isType(parent, 'RegExp')) &#123; // 对正则对象做特殊处理 child = new RegExp(parent.source, getRegExp(parent)); if (parent.lastIndex) child.lastIndex = parent.lastIndex; &#125; else if (isType(parent, 'Date')) &#123; // 对Date对象做特殊处理 child = new Date(parent.getTime()); &#125; else &#123; // 处理对象原型 proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 child = Object.create(proto); &#125; // 处理循环引用 const index = parents.indexOf(parent); if (index != -1) &#123; // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 return children[index]; &#125; parents.push(parent); children.push(child); for (let i in parent) &#123; // 递归 child[i] = _clone(parent[i]); &#125; return child; &#125;; return _clone(parent);&#125;; 我们做一下测试123456789101112131415161718192021222324function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');function say() &#123; console.log('hi');&#125;const oldObj = &#123; a: say, c: new RegExp('ab+c', 'i'), d: Messi,&#125;;oldObj.b = oldObj;const newObj = clone(oldObj);console.log(newObj.a, oldObj.a); // [Function: say] [Function: say]console.log(newObj.b, oldObj.b); // &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/iconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person] 当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--传递引用]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[七、传递引用 1.JavaScript中的基本类型传递一个我们经常遇到的问题：“JS中的值是按值传递，还是按引用传递呢？” 由于js中存在复杂类型和基本类型,对于基本类型而言,是按值传递的. 1234567var a = 1;function test(x) &#123; x = 10; console.log(x);&#125;test(a); // 10console.log(a); // 1 虽然在函数test中a被修改,并没有有影响到外部a的值,基本类型是按值传递的. 2.复杂类型按引用传递?我们将外部a作为一个对象传入test函数.12345678910var a = &#123; a: 1, b: 2&#125;;function test(x) &#123; x.a = 10; console.log(x);&#125;test(a); // &#123; a: 10, b: 2 &#125;console.log(a); // &#123; a: 10, b: 2 &#125; 可以看到,在函数体内被修改的a对象也同时影响到了外部的a对象,可见复杂类型是按引用传递的. 可是如果再做一个实验:12345678910var a = &#123; a: 1, b: 2&#125;;function test(x) &#123; x = 10; console.log(x);&#125;test(a); // 10console.log(a); // &#123; a: 1, b: 2 &#125; 外部的a并没有被修改,如果是按引用传递的话,由于共享同一个堆内存,a在外部也会表现为10才对.此时的复杂类型同时表现出了按值传递和按引用传递的特性. 3.按共享传递复杂类型之所以会产生这种特性,原因就是在传递过程中,对象a先产生了一个副本a,这个副本a并不是深克隆得到的副本a,副本a地址同样指向对象a指向的堆内存. 因此在函数体中修改x=10只是修改了副本a,a对象没有变化.但是如果修改了x.a=10是修改了两者指向的同一堆内存,此时对象a也会受到影响. 有人讲这种特性叫做传递引用,也有一种说法叫做按共享传递.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--this]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--this%2F</url>
    <content type="text"><![CDATA[五、this 1.什么决定了this的指向 this一直是JavaScript中十分玄乎的存在,很多人为了避开这个琢磨不透的东西,选择了尽量少得运用this,但是不可否认的是,正是因为this的存在才使得JavaScript拥有了更加灵活的特性,因此,搞清楚this是每一个JavaScript学习者的必修课. this之所以让人又爱又恨,正是因为它的指向让人琢磨不透,在进行详细讲解之前,我们要搞清楚一个大前提,this的指向不是在编写时确定的,而是在执行时确定的.123456789101112obj = &#123; name: "Messi", sayName: function () &#123; console.log(this.name); &#125;&#125;;obj.sayName(); //"Messi"var f = obj.sayName;f(); //undefindconsole.log(f === obj.sayName); //true 很明显,虽然f与obj.sayName是等价的,但是他们所产生的结果却截然不同,归根到底是因为它们调用位置的不同造成的. f的调用位置在全局作用域,因此this指向window对象,而window对象并不存在name因此会显示出undefind,而obj.sayName的this指向的是obj对象,因此会打印出&quot;Messi&quot;. 我们可以在以下代码中加入name = &quot;Bale&quot;;来证明以上说法. 12345678910111213name = "Bale";obj = &#123; name: "Messi", sayName: function () &#123; console.log(this.name); &#125;&#125;;obj.sayName(); //"Messi"var f = obj.sayName;f(); //"Bale"console.log(f === obj.sayName); //true 大家一定会好奇,调用位置是如何决定obj.sayName的this指向obj对象,f却指向window对象呢,其中遵循什么规则吗? 2.默认绑定 this一共存在4种绑定规则,默认绑定是其中最常见的,我们可以认为当其他三个绑定规则都没有体现时,就用的是默认的绑定规则. 1234567name = "Bale";function sayName () &#123; console.log(this.name);&#125;;sayName(); //"Bale" 以上代码可以看成我们第一节例子中的f函数,它之所以指向window对象,就是运用了this默认绑定的规则,因为此实例代码中既没有运用apply bind等显示绑定,也没有用new绑定,不适用于其他绑定规则,因此便是默认绑定,此时的this指向全局变量,即浏览器端的windowNode.js中的global. 3.隐式绑定 当函数被调用的位置存在上下文对象,或者说被某个对象拥有或包含,这时候函数的f的this被隐式绑定到obj对象上.12345678function f() &#123;console.log( this.name );&#125;var obj = &#123;name: "Messi",f: f&#125;;obj.f(); // Messi 4.显式绑定 除了极少数的宿主函数之外,所有的函数都拥有call apply方法,而这两个大家既熟悉又陌生的方法可以强制改变this的指向,从而实现显式绑定. call apply可以产生对this相同的绑定效果,唯一的区别便是他们参数传入的方式不同. call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 第一个参数意义都一样。第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3) 对应的apply写法为：func.apply(func1,[var1,var2,var3])，同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。 123456789function f() &#123;console.log( this.name );&#125;var obj = &#123;name: "Messi",&#125;;f.call(obj); // Messif.apply(obj); //Messi 我们可以看到,效果是相同的,call apply的作用都是强制将f函数的this绑定到obj对象上.在ES5中有一个与call apply效果类似的bind方法,同样可以达成这种效果, Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。 123456789101112function f() &#123; console.log( this.name );&#125;var obj = &#123; name: "Messi",&#125;;var obj1 = &#123; name: "Bale"&#125;;f.bind(obj)(); //Messi ,由于bind将obj绑定到f函数上后返回一个新函数,因此需要再在后面加上括号进行执行,这是bind与apply和call的区别 5.new绑定用 new 调用一个构造函数，会创建一个新对象, 在创造这个新对象的过程中,新对象会自动绑定到Person对象的this上，那么 this 自然就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。123456function Person(name) &#123; this.name = name; console.log(name);&#125;var person1 = new Person('Messi'); //Messi 6.绑定优先级通过以上的介绍,我们知道了四种绑定的规则,但是当这些规则同时出现,那么谁的优先级更高呢,这才有助于我们判断this的指向.通常情况下,按照优先级排序是:new绑定 &gt; 显式绑定 &gt;隐式绑定 &gt;默认绑定 我们完全可以通过这个优先级顺序判断this的指向问题. 7.ES6箭头函数中的this箭头函数不同于传统JavaScript中的函数,箭头函数并没有属于自己的this,它的this是捕获其所在上下文的 this 值，作为自己的 this 值,并且由于没有属于自己的this,箭头函数是不会被new调用的. MDN文档中关于箭头函数的实例很清楚的说明了这一点. 在 ECMAScript 3/5 中，这个问题可以通过新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。12345678910function Person() &#123; var self = this; // 也有人选择使用 `that` 而非 `self`. // 只要保证一致就好. self.age = 0; setInterval(function growUp() &#123; // 回调里面的 `self` 变量就指向了期望的那个对象了 self.age++; &#125;, 1000);&#125; 除此之外，还可以使用 bind 函数，把期望的 this 值传递给 growUp() 函数。 箭头函数则会捕获其所在上下文的 this 值，作为自己的 this 值，因此下面的代码将如期运行。123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向了 person 对象 &#125;, 1000);&#125;var p = new Person(); 当然,我们用babel转码器,也可以让我们更清楚理解箭头函数的this 12345678// ES6const obj = &#123; getArrow() &#123; return () =&gt; &#123; console.log(this === obj); &#125;; &#125;&#125; 123456789// ES5，由 Babel 转译var obj = &#123; getArrow: function getArrow() &#123; var _this = this; return function () &#123; console.log(_this === obj); &#125;; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--属性]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[六、属性 1.JavaScript中的对象JavaScript中的对象一般分为三类:内置对象(Array, Error, Date等), 宿主对象(对于前端来说指的是浏览器对象,例如window), 自定义对象(指我们自己创建的对象). 因此,我们主要讨论的内容是围绕自定义对象展开的,今天我们就对象的属性进行深入地探究. 2.属性的创建我们先定义一个对象,然后对其赋值:12var person = &#123;&#125;;person.name = "Messi"; 以上操作相当于给person对象建立了一个name属性,且值为&#39;Messi&#39;. 那么这个赋值的过程具体的原理是什么呢? 首先,我们创建了一个’空’对象,之所以我们打上引号,是因为这并不是一个严格意义上的空对象,因为在建立这个对象的过程中,JavaScript已经为这个对象内置了方法和属性,当然是不可见的,在属性的建立过程中就调用了一个隐式的方法[[put]]. 大概的创建过程是,当属性第一次被创建时,对象调用内部方法[[put]]为对象创建一个节点保存属性.12345st=&gt;start: persone=&gt;end: persen.name = &quot;Messi&quot;io1=&gt;inputoutput: [[put]]st-&gt;io1-&gt;e 3.属性的修改我们对上例中的代码做一下修改:123var person = &#123;&#125;;person.name = "Messi";person.name = "Bale"; 很显然,name被创建后,该属就被进行了修改,原属性值Messi被修改为Bale,那么这个过程又是如何发生的呢? 其实对象内部除了隐式的[[put]]方法,还有一个[[set]]方法,这个方法不同于[[put]]在创建属性时调用,而是在同一个属性被再次赋值的时候用于更新属性进行的调用. 12345st=&gt;start: person.name = &quot;Messi&quot;e=&gt;end: persen.name = &quot;Bale&quot;io1=&gt;inputoutput: [[put]]st-&gt;io1-&gt;e 4.属性的查询判断一个属性或者方法是否在一个对象中,通常有两种方式.in操作符方式:1234var person = &#123; name: "Messi"&#125;;console.log("name" in person); //true hasOwnProperty方法: 1234var person = &#123; name: "Messi"&#125;;console.log(person.hasOwnProperty("name")); //true 5.属性的删除删除一个属性,最正确的方式是用delete方法,一个错误的方式是将该属性赋值为null,该方式的错误之处在于赋值null相当于调用了[[set]]方法把原属性值更改为了null,这个保存属性的节点依然存在,而用delete方法便能彻底删除这个节点.12345var person = &#123; name: "Messi"&#125;;delete person.name;console.log("name" in person); //false 6.属性的枚举我们通常用for...in枚举对象中的属性,它会将属性一一返回.在ES5中引入了一个新的方法Object.key(),不同之处在于,它可以将结果以数组的形式返回1234567891011var person = &#123; name: "Messi", age: 29&#125;;for(var pros in person ) &#123; console.log(pros); // name age &#125;var pros = Object.keys(person);console.log(pros); //[ 'name', 'age' ] 值得注意的是,并非所有的属性都是可枚举的,例如对象自带的属性length等等,因此我们可以用propertyIsEnumerable()方法来判断一个属性是否可枚举.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--原型]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[四、原型 1.原型对象绝大部分的函数(少数内建函数除外)都有一个prototype属性,这个属性是原型对象用来创建新对象实例,而所有被创建的对象都会共享原型对象,因此这些对象便可以访问原型对象的属性,例如hasOwnProperty()方法存在于Obejct原型对象中,它便可以被任何对象当做自己的方法使用. object.hasOwnProperty( propertyName )hasOwnProperty()函数的返回值为Boolean类型。如果对象object具有名称为propertyName的属性，则返回true，否则返回false。12345678 var person = &#123; name: "Messi", age: 29, profession: "football player" &#125;;console.log(person.hasOwnProperty("name")); //trueconsole.log(person.hasOwnProperty("hasOwnProperty")); //falseconsole.log(Object.prototype.hasOwnProperty("hasOwnProperty")); //true 由以上代码可知,hasOwnProperty()并不存在于person对象中,但是person依然可以拥有此方法. 很多人此时会好奇,person对象是如何找到Object对象中的方法的呢?这其中的内部机制是什么?这便是我们接下来要说的原型链. 2.__proto__与[[Prototype]]上一篇我们的示意图中曾经出现过__proto__,在ES6之前这个__proto__是大部分主流浏览器(IE除外)引擎提供的,还尚属非ECMA标准,在解析一个对象实例的时候为对象实例添加一个__proto__属性,此属性指向原型对象,我们便可以通过此属性找到原型对象.12345678function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); //person1 = &#123;name:"Messi", age: 29, profession: "football player"&#125;;var person2 = new person("Bale", 28); //person2 = &#123;name:"Bale", age: 28, profession: "football player"&#125;;console.log(person1.__proto__ === person.prototype); //true __proto__除了被主流浏览器支持外,还被Node.js支持,在ES2015进入到规范附录部分,算是被正式纳入了标准. 而在标准的语法里,实例对象是通过内置的内部属性[[Prototype]]来追踪原型对象的,这个[[Prototype]]的指针始终指向原型对象,此属性通常情况下是不可见的,我们需要用getPrototypeOf()来读取[[Prototype]]属性值(这个值就是原型对象). 12var obj = &#123;&#125;;console.log(Object.getPrototypeOf(obj) === Object.prototype); //true 同时我们也可以用isPrototypeOf来检验某个对象是否是另一个对象的原型对象. 12var obj = &#123;&#125;;console.log(Object.prototype.isPrototypeOf(obj)); //true ３．原型链在我们了解了__proto__与[[Prototype]]之后,就可以相对容易理解原型链了,由于__proto__与[[Prototype]]功能相似,但是__proto__更容易测试方便学习,我们选择__proto__来进行原型链的讲解. 12345678910111213function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); //person1 = &#123;name:"Messi", age: 29, profession: "football player"&#125;;var person2 = new person("Bale", 28); //person2 = &#123;name:"Bale", age: 28, profession: "football player"&#125;;person1.hasOwnProperty("name");console.log(person1.hasOwnProperty("hasOwnProperty")); //fasleconsole.log(person1.__proto__ === person.prototype); //trueconsole.log(person.prototype.hasOwnProperty("hasOwnProperty")); //falseconsole.log(person1.__proto__.__proto__ === person.prototype.__proto__); // trueconsole.log(person.prototype.__proto__.hasOwnProperty("hasOwnProperty")); //true 我们可以分析这个例子,看看person1对象实例是如何调用hasOwnProperty()这个方法的. 首先person1对象实例中寻找hasOwnProperty()方法,person1.hasOwnProperty(&quot;hasOwnProperty&quot;)返回false,发现不存在此方法,这时通过__proto__找到person1的原型对象. 在person1的原型对象person1.__proto__即person.prototype中寻找hasOwnProperty()方法,person.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)返回false,依然没有找到,此时顺着person.prototype的__proto__找到其原型对象. 在person.prototype原型对象person.prototype.__proto__即Object.prototype中寻找hasOwnProperty()方法,Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)返回true,由于hasOwnProperty()为Object.prototype内置方法,因此person1顺利找到此方法并调用. 总而言之,实例对象方法调用,是现在实力对象内部找,如果找到则立即返回调用,如果没有找到就顺着__proto__向上寻找,如果找到该方法则调用,没有找到会直接报错,这便是原型链. 如图所示,会更加直观. 4.ES6中的__proto__虽然__proto__在最新的ECMA标准中被纳入了规范,但是由于__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API.标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）代替。 12345678910function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29);console.log(Object.getPrototypeOf(person1) === person.prototype); //trueObject.setPrototypeOf(person1, &#123;League: "La Liga"&#125;); console.log(person1.League); //La Liga 以上为具体用法,但是值得注意的是Object.setPrototypeOf()在使用中有一个坑,如代码所示:123456789101112function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); var person2 = new person("Bale", 28); Object.setPrototypeOf(person1, &#123; League: "La Liga"&#125;);console.log(person1.League); //La Ligaconsole.log(person2.League); //undefind 也就是说不同于直接用person1.__proto__.League = &quot;La Liga&quot;;会使得两个实例同时生效,Object.setPrototypeOf()只能生效一个实例对象.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--作用域]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[三、作用域 1. 为什么要理解作用域原因很简单,JavaScript中最重要的一个概念闭包的理解就建立在对作用域的理解之上,而一个对象的的构成往往离不开闭包以及作用域. 2. 动态作用域or静态作用域?首先我们要搞清楚JavaScript的作用域类型,这有助于我们在分析作用域时的判断. 静态作用域:静态作用域是指声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。 动态作用域:程序中某个变量所引用的对象是在程序运行时刻根据程序的控制流信息来确定的。 大多数现代编程语言都采用的静态作用域,即代码在写出来的时候就已经确定的,并非在执行时再确定,我们可以根据以下代码一探究竟.12345678function f() &#123; console.log(a);&#125;function g() &#123; var a = 7; f();&#125;g(); // a is not defined 这段代码在执行时候会报错,很明显,如果JavaScript采用了动态作用域,a在执行时确定的话,那么以上代码相当于这样:1234567function g() &#123; var a = 7; function f() &#123; console.log(a); &#125;&#125;g(); //undefind 因此,我们可以判断出JavaScript属于静态作用域. 3.函数作用域函数是存在自身作用域的,在创建函数之初,函数体内就产生了作用域,为了方便理解,我们引用了《你不知道的JavaScript》书中的代码及图例,他会很清晰地帮助我们理解函数作用域.12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); // 2, 4, 12 由于JavaScript是采用静态作用域,作用域是在函数创建的时候就确定下来的. 4.作用域链那么,我们可以仔细分析一下这个作用域链.我们可以看到scope chain通过指向本函数的变量对象,并通过本函数的变量对象与整个父级函数变量对象联系在一起,这就是作用域链. 所以说，作用域链与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。 5. 块级作用域在ES2015之前,JavaScript中实际上是没有语法层面的块级作用域,这就造成了很多意外的产生.1234for (var i = 0; i&lt;3; i++) &#123;&#125;console.log(i); //3 如果是在有块级作用域的语言中,i是不会被打印出来的,但是在JavaScript中却被打印出来,这就是变量泄露的情况,也就是说看似在块级作用域的变量泄漏到全局作用域中,这也就造成了全局污染. 在ES5中,人们为了解决这个问题,一般采用立即执行函数IIFE来模拟块级作用域,但是这种写法不易读也不优雅,因此,在ES2015中引入了let,通过let可以创建块级作用域. let与var在使用上基本是类似的,但是let有三个主要的特点 可创建块级作用域 不存在变量提升 存在暂时性死区 例如上面的代码如果改用let声明,就不存在变量污染全局的情况1234for (let i = 0; i&lt;3; i++) &#123;&#125;console.log(i); //i is not defind 至于其它let的具体用法,可以直接参考《ES6入门教程》. 6.什么是闭包我们先简单地描述一下闭包:闭包是一个函数读取其它函数变量的桥梁. 我们先从上面这个简单的例子开始12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); // 2, 4, 12 根据前面所学作用域的概念,函数f2将引用函数f1的变量a并打印,这个嵌套函数中,子函数对父函数中的变量进行了引用,而使得这个引用得以成行的桥梁就是‘闭包’. 很多讲解闭包的文章都用return做实例,值得注意的是,闭包的形成并不一定要有return,只要对其它函数变量产生了引用,就会产生闭包，而return的作用是方便外部访问. 可以看到bar通过作用域链向上寻找到变量,我理解的闭包是一个对象,包含了函数本身以及它引用的上下文环境,本实例函数的闭包可以用这段代码来示意下:{Funtion:bar, bar.variableObject:{c=12, ...}, foo.variableObject:{b=4, ...},window/global.variableObject:{a=2, ...}}具体地说，函数A包含函数B，函数B可以获取函数A中的数据，而函数A不能获取函数B中的数据，则函数A作用域以外可以通过调用函数B改变函数A的数据。 闭包只是javascript函数作用域产生的附属品]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--预解释]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E9%A2%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[二、预解释 1.从一个实例开始仔细阅读以下JavaScript代码,你觉得运行结果会是什么呢?是 1 还是2?123456var a= 1;function f() &#123; console.log(a); var a = 2;&#125;f(); 答案是undefined. 那么到底是什么原因导致了这个让人意外的结果呢?这就要从JavaScript解释阶段说起。 2.JavaScript预解释我们可以大致把JavaScript在浏览器中运行的过程分为两个阶段预解释阶段（有人说准确的说法是应该是Parser，我们以预解释方便理解） 执行阶段,在JavaScript引擎对JavaScript代码进行执行之前,需要进行预先处理,然后再对处理后的代码进行执行。 我们平时书写的JavaScript代码并不是JavaScript执行的代码(V8引擎读取一行执行一行这种理解是错误的),它需要预解释后,再由引擎进行执行. 具体的解释过程涉及到浏览器内核的技术不属于前端领域,不过我们可以浅显的理解一下V8在处理JavaScript的一般过程: 以上例中的var a = 2;为例,我们一般人的理解为声明了一个值为2的变量a,但是在JavaScript引擎处理时却分为了两个步骤: 读取var a后,在当前作用域中查找是否有相同声明,如果没有就在当前作用域集合中创建一个名为a的变量,否则忽略此声明继续进行解析. 接下来,V8引擎会处理a = 2的赋值操作,首先会询问当前作用域中是否有名为a的变量,如果有进行赋值,否则继续向上级作用域询问. 3.JavaScript执行环境我们上面提到的所谓javascript预解释正是创建函数的执行环境（又称“执行上下文”），只有搞定了javascript的执行环境我们才能搞清楚一段代码在执行过后为什么产生这样的结果。 我们用一段伪代码表示创立的执行环境12345executionContextObj = &#123; 'scopeChain': &#123; /* 变量对象 + 所有父级执行上下文中的变量对象 */ &#125;, 'variableObject': &#123; /* 函数参数 / 参数, 内部变量以及函数声明 */ &#125;, 'this': &#123;&#125;&#125; 作用域链(scopeChain)包括下面提到的变量对象(variableObject)和所有父级执行上下文中的变量对象. 变量对象(variableObject)是与执行上下文相关的数据作用域,一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明: 变量; 函数声明; 函数的形参 在有了这些基板概念之后我们可以梳理一下js引擎创建执行的过程: 创建阶段 创建Scope chain 创建variableObject 设置this 执行阶段 变量的值、函数的引用 执行代码 而变量对象的创建细节如下: 根据函数的参数，创建并初始化arguments object 扫描函数内部代码，查找函数声明（Function declaration） 对于所有找到的函数声明，将函数名和函数引用存入变量对象中 如果变量对象中已经有同名的函数，那么就进行覆盖 扫描函数内部代码，查找变量声明（Variable declaration） 对于所有找到的变量声明，将变量名存入变量对象中，并初始化为”undefined” 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 4.变量提升正是由于以上的处理,产生了大家熟知的JavaScript中的变量提升,具体以上代码的执行过程如以下伪代码所示:12345678910111213141516171819202122// global contextexecutionContextObj = &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; a: undefined, f: pointer to function f() &#125;, 'this': &#123;...&#125;&#125;...&#125;//首先在全局执行环境中声明了变量a以及函数f,此时a虽然被声明,但是尚未赋值x = 1;function f() &#123; executionContextObj &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; arguments: &#123;&#125;, a: undefined &#125;, 'this': &#123;...&#125; &#125; //内部词法环境中声明了变量a,此时a虽然被声明,但是尚未赋值 console.log(a);//此时a需要被被打印出来,在作用域内寻找a变量赋值,于是被赋值undefined a = 2;&#125; 我们可以明显看到,a变量在预解释阶段已经被赋值undefined,在执行阶段js是自上而下单线执行，当console.log(a)执行之时,a=2还没有被执行,a变量的值便是预处理阶段被赋予的undefined, 5.函数声明与函数表达式我们看到,在编译器处理阶段,除了被var声明的变量会有变量提升这一特性之外,函数也会产生这一特性,但是函数声明与函数表达式两种范式创建的函数却表现出不同的结果. 我们先看一个实例,运行以下代码12345678910f();g();//函数声明function f() &#123; console.log('f');&#125;//函数表达式var g = function() &#123; console.log('g');&#125;; f成功被打印出来,而g函数出现了类型错误,这是什么原因呢? 12345678910111213141516executionContextObj = &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; f: pointer to function f(), g: undefined&#125;, 'this': &#123;...&#125;&#125;f();g();//函数声明function f() &#123; console.log('f');&#125;//函数表达式var g = function() &#123; console.log('g');&#125;; 我们看到,在预解释阶段函数声明的f是被指向了正确的函数得以执行,而函数表达式g被赋予undefined,undefined无法被当作函数执行因此报错g is not a function. 6.冲突处理通常情况下我们不会将同一变量变量重复声明,但是出现了类似情况后,编译器会如何处理这些冲突呢? 变量之间冲突执行以下函数:123var a = 3;var a = 4;console.log(a); 结果显而易见,后声明变量值覆盖前者的值 函数之间冲突12345678f();function f() &#123; console.log('f');&#125;function f () &#123; console.log('g');&#125;; 结果同变量冲突,后者覆盖前者. 函数与变量之间冲突 123456console.log(f);function f() &#123; console.log('f');&#125;var f ='g'; 结果如下,函数声明将覆盖变量声明. [Function: f]7.ES6中的let在ES6中出现了两个最新的声明语法let与const,我们以let为例,进行测试看看与var的区别.12345function f() &#123; console.log(a); let a = 2;&#125;f(); // ReferenceError: a is not defined 这段代码直接报错显示未定义,let与const拥有类似的特性,阻止了变量提升,当代码执行到console.log(a)时,执行换将中a还从未被定义,因此产生了错误.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解javaScript--类型判断]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[一、类型判断 JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol JavaScript引用类型:Object 1.原始类型与引用类型1.1 原始类型又被称为基本类型，原始类型保存的变量和值直接保存在栈内存(Stack)中,且空间相互独立,通过值来访问,通过一个例子来解释. 12var person = 'Messi';var person1 = person; 上述代码在栈内存的示意图是这样的,可以看到,虽然person赋值给了person1.但是两个变量并没有指向同一个值,而是person1自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的. 1234567var person = 'Messi';var person1 = person;var person = 1;console.log(person); //1console.log(person1); //'Messi' 上述代码示意图是这样的,person的值虽然改变,但是由于person1的值是独立储存的,因此不受影响. 值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的. 123var person = 'Messi';var person1 = 'Messi';console.log(person === person1); //true 1.2引用类型剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。 与原始类型不同的是,引用类型的内容是保存在堆内存中,而栈内存(Heap)中会有一个堆内存地址,通过这个地址变量被指向堆内存中Object真正的值,因此引用类型是按照引用访问的. 123456789101112var a = &#123;name:"percy"&#125;;var b;b = a;a.name = "zyj";console.log(b.name); // zyjb.age = 22;console.log(a.age); // 22var c = &#123; name: "zyj", age: 22&#125;;console.log(a === c); //false 我们可以逐行分析: 1. `b = a`,如果是原始类型的话,`b`会在栈内自己独自创建一个内存空间保存值,但是引用类型只是`b`的产生一个对内存地址,指向堆内存中的`Object`. 2.`a.name = &quot;zyj&quot;`,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可. 3.最后创建了一个新的对象`c`,看似跟`b` `a`一样,但是在堆内存中确实两个相互独立的`Object`,引用类型是按照**引用比较**,由于`a` `c`引用的是不同的`Object`所以得到的结果是`fasle`. 2. 类型中的坑2.1 数组中的坑数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦. 稀疏数组:指的是含有空白或空缺单元的数组12345678910111213var a = [];console.log(a.length); //0a[4] = a[5];console.log(a.length); //5a.forEach(elem =&gt; &#123; console.log(elem); //undefined&#125;);console.log(a); //[,,,,undefined] 这里需要注意: 一开始建立的空数组a的长度为0,这可以理解,但是在a[4] = a[5]之后出现了问题,a的长度变成了5,此时a数组是[,,,,undefined]这种形态. 我们通过遍历,只得到了undefined这一个值,这个undefind是由于a[4] = a[5]赋值,由于a[5]没有定义值为undefined被赋给了a[4],可以等价为a[4] = undefined. 字符串索引 123456var a = [];a[0] = 'Bale';a['age'] = 28;console.log(a.length); //1console.log(a['age']); //28console.log(a); //[ 'Bale', age: 28 ] 数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里. 2.2 数字中的坑二进制浮点数 JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.123var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //false 这是个出人意料的结果,实际上a的值约为0.30000000000000004这并不是一个整数值,这就是二进制浮点数带来的副作用. 123456var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //falseconsole.log(Number.isInteger(a*10)); //falseconsole.log(Number.isInteger(b*10)); //trueconsole.log(a); //0.30000000000000004 我们可以用Number.isInteger()来判断一个数字是否为整数. NaN 1234var a = 1/new Object();console.log(typeof a); //Numberconsole.log(a); //NaNconsole.log(isNaN(a)); //true NaN属于特殊的Number类型,我们可以把它理解为坏数值,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己NaN === NaN //false,我们只能用isNaN()来检测一个数字是否为NaN. 3.类型转换原理类型转换指的是将一种类型转换为另一种类型,例如:123var b = 2;var a = String(b);console.log(typeof a); //string 当然,类型转换分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于JavaScript是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此JavaScript引擎会在运算时为变量设定类型. 这看起来很美好,JavaScript引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一到面试题开始. 1&#123;&#125;+[] //0 答案是0 是什么原因造成了上述结果呢?那么我们得从ECMA-262中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的语言规范,如果没这个耐心还是往下看. 这是JavaScript种类型转换可以从原始类型转为引用类型,同样可以将引用类型转为原始类型,转为原始类型的抽象操作为ToPrimitive,而后续更加细分的操作为:ToNumber ToString ToBoolean,这三种抽象操作的转换表如下所示 如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,// (1) for number hint, and (2) for string hint.function ToPrimitive(x, hint) &#123; // Fast case check. if (IS_STRING(x)) return x; // Normal behavior. if (!IS_SPEC_OBJECT(x)) return x; if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive); if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT; return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultNumber(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultString(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125; 上面代码的逻辑是这样的： 如果变量为字符串，直接返回. 如果!IS_SPEC_OBJECT(x)，直接返回. 如果IS_SYMBOL_WRAPPER(x)，则抛出异常. 否则会根据传入的hint来调用DefaultNumber和DefaultString，比如如果为Date对象，会调用DefaultString. DefaultNumber：首先x.valueOf，如果为primitive，则返回valueOf后的值，否则继续调用x.toString，如果为primitive，则返回toString后的值，否则抛出异常 DefaultString：和DefaultNumber正好相反，先调用toString，如果不是primitive再调用valueOf. 那讲了实现原理，这个ToPrimitive有什么用呢？实际很多操作会调用ToPrimitive，比如加、相等或比较操。在进行加操作时会将左右操作数转换为primitive，然后进行相加。 下面来个实例，({}) + 1（将{}放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。 加操作只有左右运算符同时为String或Number时会执行对应的%_StringAdd或%NumberAdd，下面看下({}) + 1内部会经过哪些步骤： {}和1首先会调用ToPrimitive{}会走到DefaultNumber，首先会调用valueOf，返回的是Object {}，不是primitive类型，从而继续走到toString，返回[object Object]，是String类型最后加操作，结果为[object Object]1再比如有人问你[] + 1输出啥时，你可能知道应该怎么去计算了，先对[]调用ToPrimitive，返回空字符串，最后结果为”1”。 本系列主要参考： JavaScript 类型的那些事]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解promise]]></title>
    <url>%2F2018%2F02%2F20%2F%E7%90%86%E8%A7%A3promise%2F</url>
    <content type="text"><![CDATA[前言在学习node的路上，理解异步操作是重点，而处理的方法一直在完善，先有setTimeout,后又promise，貌似目前目前大招是async/await(目前三个都不理解，(捂脸…))，下面就开始吧。这是在看JavaScript Promise迷你书时记录的笔记,若有错误，敬请指出，感激不尽。原文Promise迷你书 1、什么是Promise1.1、常见异步处理Promise是抽象异步处理对象以及对其进行操作的组件。Promise最初被提出是在E语言，E语言是基于并列/并行处理设计的一种编程语言。常见基于javaScript的异步处理大都利用回调函数 12345678----//使用回调函数的异步处理getAsync("fileA.txt", function(error, result)&#123; if(error)&#123; throw error; &#125; &#125;);---- 1.2、使用Promise进行异步处理Promise是把类似的异步处理对象和处理规则规范化，并按照统一的接口来编写，而采取规定方法之外的写法都会出错。 12345678//使用Promise进行异步处理var promise = getAsyncPromise("fileA.txt");promise.then(function(result)&#123; //获取文件内容成功时的处理&#125;).catch(function(error)&#123; //获取文件内容失败时的处理&#125;);&lt;1&gt;返回promise对象 我们可以向预设了抽象化异步处理的promise对象，注册这个promise对象执行成功和失败时相应的回调函数。这里与常见异步处理操作不同，需严格遵守规则，无法自由的定义回调函数的参数。所以，promise的功能是可以将复杂的异步处理轻松地进行模式化 1.3、Promise简介三种API类型 ConstructorPromise类似XMLHttpRequest，从构造函数promise新建一个promise对象作为接口。 12345//创建promise对象var promise = new Promise(function(res,rej)&#123; //异步处理 //处理完后，调用resolve或reject&#125;); Instance Method通过new生成promise对象，promise.then()方法可以设置在resolve(成功)/reject(失败)时调用的回调函数。 promise.then(onFulfilled, onRejected) resolve(成功)时onFulfilled 会被调用 reject(失败)时onRejected 会被调用只想对异常进行处理时可以采用 promise.then(undefined, onRejected)这种方式，只指定reject时的回调函数即可。不过这种情况下 promise.catch(onRejected) 应该是个更好的选择。 Static Method辅助方法：promise.all()promise.resolve() 1.3.1、Promise workflow123456789101112function asyncFunction() &#123;return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then(function (value) &#123; console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); 1.3.2、Promise的状态用new Promise实例化的promise对象有以下三个状态： “has-resolution” - Fulfilled resolve(成功)时。此时会调用 onFulfilled “has-rejection” - Rejected reject(失败)时。此时会调用 onRejected “unresolved” - Pending 既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等状态变化 promise对象的状态，从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。也就是说，Promise与Event等不同，在.then后执行的函数可以肯定地说只会被调用一次。另外，Fulfilled和Rejected这两个只中任一状态都可以表示为Settled(不变的)。 Settled resolve(成功)或rejected(失败)。 1.4、编写Promise代码如何写Promise代码。 1.4.1、创建promise对象流程如下 1.new Promise(fn)返回一个promise对象 2.在fn中指定异步等处理 * 处理结果正常，调用resolve(处理结果值) * 处理结果错误，调用reject(Error对象) 在此用Promise来通过异步处理方式来获取XMLHttpRequest(XHR)的数据。 创建XHR的promise对象首先，创建一个用Promise把XHR处理包装起来的名为getURL的函数。 xhr-promise.js1234567891011121314151617181920212223242526function getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status == 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125; &#125;);&#125;//实例var URL = "http://httpbin.org/get";getURL(URL).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;);//输出结果为请求数据 getURL只有在通过XHR取得结果状态码为200(数据取得成功)时，调用resovle，其他情况(取得失败)时调用reject方法。 成功时 resolve(req.responseText)在response的内容中加入了这个参数，resolve方法把参数传给回调函数(then方法会接收这个参数)。 常见回调函数callback(err, response)的值为err(出错)和response(接收的数据)，来处理正常和异常的情况，而在Promise中resolve/reject则担当了这个职责 失败时 当发生错误时，onerror事件被触发，调用reject。 此时，如reject(new Error(req.statusText))，创建一个Error对象并将具体的值传入，传给reject的参数只要是Error对象(或者继承自Error对象)就行。 我的疑问]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>promise</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node要点总结]]></title>
    <url>%2F2018%2F02%2F20%2Fnode%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node开发要点1、常用前端技术： html5 css3 jQuery 2、js高级话题： 面向对象 闭包 作用域 设计模式 3、其他后端技术： mongodb redis apache nignix mysql 4、node内置核心库： 全局对象 时事件 流 网络 子程序 5、常用知名第三方库： async express koa 6、node高级话题： 异步 部署 性能调优 异常调试 node事件循环机制* javaScript高级话题(面向对象、作用域、闭包、设计模式)面向对象1、常用js类定义的方法？构造函数原型法： 1234567891011121314151617 function Person () &#123; this.name = 'pinocchio'; &#125; Person.prototype.sayName = function () &#123; alert(this.name);; &#125; var person = new Person (); person.sayName(); //对象创建: var Person = &#123; name: 'pinocchio', sayName: function () &#123; alert(this.name); &#125; &#125;; var person = Object.create(Person); person.sayName(); 2、js类继承的方法？原型链法(Person是Animal的子集，即子类)： 12345678910111213141516171819202122232425262728293031323334 function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125; function Person () &#123;&#125; Person.prototype = Animal.prototype; //人继承动物 Person.prototype = constructor = 'Person'; //更新构造函数为人属性复制法(单纯复制，两者无继承关系)： function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123;&#125; //复制动物所有属性到人 for (prop in Animal.prototype) &#123; Person.prototype[prop] = Animal.prototype[prototype]; &#125; //更新构造函数为人 Person.prototype.constructor = 'Person'; 构造器应用法: function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123; //apply,call,bind方法都行，有细微区别 Animal.call(this); &#125; 3、js类多重继承的方法怎么实现？通过类继承里面的属性复制法来实现，可以继承所有父类的prototype属性 作用域 4、js里作用域是什么样？函数作用域， 123456789var globalVar = 'global var';function test() &#123; alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义 var globalVar = 'overrided var'; // globalVar在本函数内被重定义 alert(globalVar); // overrided var&#125;alert(globalVar); // global var，使用全局变量 5、js中this指的是什么？this指的是对象本身 6、apply，call，bind有什么区别？apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； 三者第一个参数都是this要指向的对象，也就是想指定的上下文； 三者都可以利用后续参数传参； apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表 12345678910111213141516function Person () &#123;&#125;Person.prototype.sayName() &#123; alert(this.name);&#125;//普通对象，不是Person实例var obj = &#123; name: 'pinocchio'&#125;;//applyPerson.prototype.sayName.apply(obj, [param1, param2, param3]);//callPerson.prototype.sayName.call(obj, param1, param2, param3);//bind,先绑定，再执行var sn = Person.prototype.sayName.bind(obj);sn([param1, param2, param3]);sn(param1, param2, param3); 7、caller，callee和arguments分别是什么？123456789101112caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量． function parent(param1, param2, param3) &#123; child(param1, param2, param3); &#125; function child() &#123; console.log(arguments); // &#123; '0': 'mqin1', '1': 'mqin2', '2': 'mqin3' &#125; console.log(arguments.callee); // [Function: child] console.log(child.caller); // [Function: parent] &#125; parent('mqin1', 'mqin2', 'mqin3'); 闭包8、什么是闭包？闭包有什么用处？通俗的说，闭包就是作用域范围，因为js是函数作用域，所以函数就是闭包．全局函数的作用域范围就是全局，所以无须讨论．更多的应用其实是在内嵌函数，这就会涉及到内嵌作用域，或者叫作用域链。 这就会带来另外一个问题，什么时候引用结束？如果不结束，就会一直占用内存，引起内存泄漏．不用的时候就引用设为空。 9、defineProperty, hasOwnProperty, propertyIsEnumerable都是做什么用的？Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有value,writable,configurable,enumerable,set/get等.hasOwnProerty用于检查某一属性是不是存在于对象本身，继承来的 父亲的属性不算．propertyIsEnumerable用来检测某一属性是否可遍历，也就是能不能用for..in循环来取到. 设计模式10、js常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等1) 单例： 任意对象都是单例，无须特别处理var obj = {name: &#39;michaelqin&#39;, age: 30}; 2) 工厂: 就是同样形式参数返回不同的实例12345678910111213function Person() &#123; this.name = 'Person1'; &#125;function Animal() &#123; this.name = 'Animal1'; &#125;function Factory() &#123;&#125;Factory.prototype.getInstance = function(className) &#123; return eval('new ' + className + '()');&#125;var factory = new Factory();var obj1 = factory.getInstance('Person');var obj2 = factory.getInstance('Animal');console.log(obj1.name); // Person1console.log(obj2.name); // Animal1 3) 代理: 就是新建个类调用老类的接口,包一下1234567891011121314151617function Person() &#123; &#125;Person.prototype.sayName = function() &#123; console.log('michaelqin'); &#125;Person.prototype.sayAge = function() &#123; console.log(30); &#125;function PersonProxy() &#123; this.person = new Person(); var that = this; this.callMethod = function(functionName) &#123; console.log('before proxy:', functionName); that.person[functionName](); // 代理 console.log('after proxy:', functionName); &#125;&#125;var pp = new PersonProxy();pp.callMethod('sayName'); // 代理调用Person的方法sayName()pp.callMethod('sayAge'); // 代理调用Person的方法sayAge() 4) 观察者: 就是事件模式，比如按钮的onclick这样的应用.12345678910111213141516171819202122232425262728293031323334353637function Publisher() &#123; this.listeners = [];&#125;Publisher.prototype = &#123; 'addListener': function(listener) &#123; this.listeners.push(listener); &#125;, 'removeListener': function(listener) &#123; delete this.listeners[listener]; &#125;, 'notify': function(obj) &#123; for(var i = 0; i &lt; this.listeners.length; i++) &#123; var listener = this.listeners[i]; if (typeof listener !== 'undefined') &#123; listener.process(obj); &#125; &#125; &#125;&#125;; // 发布者function Subscriber() &#123;&#125;Subscriber.prototype = &#123; 'process': function(obj) &#123; console.log(obj); &#125;&#125;; // 订阅者var publisher = new Publisher();publisher.addListener(new Subscriber());publisher.addListener(new Subscriber());publisher.notify(&#123;name: 'michaelqin', ageo: 30&#125;); // 发布一个对象到所有订阅者publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者 11、列举数组相关的常用方法push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter 12、列举字符串相关的常用方法indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase node核心内置库类（事件， 流， 文件， 网络）node概览：1、node架构主要分为三层，应用app &gt;&gt; V8及node内置架构 &gt;&gt; 操作系统. V8是node运行的环境，可以理解为node虚拟机． node内置架构又可分为三层: 核心模块(javascript实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http. 2、node的核心模块EventEmitter, Stream, FS, Net, 全局对象 node全局对象：1、node有哪些全局对象？process、 console、 Buffer 2、process有哪些方法？process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit 3、console有哪些常用方法?console.log/console.info, console.error/console.warning, console.time/console.timeEnd, console.trace, console.table 4、node有哪些定时功能?setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick 5、node中的事件循环是什么样子的?process.nextTick &gt;&gt; setImmidate &gt;&gt; setTimeout/SetInterval 6、node中的Buffer如何应用?Buffer是用来处理二进制数据的，比如图片，mp3,数据库文件等.Buffer支持各种编码解码，二进制字符串互转 EventEmitter:1、什么是EventEmitter?EventEmitter是node中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题. 2、如何实现一个EventEmitter?主要分三步：定义一个子类， 调用构造函数， 继承EventEmitter 123456789101112131415var util = require('util'), EventEmitter = require('event').EventEmitter;//构造函数function MyEmitter () &#123; EventEmitter.call(this);&#125;//继承util.inherits(MyEmitter, EventEmitter);var em = new MyEmitter();//接受事件em.on('hello', function(data) &#123; console.log('收到事件hello的数据：'， data);&#125;);em.emit('hello', 'EventEmitter传递消息真方便'); 3、EventEmitter有哪些典型应用？模块之间传递消息 回调函数内外传递消息 处理流数据 观察者模式发射触发机制 4、怎么捕获EventEmitter的错误事件？监听error事件即可，若有多个EventEmitter，可用domain来统一处理。 123456789101112var domain = require('domain');var myDomain = domain.create();//接受事件并打印myDomain.on('error', function(err)&#123; console.log('domain接受到的事件', err);&#125;);myDomain.run(function() &#123; var emitter1 = new MyEmitter(); emitter1.emit('error', '错误事件来自emitter1'); var emitter2 = new MyEmitter(); emitter2.emit('error', '错误事件来自emitter2');&#125;); 5、EventEmitter中的newListenser事件有什么用处?newListener可以用来做事件机制的反射，特殊应用，事件管理等．当任何on事件添加到EventEmitter时，就会触发newListener事件，基于这种模式，我们可以做很多自定义处理. 123456789var emitter3 = new MyEmitter();emitter3.on('newListener', function(name, listener) &#123; console.log("新事件的名字:", name); console.log("新事件的代码:", listener); setTimeout(function()&#123; console.log("我是自定义延时处理机制"); &#125;, 1000);&#125;);emitter3.on('hello', function()&#123; console.log('hello node');&#125;); Streamstream是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型． 1、Stream有什么好处？非阻塞式数据处理提升效率，片段处理节省内存，管道处理方便扩展 2、Stream有哪些典型应用？文件处理、网络交换、数据转换、音视频处理 3、怎么捕获Stream的错误事件？监听error事件、方法同EventEmitter 4、哪些常用Stream，分别什么时候用？Readable为可被读流，在座位数据源时使用； Writeable为可被读流，在作为输出元时使用； Duplex为读写流，作为输入源接受被写入，同时又作为输入源被后面的流读出； Transform机制和Duplex一样，都是双向流，区别时Transfrom只需要实现一个函数_transfrom(chunk, encoding, callback); 而Duplex需要分别实现_read(size)函数和_write(chunk, encoding, callback)函数. 5、实现一个Writable Stream?三步走:1)构造函数call Writable 2) 继承Writable 3) 实现_write(chunk, encoding, callback)函数 ``` var Writeable = require(&apos;stream&apos;).Writable; var util = require(&apos;util&apos;); //构造函数 function MyWriteable(options) { Writeable.call(this, options); } //继承Writeable util.inherits(MyWriteable, Writable); MyWritable.prototype._write = function(chunk, encoding, callback) { // 此处可对写入的数据进行处理 console.log(&quot;被写入的数据是:&quot;, chunk.toString()); callback(); }; // stdin作为输入源，MyWritable作为输出源 process.stdin.pipe(new MyWritable()); ``` node高级话题(异步， 部署， 性能调优， 异步调试)1、node中的异步与同步怎么理解？node是单线程的，异步是通过一次次的事件循环来实现的。 同步则是阻塞式的io，在高并发环境下会有很大的性能问题，所以同步一般只在基础框架的启动时使用，如：加载配置文件、初始化程序 2、哪些方法可以进行异步流程控制？1）多层嵌套回调 2）单独为回调写函数，函数里再回调 3)第三方框架：async、q、promise 3、怎么绑定node程序到80端口？1）sudo 2）Apache/nginx代理 3）操作系统的firewall iptables端口绑定 4）第三方库up 4、有哪些方法可以让node程序遇到错误后自动重启?1) runit 2) forever 3) nohup npm start &amp; 4）up -watch -port 80 server.js 5、怎么充分利用多个cpu？1个cpu运行一个node程序 6、怎样调节node执行单元的内存大小?用--max-old-space-size 和 --max-new-space-size 来设置 v8 使用内存的上限 7、有哪些常用方法可以防止程序崩溃?1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试 8、怎样调试node程序?1) 监听错误事件req.on(&apos;error&apos;, function(){}), 适用EventEmitter存在的情况; 2) Promise.then.catch(error),适用Promise存在的情况 3) try-catch,适用async-await和js运行时异常，比如undefined object]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>总结</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable详解及React中实践]]></title>
    <url>%2F2017%2F12%2F17%2FImmutable%E8%AF%A6%E8%A7%A3%E5%8F%8AReact%E4%B8%AD%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1、js中数据可变状态概念：js中的对象一般是可变的，由于使用了引用赋值，新的对象简单的引用了原始的对象，改变的新对象将影响到原始对 象。 例如： 1234foo = &#123;a:1&#125;;bar = foo;bar.a = 2;console.log(foor.a); //输出2 优缺点：优点：节约内存 缺点：当应用复杂后，会造成非常大的隐患 解决办法：shallowCopy（浅拷贝），deepCopy（深拷贝） 两种方法可将对象置为不可变对象，但同时也造成cpu和内存的浪费 2、Immutable.Data]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Immutable</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React笔记]]></title>
    <url>%2F2017%2F12%2F17%2FReact%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据类型 state/props state—组件本身的数据 props—从其他组件传入的组件 生命周期 getDefaultProps //获得默认数据 getInitialState //设置State数据 componentWillMount //在component即将挂在到页面上时 render componentDidMount //ui真正挂载到文档流 componentWillUnmount //文件销毁 组件间通信 widget之间通过props通信 子组件与父组件的通信 事件订阅 React-router url模式： browserHistory //yoursite.com/a/b hashHistory //yoursite.com/#a/b 两种组件：（装载页面的组件） IndexRouter //默认（没有存url） Router 写法： &lt; Link to = “url”&gt; 注释： 页面切换时，组件会被销毁，再次进入时重新加载。若要实现某功能一直运行，不受页面切换的影响，则将该功 能置于根节点上。 事件订阅 //TODO:完善整个概念]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fwebpack%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[webpack使用中的错误：1.npm run dev 出错打包错误in ./src/index.js12345Module build failed: TypeError: fileSystem.statSync is not a function at module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/utils/exists.js:7:25) at find (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/resolve-rc.js:13:9) at Object.module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/index.js:113:132) @ multi main 原因及解决方法：babel-loader7.x版本与webpack1.x不兼容，将babel-loader版本降到6.x]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装以及升级node，npm：1.安装nodejssudo apt install nodejs-legacy2.安装npmsudo apt install npm3.清楚cachesudo npm cache clean -f4.安装n包sudo npm install -g n5.获取nodejs稳定版sudo n stable6.升级npmsudo npm install -g npm]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2017%2F12%2F13%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[显示仓库中的页面1、把文件放在**.github.io仓库2、在文件路径前面加http://htmlpreview.github.io/?然后访问，如： http://htmlpreview.github.io/?https://github.com/**/example/index.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu笔记]]></title>
    <url>%2F2017%2F12%2F13%2FUbuntu%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[系统操作：1.在图形化界面下获取最高权限 sudo nautilus2.显示/隐藏文件 Ctrl+hnpm:1.在使用npm下载包的时候出现无权限修改文件问题 在npm前面加上sudo2017-09-25]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电梯模拟程序]]></title>
    <url>%2F2017%2F11%2F27%2F%E7%94%B5%E6%A2%AF%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[whim今天在等电梯的时候，突然对电梯工作流程感兴趣，想写个电梯模拟小程序。先来占个坑，写个大致思路,等考完试再来完成 //这楼有20层int max_floor = 20; 楼层构造一个类12345678//楼层class floor &#123; private: //楼层 int floor = 0; //有人上1，还是下2,或是没人按电梯0 int uds = 0；&#125; 电梯构造一个类1234567891011121314//电梯class elevator &#123; private: int current_floor = 0; //三个状态，上升1，下降2，静止0 int uds = 0; public: //上升 void up(); //下降 void down(); //判断电梯上升还是下降 void UpDown(); &#125; 判断函数构造一个类因为有两个电梯，所以把判断函数拿出来单独构造一个类。123456//判断电梯哪个电梯去载人，上升还是下降class select &#123; public: //判断哪个电梯去载人 void which（）；&#125; 函数部分1234567891011121314151617void elevator::up()&#123; //用参数判断是否到达 int arrived = 0; for (int i = 1; i &lt;= 20; i++)&#123; //判断是否到达目的楼层(类之间引用问题) if(current_floor != floor.floor)&#123; current_floor++; &#125;else &#123; arrived = 1; continue; &#125; &#125; return arrived;&#125; 大致思路就先写到这，后续加上。 真的蛮好玩诶！]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>whim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+mysql实现小型web后台程序]]></title>
    <url>%2F2017%2F11%2F26%2Fnodejs-mysql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9E%8Bweb%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[项目地址主要实现功能：1.用户名密码登录2.增删改查管理员发布的网页数据 具体小功能：1.对用户名数据进行哈希加密（签名）2.强制登录页面（重定向）3.浏览器与服务器传输数据 图片界面丑了点，当时主要把后台功能搭起来，功能基本齐全，后面会把界面做起来登录界面 首页 发布信息 用户评价 项目结构： /server.js其功能是建服务器监听8080端口。具体代码： 1234567891011121314151617181920212223242526272829303132333435var server=express();server.listen(8080);//1.获取请求数据//get自带server.use(bodyParser.urlencoded());server.use(multerObj.any());//2.cookie、sessionserver.use(cookieParser());(function ()&#123; var keys=[]; for(var i=0;i&lt;100000;i++)&#123; keys[i]='a_'+Math.random(); &#125; server.use(cookieSession(&#123; name: 'sess_id', keys: keys, maxAge: 20*60*1000 //20min &#125;));&#125;)();//3.模板server.engine('html', consolidate.ejs);server.set('views', 'template');server.set('view engine', 'html');//4.routeserver.use('/', require('./route/web')());server.use('/admin/', require('./route/admin')());//5.default：staticserver.use(static('./static/'));console.log('server is running at port 8080...'); 各段代码作用如下：1.解析请求数据2.并发给请求方cookie，3.声明调用的模板4.路由功能，区分请求并转入相应界面5.处理静态文件请求 /libs/common.js该文件封装模板，其功能是将登录时的用户输入的用户名密码等数据用哈希算法加密（签名），让该数据不可见，避免他人获取用户名密码。代码如下： 1234567 MD5_SUFFIX: '*****',md5: function (str)&#123; var obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex'); 其中，MD5_SUFFIX加在数据后面，再进行md5加密，该MD5_SUFFIX是自定义的数据的 /route/index.js在服务器运行后，服务器一直监听8080端口，当有请求访问，首先对该用户的登录状态和请求进行判定，如果不是管理员，就重定向返回登录界面。如果想访问其他页面，也不行，重定向回登录界面。只有当既是管理员，请求访问的又是登录界面才对请求予以响应。 123456789//检查登录状态 router.use((req, res, next)=&gt;&#123; if(!req.session['admin_id'] &amp;&amp; req.url!='/login')&#123; //没有登录 //转向登录界面(重定向) res.redirect('/admin/login'); &#125;else&#123; next(); &#125; &#125;); 如果已确定是管理员，就再来判定其访问请求。 1234//根据不同http请求，转向不同页面router.use('/login', require('./login')());router.use('/banners', require('./banners')());router.use('/custom',require('./custom')()); /route/login.js那是怎么判断是否为管理员？ 当管理员登录时，后台就拿着页面获取的用户名密码和数据库的进行比对，成功就给浏览器发session，不成功就不发，判定管理员的时候就是看有没有session。为什么不直接不直接用用户名密码验证，而要再加一个session？ session可以理解为cookie的加强版，具有生存期，可以控制用户在一定时间内免登陆。若采用用户名密码验证，那每 退一次，就得输入一次密码，这在实际操作中是很不方便的。 12345if(data[0].password==password)&#123; //成功 req.session['admin_id']=data[0].ID; res.redirect('/admin/'); &#125; route和template登录后，就对数据进行操作。route和template分别是存放js和静态文件的文件夹，文件夹内的js文件实现的功能相似，都是将页面和数据库连接起来，对数据进行增删改查的操作。就banners页面来说，其具体代码如下： 12//连接数据库var db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '***', database: 'learner'&#125;); 修改banner数据 1234567891011121314151617db.query(`SELECT * FROM banner_table WHERE id=$&#123;req.query.id&#125;`, (err, data)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else if(data.length==0)&#123; res.status(404).send('data not found').end(); &#125;else&#123; db.query('SELECT * FROM banner_table', (err, banners)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else&#123; res.render('admin/banners.ejs', &#123;banners, mod_data: data[0]&#125;); &#125; &#125;); &#125;&#125;); 其他数据操作功能同理]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm重新安装模块]]></title>
    <url>%2F2017%2F11%2F26%2Fnpm%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[npm删除模块，重新安装错误经过 使用hexo模块的时候，不小心将已经配置好的blog文件删除。在网上查找资料，运行npm cache clean –force，出现错误（不能使用hexo命令）。然后我就准备重装hexo，把usr/bin和local里hexo相关文件删除，用npm重新下载hexo，但还是和之前一样出错 解决 需要删除hexo相关文件和packagejson里的依赖，再重新下载hexo，就可以使用了 具体位置（linux环境）：/home/zaizizaizai/.npm-global/bin和/home/zaizizaizai/.npm-global/lib 补充：此路径为隐藏目录，在home区需要按快捷键ctrl+h显示隐藏文件，或者通过命令行进行操作]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应网页设计]]></title>
    <url>%2F2017%2F11%2F26%2F%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[点我转向原文章转译：pinocchio对于初入前端的学习者来说，设计网页自适应不同分辨率的终端是比较难解决的一件事。自适应网页设计指的是可以自动识别屏幕宽度、并做出相应调整的网页设计。 以下是自适应网页设计的方法： 一、允许网页宽度自动调整 在网页代码的头部，加入viewport元标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device- width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 所有主流浏览器(IE9)都支持这个设置。对于老式浏览器（IE6、7、8），需要使用css3-mediaqueries.js。 二、不使用绝对宽度 若在头部加入了viewport元标签，网页会自动更具屏幕宽度调整布局，所以不能使用具有绝对宽度的元素。 即css代码不能制定像素宽度 width:xxx px; 只能使用百分比宽度 width: xx%; 或者 width:auto; 三、相对大小的字体 字体也不能使用绝对大小（px），而只能使用相对大小（em）。 123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 123 h1 &#123; font-size: 1.5em; &#125; 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 123 small &#123; font-size: 0.875em; &#125; 四、流动布局（fluid grid） “流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 123456789.main &#123; float: right; width: 70%;&#125;.leftBar &#123; float: left; width: 25%;&#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向 overflow（溢出），避免了水平滚动条的出现。 五、选择加载css “自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 400px)" href="tinyScreen.css" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 123 &lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 400px) and (max-device-width: 600px)" href="smallScreen.css" /&gt; 如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 1 @import url("tinyScreen.css") screen and (max-device-width: 400px); 六、CSS的@media规则 同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 12345678910 @media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 七、图片的自适应（fluid image） 除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： img { max-width: 100%;} 这行代码对于大多数嵌入网页的视频也有效，所以可以写成： img, object { max-width: 100%;} 老版本的IE不支持max-width，所以只好写成： img { width: 100%; } 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： img { -ms-interpolation-mode: bicubic; } 或者，Ethan Marcotte的imgSizer.js。 1234 addLoadEvent(function() &#123; var imgs = document.getElementById("content").getElementsByTagName("img"); imgSizer.collate(imgs); &#125;);]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>转载</tag>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博客评论说明由于多说、跟帖等评论插件都倒了，就转向了友言。结果友言服务器是国外的，得翻墙才能用。就转向了畅言，可是这搜狐畅言得用域名（我怕还没来的及买域名了-_-）。最后还是回到大爱的git了。过程：多说、跟帖–&gt;友言–&gt;畅言–&gt;gitment 2017-11-23]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>博客说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解MongoDB]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MongoDB%2F</url>
    <content type="text"><![CDATA[这是在我看完《深入理解MongoDB》后，按照自己的理解记录下来的笔记，初次接触，若有错误，敬请指出，感谢！ 一.概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB操作模式：应用程序&lt;=&gt;mongos&lt;=&gt;集群 二.理解分片1.什么是分片（sharding）？分片（sharding）是MongoDB用来将大型集合分割到不同服务器上采用的方法。这样做是为实现3个目标：让集群“不可见”让应用程序知道要执行任何“增删改查”操作只需要发送请求给MongoDB这一个对象就行了，剩下的事就交给它了，不需要区分交给那个服务器，简化了应用程序端操作指令。在MongoDB中具体连接客户端与服务器端的就是叫做mongos的专有路由进程，mongos可以比喻为一个秘书，转发客户端的请求，和服务器端的响应。保证集群总是可以读写一个大的集合分为多个分片（shard），当其中一个进程/服务器出现问题，由运行在其他分区的其他副本接替换掉的部分继续工作。使集群易于扩展将大的集群分割为多个小的分区，当需要资源的时候，只需要添加小的空间。 2.分配数据sharding操作后得到分片（shard）是集群中负责数据某一子集的一台或多台服务器。换言之，一个分片包含数据的某个子集。例如一个集群包含1000份代表网站注册用户文档，其中一个分片就可能包含200份。若一个分片包含多个服务器，则每个服务器拥有一份完整的数据副本。 一分片一区间分配数据最简单的方法就是让一分片负责一区间的数据。假设有四个分片，依次对应[“a”,”f”),[“f”,”n”),[“n”,”t”),[“t”,”{“)区间，{是ASCII码表中字母z后面的字符。许多用户用首字母在范围[“a”,”f”)中的名字来注册，就导致分片1较大，我们可以调整区间使分片1对应的区间缩小，从而让分片均衡。但当分片1和分片2过载时，就不太好处理。假设分片1和分片2各有500G数据，分片3和分片4各有300G数据，此时就需要分片1转移100G数据到分片2，接着从分片2转移200G数据到分片3，最后分片3转移100G数据到分片4，从而使每个分片都具有400G数据，达到均衡。这还只是4个分片，执行这个操作一共移动了400G数据。当考虑到所有分片，可想需要移动的数据量是很大的。 一分片多区间重新来考虑上面的情况，此时是一分片多区间。我们可以把分片1和分片2都划分为两个区间，分片1分别对应包含400G数据的[“a”,”d”)区间和包含100G数据的[“d”,”f”)区间，分片2分别对应包含400G数据[“f”,”j”)区间和100G数据[“j”,”n”)区间。我们就可以把分片1中的[“d”,”f”)区间的数据直接移动到分片3，把分片2中的[“,j”,”n”)区间的数据直接移动到分片4，相比上一种情况，只需要移动200G数据。添加新的分片也具有同样的优势——减少数据转移量。 创建块一个区间的数据成为一个数据块（也叫块，chunk），块默认大小为200MB（兼顾可移动性和最小开销），当一个块的区间一分为二是，就变成两个块了。当提到块出不得不说片键了，如下所示{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}{“username”:”zaizizaizai”,”age”:16}如果我们选择age字段作为片键病得到一个块区间[20,30），则得到的块为：{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}可以把片键理解为一个选择器（标签），也可理解为属性，即挑选符合条件的数据，在这里不仅局限于把age作为片键，username也可以作为片键，且片键值不可修改。随着数据的增加，当一个块变大，MongoDB会自动将其分割为2个小块。若分片间数据比例失衡，MongoDB会迁移块其他分片（由叫做平衡器的进程执行），以达到分片间数据比例总是平衡的状态。同时平衡器会忽略微小的不平衡，否则会导致恶性循环。 三.建立集群选择片键片键的选择很重要，因为这关系到读操作的速度。以下介绍集中片键的几个常见反例，以便更好理解片键选择。小基数片键假设我们有3个分片，我们需要选择片键。前后端编程开发常见的建站就需要对数据分类，有用户的数据、管理员的数据、网页参数的数据，那为了方便理解和区分，就选择用户、管理员、网页参数3个片键。虽然管理员数据比较小，但用户的数据会一直增加，增加到一定程度后，MongoDB也不能分割分片里的块了，最终磁盘空间被耗尽。由于片键值数量有限，后来，就会得到一个又大又无法移动，还不能分割的块，这对数据管理造成极大的不方便。升序片键对大部分应用程序而言，新数据被访问的次数总是多于老数据，所以人们会尝试诸如时间戳或者objectID一类的字段作为片键。比如，社交软件上的发动态，每条动态包含消息、地点、时间，我们以时间段来分片。从一个数据块开始，随着时间推移，一个块满了，裂变为两个块，时间点继续增加，这个片键创造了一个单一且不可分散的热点。动态被发出，该时间点MongoDB需要对该时间点对应的块进行写操作，而当大量的动态在同一时间发出，MongoDB来不及对块进行写操作，就会造成堵塞，使应用程序瘫痪。随机片键为了避免以上的热点片键，有人选择取随机的字段来分片。采用这种字段开始还不错，但随着数据量的增加，它会变得越来越慢。现在采用随机片键，已经得到一组均匀分布于各分片的数据块。假设分片上的一个块填满并分裂了，配置服务器注意到分片2比分片1多10个块，为了抹平差距，MongoDB就将分片2中的随机5个块（块的数据量的大小不确定）经由内存发送给分片1。随着数据量的增加，这5个随机的块的数据量会很大，应发大量的磁盘IO，致使数据库变慢。好片键准升序键加搜索键快速起步 若想尽快上手，可用Github上的mongos-snippets，其中有个simple-setup.py能自动地启动、配置和生成一个集群，它需要MongoDB的Python驱动。 安装MongoDB的Python驱动sudo easy_install pymongo下载mongos-snippets库并执行以下操作python sharding/simple-setup.py –path=绝对路径 simple-setup.py会启动一个mongos进程，地址为localhost://27017 2017.10.29 pinocchio]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全概略]]></title>
    <url>%2F2017%2F11%2F23%2Fweb%E5%AE%89%E5%85%A8%E6%A6%82%E7%95%A5%2F</url>
    <content type="text"><![CDATA[声明：本文章是在看《白帽子讲web安全》时所做的记录，以供复习攻击方式重点：sql注入 xss 技巧：1.数据库里的登录ID和昵称分开 一.安全世界观1.安全是一个持续过程2.安全三要素2.1机密性2.2完整性2.3可用性 3.安全评估 资产等级划分-&gt;威胁分析-&gt;风险分析-&gt;确认解决方案 3.1资产等级划分3.2威胁分析3.3风险分析3.4确认解决方案 4.白帽子兵法4.1Secure By Default原则4.1.1黑名单、白名单4.1.2最小权限原则4.1.3纵深防御原则4.1.4数据与代码分开原则4.1.5不可预测性原则 二.浏览器安全2.1同源策略2.2浏览器沙箱更新中…… 2017.11.18]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网络安全</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
</search>
