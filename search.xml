<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[clox编译器]]></title>
    <url>%2F2019%2F07%2F19%2Fclox_compiler%2F</url>
    <content type="text"><![CDATA[clox(持续更新中，目前到scanner)clox是由Bob Nystrom基于ｃ编写的编译器，最终解释结果编译成字节码，通过编写学习，可以了解编译器的基本原理主流程主要分为三步： 扫描 编译 执行(虚拟机) github代码库:zaizizaizai 推荐：原文教程请戳这里 极度推荐项目库：project-based-learning 目录结构 文件说明 流程 clox编译器整个代码逻辑流程 执行减法(3-1)的流程 结构 chunk结构 ValueArray结构 VM结构 函数以及参数说明 reallocate() OP_CONSTANT 文件说明 文件名 功能 common 通用引用库文件 memory 数组增删的逻辑，基础的内存管理 chunk chunk节点：结构定义,属性的更改;储存源代码 value 常量池，常量类型结构的定义及实现 debug 反汇编提示信息 main 主函数 vm 虚拟机－指令执行器;解释执行源代码 compiler 编译 scanner 扫描代码段 流程clox编译器整个代码逻辑流程 执行减法的流程 结构chunk结构1234567typedef struct &#123; int count; //实际使用大小 int capacity; //分配数组的容量 uint8_t* code; //指令 int* lines; //线信息 ValueArray constants; //常量列表&#125; Chunk; 分配具有更多容量的新数组 将现有元素从旧数组复制到新数组 更新capacity 删除旧数组 更新code指向新数组 既有空间，也可将元素储存在新数组中 更新cout ValueArray结构12345typedef struct&#123; int capacity; //容量 int count; //实际使用大小 Value* values; //数值&#125; ValueArray; VM结构1234typedef struct &#123; Chunk* chunk; uint8_t* ip; //指令指针(PC机中的程序计数器)&#125; VM; 函数以及参数说明reallocate函数传递两个参数给reallocate()控制要实现的操作 oldsize newSize 操作 0 非0 分配新块 非0 0 重置为空 非0 &lt; oldSize 缩小现有分配 非0 &gt; oldSize 增加现有分配 OP_CONSTANTOP_CONSTANT采用单字节操作数制定从块的常量数组加载哪个常量 文章顶部]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python核心(一)]]></title>
    <url>%2F2019%2F01%2F19%2Fpython%E6%A0%B8%E5%BF%83-%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[大海与生活]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%A4%A7%E6%B5%B7%E4%B8%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+wEv4tLIu2LkaiyIG/9QgnYRJtrlFnoweRQMH2XbccyynEhMsnGZe7GsZklGyFcjfReuJRPpxqn79rgHRVsQU38kuHR/TEb+V5VGkEEsT20OJ2vTZwaG73xrXzsF5LSCEffRFkYuIrFmQ2a/S0uP5oAgVrJcVjgbwXH/Z3Os+xM6KMlWb8e2mUpyRAjlTIoue4q/rs/2tBZnKW0qthKmqEK38kZYDWdSqFn4MWWUfeBdY3XoWEb0lqnes7HFH7nUs6goLsGDrASQ5//IZfcDGq0b7X/nCj3TQdA4DFl9EwhSHoumg81qWBqEEXJEwIcj3urb/q7r4mm0l8GDT+bEMe/RHgtmsI2gmTHyJsDL6Mt8X6CPPrMphzORNfHC4k3FT3CUDoOUwCjEIgxWt1Rso7gOiGRxASv4Q=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX19coLXKLDzF7V0TeoqK1aForrSBjmx/NuqlHPoHZkBCWDuagI08q+/QMKzLBH4/ndYOE7IB+QxXPCKz5mbhHM9x46RJW9M67/PlSBG617iWyzaGT0AlQv3QOxmVzFks8cLbWXy/2qmI+LV3g10+j+QvDIS0IMpIkFWYA9AiPuBoK1WYDfgpF37LNFubCOqhmZtZ6h/cPBkdpAPyxn9Xoxg1V3X1N8BPYVLpNPHdzLGuBTT1+JeMt9VzmEBFvWizNm4qJb1yMwU610/17gaa9yFsxKD+CoTzgVXzlMDFUtPnCIrvmowiZqWQr6w/R3ohEM7zqRzbq7kMrgHHKBPr+tIThWjHEeAK1jScb0l/J9jHertUMOQws5PiaX3+hM/qYs/jls8UCYh3R4oVSJu+S9KKK2/VzXc9CX/68CZ/l/1jcjrSE55HsMSHGpMNGuOxH4fGoXP5lRDfC2z9FNMg5RcsEMWHZVqch9yEGq8I+lwhkQ+ELKm2cZ5GG4O8bQHIR+4AXCfKipclIw==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于自信]]></title>
    <url>%2F2018%2F08%2F04%2F%E5%85%B3%E4%BA%8E%E8%87%AA%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致未来的你]]></title>
    <url>%2F2018%2F07%2F07%2F%E8%87%B4%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1/QHh8Dwx7WCp6LaZRjwgKwo2n7LMNnYOTOLL674WTNJjJ+pR3u3OHQBIH81pmXRMmwmQc5k0PAG+uFVPz72Xi0V4UjGgEw93Z2kG1VAlv28m0LFMVHWCZwC6JPaZZrd57K+tVE+AsTwNCuAhurTdv5ujOoDimPaFAvtQVexC7myEa0qbFxCEgrJHV81Uq1nM2w1peTJJ9tuXGczbLjxktPLL5rz2dxq9e/LE+4rsWltm2xcYubY/tf7Xs0+K85G7tZVeThBy4BrRRdTvi0CPiEoyRVFRm87lHaFncPielwAjhDF8uoKDC87/3kHZE5ZjF8BPEcF3NLgSg3ukDymemcz+fFS1YCduNmZ6PT32nxRkNiH7fqYYnTGiA8PCC13Z823dGwagOuT7MPsITQJtqa3UIqrGveEYu0tVHsefaclNrEeXadHXfzUNIN9OTq+ORQAowk45fMZxn8Cr9DrHKkxLjxOoUQgYjoHITmfaATu709i2hxnQiI2CWnBBUIhYjaJNIaG4wBFp3soUKZd2gKBYxRPJmPQmOTiPUEbXN/mpBRktFAzV245fT7z2O73wSgQNQyt/XQFX9GRb25dr0FYuuwxVRu68kgkcS3bdpx5tg+BBQlmgAa+IofRrp8NQ9W5cJzkT6hUDq8023qJ3dK5RoQjj2rBAHayfeQZloIIgV9UcRbxxtCWezWUEt1346akP45GI/A3PkXcttdld/Z/neGCG6Rm5lNJ8ZqIN3DYprovjqF7HmyxbxJXpA6KB1A8kRyDIN1ARsdiydQxk76+xI9BycF1bpSaqNrw/qlWocRFGKUoubO+gZ4+7PWvlhgprKyiEKwq/19Gcv9DSYXeh2MDkAlke5dslZJdBryvxlXhRI5Qj5TyROEgaf7A4UpbXBWRancqpjnrXeMwKF0qg3ya1uXK/VtMHXZ4U4+Hct9xIQ/XZikxY79b5oHEip4MvlXZK5VHoRoNPiLsNt33MLXNelClB5wg15Mn0/6U3YLlFfIruDkf/9Ls8MoJqnBRsoV1+E1SUiR1ZaYiicSVL8v7Yj1e39i5jVH4gLabjrBQjt/LrtczEiCy7u9nP6XNL0FTTCflGK+CWSHuhNU584Fm9BPgmO93J9WlLcTgANCv33r//rspuGILu8Pqtm8IK4ve3NPcBtIYrUyglKyAwku189giLn6KUIEL5OL6a/1CGqrFsbnZJv5Wd07WAXJkMxUuneWpj/Jev/s3DRFvD3eTcD13xFHcZ++Wj8VfJNEdnCEAGXLb1pMbpJMApK7mqNYb24YUz+cTSqdnbG7l2X6CqpJCdcKxQNVJNXi99gQgr76JlOahTl0irApOG/9QaPFYeojO0qJCjDUXQNxkLYwRkK5oumh6KLtxLueN6ZuZ/Nc8wl8mZoVD3nsl+vXdg0oLbWDSqlTIx/wFgEv/UuYpsv3a1KuiZQjEDMWrPRrcgBAoKpL9hvZieJOc3AAPg9tzRrfnrYB+5rwLCwimU+U+ezUx1JHCFFoyQUxnT6DkQ8va1cJkqDTGcU/YLBWoaw0UBz+0qSNuuBlHOKk4kzgqsdcjjewdzjebZx5GqhaYJaMKo5KMQG91iuItyEgAWj934uFb75+PkLKAjoWh6VO4i+YB/NXmwrLf9vovVnLiViIi0UsKgIH1uUu2fjUch0AgNEyoxZFHUDtw0GUkKl25JPs39t4xdAjDR1UY4GLAAb226GgzgaUll+eutP+nl8dGP9RaI640WZ2Ga9cw2hvXNwPo9tnn/Cg5Su+lARJ38jnc+gCy7DGWqu+kwr5LnQh3zpGN32DjvJ+W7ggO1qe1Ay791+JeP4TJl7fBmJD3qXdLaqGsshAOGu5g9du4mDKdQ11Svn395HTeTy4m/rVsxfXGxZTbWrcZhnb4KIbYQZpEoZwcnprjfipvGwhGNPylH9T6E9HvhWMmKxb03nHx+wBIRU=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做饭]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%81%9A%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX18vkcwzaknhFVEM09XbSLq9sg2rOoT3ZmeREGQqmCeurwxtrEg2unepj9HFfduFSjdpWQVKt1S72Kr4nAk62JCY4BaBHAdEabun8SSMXX1SlzGPMSpvlTnVPmm9ZINvyjDuSA7l+HHJ7eHunbPFhv854V08DsafiE6dW8a2+9k0s3vEyGgyZoZZTTJoEUBvauZWTnSUAIVrVG7zM3nFrQzM+nufsRkm92S2snrcT9iLdGszgLLcxxUsFjVa604UtnGewzUfCh5NwZb7BApMtpW4STFjd274PbPWFIjjKnlgMjPMIIh5669gWiN1Dj+52j8K5FeB/P55tU8/2E3MWNIlA6RTWud77SvXBO1xoiWyo+uLbIFXCwbKQKXRwgk9+u7Z9uUCdm+EOpBXSng1hNWZqLgfStOrnXhndYlHfjMcxLa23BX6a4jznHeLPlv12rQKf0I7M6GTFkMf3ew/+kMU0mjvVY/VXHtZYKaf8V2mFkBj4mpVQDkqdT7f9jhVbWy/+pg1UuX85WK6/tFUGQY2WfX6hQTY2zD50ziQ1CxItHVUY1GHH9p/fC0Hhut0qzDSXOVsWd7dk/QoYpoMMt+udfoK2UauyEd2gg1x4rIPMpkr2aDVpWcEIoPcWLWFBX/ELwSNk7XmzE2w/1xJ1W3D/uNGp0ITlSAoAYQ3ys2GzhTIpvIQXoWP3TNIcW+D+XMf5zVDmEFMUtU3S0TpBxwYG6CqohviKXfptiEbHhQ2RSrM+dfSGAf8NLRWf2eOku8QIysR1wmVNVw22MYrDo4xJbG26oKHMz3CV9D8WbVN76IaRGW1WXQs]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来的自己]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[姨爹]]></title>
    <url>%2F2018%2F06%2F17%2F%E5%A7%A8%E7%88%B9%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1/JZBoWZAUlCrMeA/h+8PW1W9JdWlBFxYfWLctnnfdrY50QObZbus8DKwp0q85L/mNDaS08iCPuEuaVpt3g5zkMY5oe3eGAVGnbbs/MpEwok3SlKsocH57YgbMnrC0AeJYsnNTIRzvkRe9idVLlVktMcT2W4ZRBSay1i6O7knRsJHw0furL17dM/Xz+50Ff+QWT/fu5pk1o+Uax+eFCq/gGbfXgqKMyYaWoKo29JWAi91O5hs/YhFIpuDiV4xZLtiV1AqQHqWAygVKllkm68X3YbfkXdDxHSO+6Ihfp6rZSKkywqCb3sKzte3xKHLRfobF+bzwL9gs3WA==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[office online]]></title>
    <url>%2F2018%2F06%2F10%2Foffice-online%2F</url>
    <content type="text"></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.06.04]]></title>
    <url>%2F2018%2F06%2F06%2F2018-06-04%2F</url>
    <content type="text"><![CDATA[看山是山，看山不是山，看山还是山，为什么越看越伤心呢？]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天堂电影院]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%A4%A9%E5%A0%82%E7%94%B5%E5%BD%B1%E9%99%A2%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1/E1Im2MxQKg0vdI/40wXMmN/Z3dUr3pSdrLcLf06CpnlCFvRmjsLAYO7slpp9W0YC4g2FmDYfe9XxZ2phxwV8BMZaii7QcPbynctkwEksnfFv25n3DIRxpWBlnGkx9PIUPGvLTmz2pcx5dcxjbSgFWhU+3ozQr2wSLJnVrRPQZEkeSGeUqCMy/dkuuacRmywZUi/9TrWZNBeRqrNzz7WEWCIceO2rDR7sCTaxcArigchPEmjt5yoHrp0skmCXBH2iBhOe2srGV3ibSkwgwFm5HL2EXqZegsFXClLJHlWi3h3GLXhTeakW2uf8E+arESqUxTDjxRzowZRvjVYrXXvptKs+/JKUs3WM+r1qXNFAZRGmRTC0Syb8J+v2ZoKgrtiqYNg24DO7qux17AZFoiOdrsczJnQc/uYs=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与姐姐]]></title>
    <url>%2F2018%2F05%2F21%2F%E4%B8%8E%E5%A7%90%E5%A7%90%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交流]]></title>
    <url>%2F2018%2F05%2F04%2F%E4%BA%A4%E6%B5%81%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX18u+SpkMwY7HKiVZdzMChizQmL3mDpf5BYaSLv5ctpQTd+pfkgnRpJKFn6vJ439tgRgxJGhbIpn7y8dikoFFkHijk65m6TQDCcf+X9UqJXvBTF1gAfI1sH0xjq3LpNr2tK0uJLCPhZMgttv8119yCJyIHLjMKDFsHhVuCgxziHf/fUBYtwKe5kARLMHUXGGR3ZZrV6zPOpNcL8H1qo6rxFn/O9t8VIGab829DL2xyD6Cuq9bwPEOQi4jiLBwWUXFeyk7xChm5lqwpfgI1Qd2YwmsQ/h5pybr/NPflMgjqtdOGBu3pyvXHbsUgwQEZgbVmnBhSadgUY0jCQv87dsWfBDXkyP89rLk4vyCfGJnOZNQLXLuPEBy0l5xl4j7CWNENdNDm2MsHUVtgv2yFvZXTW1ligCXtK5yj25qhselhnKR0Koh4U7nlZPQANJCt2sJCUskcZszmpjDw==]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.23]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-23%2F</url>
    <content type="text"><![CDATA[过了一会，青年人把右臂举起，把手抚上石碑，开口了： “法师认为，是法源寺的名字好呢，还是悯忠寺好？” 和尚对突如其来的问话，没有任何惊异。顺口就答了： “从对人的意义说，是法源寺好；从对鬼的意义说，是悯忠寺好；从对出家人的意义说，两个都好。” 青年人会心地一笑，法师也笑着。 “我觉得还是悯忠寺好，因为人早晚都要变成鬼。” “寺庙的用意并不完全为了超度死者，也是为了觉悟生者。” “但是悯忠寺盖的时候，却是为了超度死者。” “超度死者的目的，除了为了死者以外，也为了生者。唐太宗当年把阵亡的两千人，都埋在一起，又盖这座悯忠寺以慰亡魂，也未尝不是给生者看。”“对唐太宗说来，唐太宗杀了他弟弟元吉，又霸占了弟媳妇杨氏。后来，他把弟弟追封为巢刺王，把杨氏封为巢刺王妃。最妙的是，他把他跟弟媳妇奸生的儿子出继给死去的弟弟，而弟弟的五个儿子，却统统被他杀掉。照法师说来，这也是以慰亡魂，给生者看？” “也不能说不是。”和尚不以为奇。“在中国帝王中，像有唐太宗那么多优点的人很少，唐太宗许多优点都考第一，当然他也有考第一的缺点，他在父子兄弟之间，惭德太多。有些是逼得不做不行；有些却不该做他做了。做过以后，他的优点又来收场，我认为他在事情过后，收场收得意味很深。盖这悯忠寺，就是证明。他肯盖这悯忠寺，在我们出家人看来，是种善因。” “会不会是一种伪善？” “判定善的真伪，要从他的做出来的看。做出来的是善，我们就与人为善，认为那是善；如果他没做，只是他想去行善。说去行善，就都不算。我认为唐太宗做了，不管是后悔后做了、还是忏悔后做了、还是为了女人寡妇做了、还是为了收揽民心做了，不管是什么理由，他做了。你就很难说他是伪善。只能说他动机复杂、纯度不够而已。” “我所了解的善，跟法师不一样。谈到一个人的善，要追问到他本来的心迹，要看他心迹是不是为善。存心善，才算善，哪怕是转出恶果，仍旧无损于他的善行；相反的，存心恶，便算恶，尽管转出善果，仍旧不能不说是伪善；进一步说，不但存心恶如此，就便是存心不恶，但并没存心为善，转出善果，也不能说是善行；更进一步说，存心不善不恶，但若有心为善，转出的善果，也是不值得称道的，这就是俗话所说的‘有心为善，虽善不赏；无心为恶，虽恶不罚’。上面所说，重点是根本这个人要存心善，善是自然而然自内发出，而不是有心为善，有心为善是有目的的，跟善的本质有冲突，善的本质是没有别的目的的，善本身就是目的。至于无心为善，更不足道，只是碰巧有了善果而已，但比起存心为恶却反转出善果来的，当然也高明很多。天下最荒谬的事莫过于存心为恶，反而转出善果，这个作恶的人，反倒因此受人崇拜歌颂，这太不公道了！所以，唐太宗所作所为，是一种伪善。” “刚才我说过，判定善的真伪，要从一个人做出来的看，而不是想出来的说出来的看。这个标准，也许不理想，可是它很客观。你口口声声要问一个人本来的心迹，你悬格太高了，人是多么复杂的动物，他的心迹又多么复杂，人的心迹，不是那么单纯的，也不是非善即恶的，事实上，它是善恶混合的、善恶共处的，有好的、有坏的、有明的、有暗的、有高的、有低的、有为人的、有为我的。而这些好坏明暗高低人我的对立，在一个人心迹里，也不一定是对立状态，而是混成一团状态，连他自己也弄不太清楚。心迹既是这么不可捉摸的抽象标准，你怎么能用这种标准来评定他存心善、还是存心不善不恶、还是存心恶、还是有心为善呢？心迹状态是一团乱麻，是他本人和别人都难分得一清二楚的啊。所以，我的办法是回过头来，以做出来的做标准，来知人论世、来以实践检验真理。我的标准也许比较宽，宽得把你所指的存心善以外的三类——就是存心不善不恶、有心为善、甚至是存心恶的三类都包括进去了，只要这四类都有善行表现出来，不管是有意的无意的好意的恶意的，只要有善行，一律加以肯定。所以我才说，唐太宗肯盖这个悯忠寺，是种善因。” “法师真是佛心，喜欢与人为善，到了这样从宽录取的程度。” “宽是宽了一点，但也不是不讲究分寸。像我说唐太宗盖这个悯忠寺，是种善因，并不是做善行，这就是分寸。” “照法师这么说来，盖了这么个大庙都不算是善行，只算是善因，那么怎么才算是善行？” “这要看对谁来说。如果某甲有一两黄金，他出九钱盖庙，哪怕只能盖一砖一瓦，这是善行；如果某乙有十万两黄金，他出一千两盖了整个的庙，他的善行，比起来像善因，很难算是善行。” “所以唐太宗不算？” “唐太宗身为皇帝，当然不止是十万两的某乙，他盖悯忠寺，不能算是善行。何况，他有权力根本就不使盖悯忠寺的理由发生，那就是何必出兵打高丽？不打高丽，就不会死人，就无忠可悯，所以，唐太宗如根本不打高丽，那才算是他的善行。” “照法师这个因人而异的标准，我发现法师悬的格，简直比我还高。唐朝当时受到四边民族的压力，唐太宗不动手打别人，别人大了，就会打他，如今你法师竟用的是人类和平的标准、不杀不伐的佛教标准，来要求一个十九岁起兵、二十四岁灭群雄、二十九岁就君临天下的大人物，法师未免太苛求了。” “你说的不无道理，我悬格太高了。可是，大人物犯的错，都是大错。唐太宗若不是大人物，我也不会这么苛求了。因为，从历史上看，当时高丽并没有威胁到唐朝，高丽虽然欺负它南边的新罗，但对唐朝，还受唐朝的封、还对唐朝入贡，唐太宗打它没成功，盖悯忠寺回来，第二年高丽还遣使来谢罪、还送了唐太宗两个高丽美人。这些行为，都说明了你说的唐太宗不动手打别人，别人大了，就会打他的威胁性，至少对高丽来说，是担心得太过分。我认为唐太宗打高丽，主要的原因是他的‘天可汗’思想作祟，要君临天下，当然也就谈不到爱和平了。我承认，要求唐太宗那样雄才大略的皇帝不走武力征服别人的路线，那反倒不近人情了。” “这么说来，法师还是肯定唐太宗了？” “当然肯定，任何人做出来的善我都肯定，而不以人废善。至于想去行善、说去行善，那只是一念之善，并没有行，那是不算的。善和行善是两回事，善不行，不算是善。” “法师这样注意行、注意做、注意以实践检验真理，这种思想，跟孟子以至王阳明的，完全不一样。” “是不一样。孟子认为发善情就是善，所谓‘乃若其情，则可以谓善矣’；王阳明认为在内心就是善，所谓‘至善只是此心纯乎天理之极便是’，这些抽象的检定善的标准，我是不承认的。善必须要行，藏在心里是不行的。” “法师这种见解，我听了很奇怪，太不唯心了，佛教是讲唯心的。”青年人露出一点取笑的神气。 和尚好像有一点为难，想了一下，最后说： “真正的唯心是破除我执，释迦牟尼与何罗逻仙人辩道时说：‘若能除我及我执，一切尽舍，是名真解脱。’我执就是主观的心，善如果没行出来，只凭主观的心认为已经是善就善了，这是唯心的魔道，不是唯心的正道。唯心的正道是破除这种凭想凭说就算行了善的魔道。真正的唯心在告诉人什么是唯心的限度、什么是光凭唯心做不到的。比如说吃饭，必须吃，想吃和说吃并不算吃，一定要有吃的行为；善也是这类性质，善要有行为，没有行为的善才真是伪善。” “法师这一番话，我很佩服。只是最后免不掉有点奇怪，奇怪这些话，不像是一般佛门弟子的口气、不像是出家人的口气。我说这话，是佩服，不是挖苦，请法师别见怪。” 和尚笑起来，又合十为礼。然后伸出右手，向庙门外面指一指： “现在北京城都在过年，大年初二，外面正在赶热闹，而你这位年轻朋友居然有这么大的定力，不怕寂寞，一个人，到这冷清清的千年老庙来研究古碑龟趺，一看就不是凡品。” ——《北京法源寺》]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.20]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-20%2F</url>
    <content type="text"><![CDATA[我试着远离、忘记高中，也试着找回]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.08]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-08%2F</url>
    <content type="text"><![CDATA[Talk is cheap,show me code]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.06]]></title>
    <url>%2F2018%2F03%2F25%2F2018-03-06%2F</url>
    <content type="text"><![CDATA[人生不是百米赛跑，而是长途接力赛]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.03.05]]></title>
    <url>%2F2018%2F03%2F25%2F2018.03.05%2F</url>
    <content type="text"><![CDATA[软则柔，刚则折，刚柔并济，方圆之道]]></content>
      <categories>
        <category>人言</category>
      </categories>
      <tags>
        <tag>人言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学长考研]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%AD%A6%E9%95%BF%E8%80%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1/GQMD7tYTQVuPBYjcfUB9Y1ptGmVnSCiD48E6m0FDT1whnQ0F9r1hiR2oHkEpAP/YodWbeOnnbxkxwQPA/APwzl+QVnnvWK6mFcSfCL7QxfmOC1HSeV+T5YmTrqz4avdvcfb3lCuR0eYNZpr1+C0CxSSaayfC8pPT6zjHyUSQxy4aeCI+hOXbUWMj5ay9vyrtcIMiPE397q+G+KstluE+M4R/sCvMpM3jYIqxHeyRX5p5ZNkxaULEn9rbJvCyRgWTyYwbayQAEl30qfA2qsb82/qvCZATb1nEavOl/Z307XWODH/o3P17xhKqAOBjLR6nBk53Vsm3YnH1jF5m8wW7Eim/UHbwAjtclswqXCzqs/Uvxb+GyWWShjgOrsS3Gw7KM8m3zETXivKHInJEqAQwEEERrjW72RZVCj60/hN32Qaamcl9GgnARKnf2AGrNHfIlh/FEzfi8KjEdSwUxLE90FIfrS/52SHPX1Bhzq43XX6l34YDuEz8Ear3yk+03LDRMCDyK8W0KWYdGJPPXzo/6oRTs8mOLsb4vmcp9dcpfwVC+vmKpi8Rg1YgREp5RmkDcCS36xyNqnzElwHx16y4cBnsy821YIy1A40e1pZvh9/Wcp2KNkRHgl6gwe4J1Ao0/eCRpwRTUJY4tMZt1G0MGt9sI8dSj/HIJ1P5ndw7FuIyUvl80jfQZIGlG19mNIEy4mSFZWiMYZWLjrFoyGvWBCkEXJ+qKEYAlUgEQmvRTAL68lWX6l7InTh7JTAxx5GoNm+/btOTvNUpxs4nRtV2V+mx13tunrFGnGgzOwhxG47hH7URveTJnImPaUWp6p+NXo33xx4QfVNGgEboGKPirYayPv2IztJBvbD8MzppyXCCypvrLUgmX]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[途中加油]]></title>
    <url>%2F2018%2F03%2F25%2F%E9%80%94%E4%B8%AD%E5%8A%A0%E6%B2%B9%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[担子]]></title>
    <url>%2F2018%2F03%2F25%2F%E6%8B%85%E5%AD%90%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX187WYxyobqBKo4x3qsiZO1bJwttISrK6gXx8IVBkBm6KtG88KwlmGtyeDrzWaYpS3axVLbx9d+b6lJNziS+wOZbKnY3xKO0gmUDIzAjwHxndOHs42z2NZgY7v5FtXciGHKttjr0T72HJXb9t8cMJYQNdewki6TvPfUhIaOgi084OCiK1wLyb79yDKpw2Air+mPwZAOl874LOLY/0jTCDh/+7dm23kpNaY0sImVmxhocrnuxwLo1vkEwZJFZxBm4WlY9bik2FJEFuCsFojdItSm4fJ/CHXiuZqEiGK6JGAiBKN4Jd1pVBVfvBToQYewrnMAfvpgtMuQBDEaZq2FaFHJG+G5CoUUUVxMDN1ZUN1eCsctgAS9kR+gRNWBupF2W0xfIh7rhsx32/GaI+Bo4TbKlXwMu6ImrlZk=]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出node读书笔记]]></title>
    <url>%2F2018%2F03%2F12%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnode%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ES6]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%AD%A6%E4%B9%A0ES6%2F</url>
    <content type="text"><![CDATA[兼容性 ES6(ES2015)——IE10+ Chrome FireFox 移动端 Node.js 如何兼容老版本？(编译、转译) 1、在线转换(用户每次打开页面需重新转换，费时) 在线转换有很多工具，在这里以babel为例，在线转换只需要在加上browser.js就行，如下： 12345&lt;head&gt;...省略&lt;script src="browser.js" charset="utf-8"&gt;&lt;/script&gt;&lt;script type="type/babel"&gt;&lt;/head&gt; 2、提前编译(babel/browser.js) ES6变化内容 1、变量 2、箭头函数 3、函数的参数 4、数组方法 5、字符串 6、Promise(串行化的数据请求、异步交互) 7、generator(将同步操作拆为异步操作) 8、JSON 9、面向对象 10、解构赋值 1、变量var存在的问题 可重复声明 123int a = 12;int a = 5;console.log(a); //5 无法限制修改也可以说无常量，会导致数据变动，出现问题但程序无报错。 无块级作用域var是函数作用域，导致块外面也可访问块内的数据。 1234&#123; var a = 3;&#125;console.log(a); //3 let、const性质 不可重复声明 123let a = 5;let a = 3;//报错，不可重复声明 123const a = 5;const a = 3;//报错，不可重复声明 123let a = 5;const a = 3;//报错，不可重复声明 let-变量，const-常量 123let a = 5;a =3;console.log(a); //3 块级作用域有什么用？ 经典问题： 123for(var i = 0; i &lt; 5; i++)&#123; console.log(i); //5,5,5,5,5&#125; 原始解决方法 用函数包起来——闭包 12345for (var i = 0; i&lt; 5; i++)&#123; (function (i)&#123; console.log(i); &#125;)(i); //0,1,2,3,4&#125; let解决 123for(let i = 0; i &lt; 5; i++)&#123; console.log(i); //0,1,2,3,4&#125; 2、箭头函数(方便) 区别 1234567//ES5function show()&#123; //...&#125;//ES6() =&gt; &#123;&#125; 1234567//ES5let show = function show(a,b)&#123; //...&#125;//ES6let show = (a,b) =&gt; &#123;&#125; 要点 如果只有一个参数，可省略() 如果只有一个return，可省略{} 以下例子，可说明两要点 12345678910111213141516171819202122 //ES5 let show = function(a)&#123; return a*2; &#125; //简写 let show = a =&gt; &#123; retuen a*2; &#125; //进一步简写 let show = a =&gt; a*2; ``` # # 7、generator(生成器)### 概念* 普通函数——一路到底 function show(){ alert(‘a’); alert(‘b’);} show()12* generator——中间能暂停(踹一脚走一步) function *show(){ alert(‘a’); yield; //放弃 alert(&apos;b&apos;); } let genObj = show(); genObj.next(); // agenObj.next(); // b12* generator原理 //以上一段代码为例function show_1(){ alert(‘a’);} function show_2(){ alert(‘b’);} genObj.next(); // show_1genObj.next(); // show_2123456789101112131415161718192021* yield* 应用场景 请求数据# 8、Json* 1、JSON对象 + JSON.stringify + Json.parse * 2、简写 + 名字一样 ```javascript let a = 2; let b = 5; let json = &#123;a, b, c: 6&#125;; //&#123;2,5,6&#125; 方法 1234567show function()&#123; //&#125;show ()&#123; //&#125; 3、json的标准写法 1.只能用双引号 2.所有名字都必须用引号包起来 {a: 12, b: 15} × {‘a’: 12, ‘b’: 15} × {“a”: 12, “b”: 15} √ 9、面向对象应用——React React特点 1、组件化2、强依赖于JSX=babel=browser.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;学习react-组件&lt;/title&gt; &lt;script src="react.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="react-dom.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="browser.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; class Item extends React.Component( constructor(...args)&#123; super(...args); &#125; render()&#123; return &lt;li&gt;&#123;this.props.str&#125;&lt;/li&gt;; &#125; ) class List extends React.Component( constructor(params) &#123; super(params); &#125; render()&#123; // let aItems=[]; // for(let i = 0; i &lt; this.props.arr.length; i++)&#123; // aItems.push(&lt;Item str = &#123;this.props.arr[i]&lt;/Item&gt;&#125;&gt;); // &#125; return &lt;ul&gt; &#123;this.props.arr.map(a =&gt; &lt;Item str = &#123;a&#125;&gt;&lt;/Item&gt;)&#125; &lt;/ul&gt;; &#125; ) window.onload = function()&#123; let oDiv = docum ent.getElementById('div1'); ReactDom.render( &lt;List arr=&#123;['123','abc','bxsa']&#125;&gt;&lt;/List&gt;, oDiv ); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="div1"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次网站解析]]></title>
    <url>%2F2018%2F03%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%AB%99%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言今天记起要选公选课，同学安利一个教务处app，打开一看发现界面和功能都挺不错的，突然有做教务处微信小程序版本的想法，第一想法就是去找官网api，可转眼一想，哪来的api？原作者说网站解析来的，于是开始第一次抓包过程。 1、去长大官网溜了一圈首先来到官网看了下 1.1、登录前 教务处登录页面 发送请求中的header 1.2、登陆后 1.3、测试 postman测试 一开始想到把请求数据拿到，再伪造不就行了吗？至于怎么发送、接受数据，后面再说嘛…结果转眼一想，这还有验证码，难道要把验证码都转发给客户端？我看到的教务处app中用户名和密码都是学号，不科学啊，难道他找到漏洞，把学校教务处数据爬下来了？我转向解析app 2、解析app app发送到服务器的数据 从截图中Request PostData这一栏中可以看到发送的数据，这个username(学号)没加密，password(密码)加密了，由于学号就是用户名和密码，我试着把密码用md5方法编码、URL编/解码…等一系列还有我没见过的编/解码方法，结果都不与password/原密码匹配，我猜应该加入了干扰字符吧，寻找编码方法失败。 但可以看到是发送到http://221.233.24.23/eams/login.action,就去这个网址看看。 3、 教学管理系统溜一圈3.1、登录前访问这个地址，有登录界面，这张图片是以错误的用户名密码登录时浏览器发送的数据 以错误的用户名密码登录时浏览器发送的数据 username是明文发送，password则加密了，可以看到也是发送了4个参数，这和app发送的请求参数相同，说明那个教务处app就是发送请求到这个教学管理系统的 3.2、登陆后 以正确的用户名密码登录时浏览器发送的数据 这里图片无法显示，图片内容就是与上一个图片内容类似，但就是没有post data，这是什么？没见过啊，为什么登陆成功不发送数据，登录错误还可以显示数据 留一个坑，不理解3.3、测试 结语]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎jade与ejs的区别与重点]]></title>
    <url>%2F2018%2F02%2F27%2F%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8Ejade%E4%B8%8Eejs%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E9%87%8D%E7%82%B9%2F</url>
    <content type="text"><![CDATA[一、模板引擎 //TODO 二、jade1、认识jade //TODO 2、基础语法2.1、根据缩进划分层级2.2、属性用()表示，用逗号分割 *style = [] *class = [] 2.3、内容123div xxx span xxx a(href="xxx")链接 2.4、渲染 jade.render(‘字符串’); jdde.renderFile(‘模板文件名’, 参数); 3、高级用法3.1原样输出123456789101112//1.jadehtml head body zaizi //转为对应html&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;zaizi&gt;&lt;/zaizi&gt; &lt;/body&gt; 从上面代码可以看出，原意是body的内容为zaizi，但实际转译把zaizi作为自定义标签。如何在标签里原样显示内容呢？如下: 加竖线|,原样输出 12345678910//1.jadehtml head body |zaizi //转为对应html&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;zaizi&lt;/body&gt; 此语法可用于在html代码中写js，例子： 12345678html head script | //js代码 | //js代码 body |zaizi |dog 以上情况满足写在html中js的需求，但每一行都需要加|，还是比较麻烦，更简单的方法是：在script后面加一个点.，例子： 在标签后加一个点.表示标签后的内容都原样输出 12345html head script. // js代码 body 若要文件结构更清楚，可以尝试引用外部js文件，但会增加http请求数，这里可以采用include，例子： include引用文件 12345html head script. include a.js body 3.2 使用变量12345678910111213141516171819//jade代码html head body div 我的名字: #&#123;name&#125; //js代码const jade = require('jade');const.log(jade.renderFile('`jade文件地址`', &#123;pretty: true, name: 'zaizi'&#125;));//编译效果&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;我的名字: zaizi&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>jade</tag>
        <tag>ejs</tag>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析Promise内部结构]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%89%96%E6%9E%90Promise%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 阅读本文需要对promise有一定了解，可阅读详解promise Promise标准解读 1.只有一个then方法，没有catch，race，all等方法，甚至没有构造函数 Promise标准中仅指定了Promise对象的`then`方法的行为，其他常见的方法/函数都没有指定，包括`catch`，`race`，`all`等常用方法，甚至也没有指定该乳环构造一个Promise对象，而且`then`也没有一般实现中(Q,$q等)所支持的第三个参数，一般成为onProgress 2.then方法返回一个新的Promise Promise的`then`方法返回一个新的Promise，而不是返回this，此处下文会有更多解释 12promise2 = promise1.then(alert);promise2 != promise1 //true 3.不同Promise的实现需要可以相互调用(interoperable) 4.Promise的初始状态为pending，它可以由此状态转换为fulfilled(也叫resolved)或者rejected，一旦状态确定，就不可以再转换为其他状态，状态确定的过程成为settle 5.更具体的标准 一步一步实现一个Promise 一步一步实现一个Promise 构造函数标准中并没由指定如何构造一个Promise对象，在此以实现Promise的通用方法来构造一个Promise对象，即ES6原生Promise里所使用的方法: 1234567//Promise构造函数接收一个executor函数，execuyor函数执行完同步或者异步操作后，调用它的两个参数resolve和rejectvar promise = new Promise(function(resolve, reject) &#123; /* 如果操作成功，调用resolve并传入value 如果操作失败，调用reject并传入reason */&#125;); 先实现构造函数的框架： 123456789function Promise(executor) &#123; var self = this; self.status = 'pending'; //Promise当前的状态 self.data = undefined; //Promise的值 self.onResolvedCallback = []; //Promise resolve时的回调函数 self.onRejectedCallback = []; //Promise reject时的回调函数 executor(resolve, reject); //执行executor并传入相应的参数&#125; 上面代码基本实现了Promise构造函数的主体，但还是有两个问题： 1.我们给executor函数传了两个参数：resolve和reject，这两个参数尚未定义 2.executor也有可能出错(throw)，此时，Promise应该被其throw出的值reject： 123new Promise(function(resolve, reject) &#123; throw 2;&#125;) 所以我们需要在构造函数里定义resolve和reject这两个函数： 12345678910111213141516171819202122function Promise(executor) &#123; var self = this; var self = this self.status = 'pending' // Promise当前的状态 self.data = undefined // Promise的值 self.onResolvedCallback = [] // Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面 self.onRejectedCallback = [] // Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面 function resolve(value) &#123; // TODO &#125; function reject(reson) &#123; // TODO &#125; try &#123; //try/catch捕捉错误 executor(resolve, reject); //执行executor &#125; catch(e) &#123; reject(e); &#125;&#125; 原文]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文置顶测试]]></title>
    <url>%2F2018%2F02%2F25%2F%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[使用方法在文章中添加top值，数值越大文章越靠前，如：12345title: 博文置顶测试date: 2018-02-25 17:09:16tags: [测试,博客]categories: 博客说明top: 3]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章密码测试]]></title>
    <url>%2F2018%2F02%2F25%2F%E6%96%87%E7%AB%A0%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1/N/CvOW9rHKcs1boHi2z2z17pwx7F/yen7/XdhDV4vuIWsH84IY29234fwzyMmLhJ+O6DXwpQ+wtST5bFZ8nCTJJdfcHA17G+WaJQCgBw885GHUDjR1USZqfrwYHiNtbS43f7TKu1bEOPFZcAT1BoPxJlHqO+zd5iv6hgnuCD1FR4v6SxDEefvA+F9I0hGEeXLFVMAMZaJwvYUvHkQFpk1+iuKPd1sY8j9YZpLnyOX+tg4b8v5jOHaAm8QwySc0sLXFHh8uND/SuVYYL5XgMYoEBNzgSnNQiwwJXVtDf9W+ypIuo1GxC7NQwegOFbSvDYoylTy/zrhwhPuSyIZhv7aAXjm95V7WWJ47+iz8Wp1msIP883/BMqI9snI/Lp201ui2jrKhrcwk7WjsVTG38uC9HB9v7HF9zy2mOL/3qXq1Q4s8xMiLlIhW3y1EjqmWiTO0waou8XDgWeO6X6cM82OAUrfToUAE9HgHfVeAZS+ORuvLLxHpgaKaEstY7STYYS4G566hez6k1CIWpWq6eUUL3STl8EhMxlRrQz84IUmfpk9SuBmihgNoKNgztxWeGxESs5Gzh+WsyblhqvleasvCDuoiKBfC3VD5OEdbbz1ktCyvnQNxy1+hEBSMOBCfTebzjLYluIwTagxnB9jWs/D7E34vnsqFiXaXawusBXldeDXH8yHjtxS7op4QkpDlwIzPqDyIKI78CMAUpaPE5EqK9Qfu3dH+smbwfGzxsAnqyM6ufgDO8y/Plkjseovbz9nLKcCamAtRllqHf2Mz9c5BcqxZceB6PI3cktEFnNUDUjoGIYGItr2]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[heroku上部署ss先来占个坑 之前在github上发现了一个在heroku上搭建shadowsocks的项目，自己试着搭建，发现极好用。此时原项目已被作者删除，重新找了一个。特点： 1、快速，youtube上4k视频无压力2、无限流量3、免费！免费！ github项目地址]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>heroku</tag>
        <tag>ss</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--深克隆]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E6%B7%B1%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[八、在JavaScript中如何实现一个深克隆 前言在要实现一个深克隆之前我们需要了解一下javascript中的基础类型. javascript基础类型 JavaScript原始类型:Undefined、Null、Boolean、Number、String、SymbolJavaScript引用类型:Object 1.浅克隆 浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存. 123456789101112131415161718// 浅克隆函数function shallowClone(o) &#123; const obj = &#123;&#125;; for ( let i in o) &#123; obj[i] = o[i]; &#125; return obj;&#125;// 被克隆对象const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = shallowClone(oldObj);console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // true 我们可以看到,很明显虽然oldObj.c.h被克隆了,但是它还与oldObj.c.h相等,这表明他们依然指向同一段堆内存,这就造成了如果对newObj.c.h进行修改,也会影响oldObj.c.h,这就不是一版好的克隆. 12newObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 'change' &#125; 我们改变了newObj.c.h.i的值,oldObj.c.h.i也被改变了,这就是浅克隆的问题所在. 当然有一个新的apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了. 2.深克隆2.1 JSON.parse方法前几年微博上流传着一个传说中最便捷实现深克隆的方法,JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串,这两个方法结合起来就能产生一个便捷的深克隆.1const newObj = JSON.parse(JSON.stringify(oldObj)); 我们依然用上一节的例子进行测试1234567891011const oldObj = &#123; a: 1, b: [ 'e', 'f', 'g' ], c: &#123; h: &#123; i: 2 &#125; &#125;&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.c.h, oldObj.c.h); // &#123; i: 2 &#125; &#123; i: 2 &#125;console.log(oldObj.c.h === newObj.c.h); // falsenewObj.c.h.i = 'change';console.log(newObj.c.h, oldObj.c.h); // &#123; i: 'change' &#125; &#123; i: 2 &#125; 果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了. 确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑. 1.他无法实现对函数 、RegExp等特殊对象的克隆 2.会抛弃对象的constructor,所有的构造函数会指向Object 3.对象有循环引用,会报错 主要的坑就是以上几点,我们一一测试下. 1234567891011121314151617181920212223242526272829// 构造函数function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');// 函数function say() &#123; console.log('hi');&#125;;const oldObj = &#123; a: say, b: new Array(1), c: new RegExp('ab+c', 'i'), d: Messi&#125;;const newObj = JSON.parse(JSON.stringify(oldObj));// 无法复制函数console.log(newObj.a, oldObj.a); // undefined [Function: say]// 稀疏数组复制错误console.log(newObj.b[0], oldObj.b[0]); // null undefined// 无法复制正则对象console.log(newObj.c, oldObj.c); // &#123;&#125; /ab+c/i// 构造函数指向错误console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person] 我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。 123456const oldObj = &#123;&#125;;oldObj.a = oldObj;const newObj = JSON.parse(JSON.stringify(oldObj));console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON 对象的循环引用会抛出错误. 2.2 构造一个深克隆函数我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的.(这个方法也会出现上一节提到的问题) 由于要面对不同的对象(正则、数组、Date等)要采用不同的处理方式，我们需要实现一个对象类型判断函数。 12345678910111213141516171819const isType = (obj, type) =&gt; &#123; if (typeof obj !== 'object') return false; const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case 'Array': flag = typeString === '[object Array]'; break; case 'Date': flag = typeString === '[object Date]'; break; case 'RegExp': flag = typeString === '[object RegExp]'; break; default: flag = false; &#125; return flag;&#125;; 这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略. 123const arr = Array.of(3, 4, 5, 2);console.log(isType(arr, 'Array')); // true 对于正则对象,我们在处理之前要先补充一点新知识. 我们需要通过正则的扩展了解到flags 属性 等等,因此我们需要实现一个提取flags的函数.1234567const getRegExp = re =&gt; &#123; var flags = ''; if (re.global) flags += 'g'; if (re.ignoreCase) flags += 'i'; if (re.multiline) flags += 'm'; return flags;&#125;; 做好了这些准备工作,我们就可以进行深克隆的实现了. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** deep clone* @param &#123;[type]&#125; parent object 需要进行克隆的对象* @return &#123;[type]&#125; 深克隆后的对象*/const clone = parent =&gt; &#123; // 维护两个储存循环引用的数组 const parents = []; const children = []; const _clone = parent =&gt; &#123; if (parent === null) return null; if (typeof parent !== 'object') return parent; let child, proto; if (isType(parent, 'Array')) &#123; // 对数组做特殊处理 child = []; &#125; else if (isType(parent, 'RegExp')) &#123; // 对正则对象做特殊处理 child = new RegExp(parent.source, getRegExp(parent)); if (parent.lastIndex) child.lastIndex = parent.lastIndex; &#125; else if (isType(parent, 'Date')) &#123; // 对Date对象做特殊处理 child = new Date(parent.getTime()); &#125; else &#123; // 处理对象原型 proto = Object.getPrototypeOf(parent); // 利用Object.create切断原型链 child = Object.create(proto); &#125; // 处理循环引用 const index = parents.indexOf(parent); if (index != -1) &#123; // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象 return children[index]; &#125; parents.push(parent); children.push(child); for (let i in parent) &#123; // 递归 child[i] = _clone(parent[i]); &#125; return child; &#125;; return _clone(parent);&#125;; 我们做一下测试123456789101112131415161718192021222324function person(pname) &#123; this.name = pname;&#125;const Messi = new person('Messi');function say() &#123; console.log('hi');&#125;const oldObj = &#123; a: say, c: new RegExp('ab+c', 'i'), d: Messi,&#125;;oldObj.b = oldObj;const newObj = clone(oldObj);console.log(newObj.a, oldObj.a); // [Function: say] [Function: say]console.log(newObj.b, oldObj.b); // &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125; &#123; a: [Function: say], c: /ab+c/i, d: person &#123; name: 'Messi' &#125;, b: [Circular] &#125;console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/iconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person] 当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--传递引用]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[七、传递引用 1.JavaScript中的基本类型传递一个我们经常遇到的问题：“JS中的值是按值传递，还是按引用传递呢？” 由于js中存在复杂类型和基本类型,对于基本类型而言,是按值传递的. 1234567var a = 1;function test(x) &#123; x = 10; console.log(x);&#125;test(a); // 10console.log(a); // 1 虽然在函数test中a被修改,并没有有影响到外部a的值,基本类型是按值传递的. 2.复杂类型按引用传递?我们将外部a作为一个对象传入test函数.12345678910var a = &#123; a: 1, b: 2&#125;;function test(x) &#123; x.a = 10; console.log(x);&#125;test(a); // &#123; a: 10, b: 2 &#125;console.log(a); // &#123; a: 10, b: 2 &#125; 可以看到,在函数体内被修改的a对象也同时影响到了外部的a对象,可见复杂类型是按引用传递的. 可是如果再做一个实验:12345678910var a = &#123; a: 1, b: 2&#125;;function test(x) &#123; x = 10; console.log(x);&#125;test(a); // 10console.log(a); // &#123; a: 1, b: 2 &#125; 外部的a并没有被修改,如果是按引用传递的话,由于共享同一个堆内存,a在外部也会表现为10才对.此时的复杂类型同时表现出了按值传递和按引用传递的特性. 3.按共享传递复杂类型之所以会产生这种特性,原因就是在传递过程中,对象a先产生了一个副本a,这个副本a并不是深克隆得到的副本a,副本a地址同样指向对象a指向的堆内存. 因此在函数体中修改x=10只是修改了副本a,a对象没有变化.但是如果修改了x.a=10是修改了两者指向的同一堆内存,此时对象a也会受到影响. 有人讲这种特性叫做传递引用,也有一种说法叫做按共享传递.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--this]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--this%2F</url>
    <content type="text"><![CDATA[五、this 1.什么决定了this的指向 this一直是JavaScript中十分玄乎的存在,很多人为了避开这个琢磨不透的东西,选择了尽量少得运用this,但是不可否认的是,正是因为this的存在才使得JavaScript拥有了更加灵活的特性,因此,搞清楚this是每一个JavaScript学习者的必修课. this之所以让人又爱又恨,正是因为它的指向让人琢磨不透,在进行详细讲解之前,我们要搞清楚一个大前提,this的指向不是在编写时确定的,而是在执行时确定的.123456789101112obj = &#123; name: "Messi", sayName: function () &#123; console.log(this.name); &#125;&#125;;obj.sayName(); //"Messi"var f = obj.sayName;f(); //undefindconsole.log(f === obj.sayName); //true 很明显,虽然f与obj.sayName是等价的,但是他们所产生的结果却截然不同,归根到底是因为它们调用位置的不同造成的. f的调用位置在全局作用域,因此this指向window对象,而window对象并不存在name因此会显示出undefind,而obj.sayName的this指向的是obj对象,因此会打印出&quot;Messi&quot;. 我们可以在以下代码中加入name = &quot;Bale&quot;;来证明以上说法. 12345678910111213name = "Bale";obj = &#123; name: "Messi", sayName: function () &#123; console.log(this.name); &#125;&#125;;obj.sayName(); //"Messi"var f = obj.sayName;f(); //"Bale"console.log(f === obj.sayName); //true 大家一定会好奇,调用位置是如何决定obj.sayName的this指向obj对象,f却指向window对象呢,其中遵循什么规则吗? 2.默认绑定 this一共存在4种绑定规则,默认绑定是其中最常见的,我们可以认为当其他三个绑定规则都没有体现时,就用的是默认的绑定规则. 1234567name = "Bale";function sayName () &#123; console.log(this.name);&#125;;sayName(); //"Bale" 以上代码可以看成我们第一节例子中的f函数,它之所以指向window对象,就是运用了this默认绑定的规则,因为此实例代码中既没有运用apply bind等显示绑定,也没有用new绑定,不适用于其他绑定规则,因此便是默认绑定,此时的this指向全局变量,即浏览器端的windowNode.js中的global. 3.隐式绑定 当函数被调用的位置存在上下文对象,或者说被某个对象拥有或包含,这时候函数的f的this被隐式绑定到obj对象上.12345678function f() &#123;console.log( this.name );&#125;var obj = &#123;name: "Messi",f: f&#125;;obj.f(); // Messi 4.显式绑定 除了极少数的宿主函数之外,所有的函数都拥有call apply方法,而这两个大家既熟悉又陌生的方法可以强制改变this的指向,从而实现显式绑定. call apply可以产生对this相同的绑定效果,唯一的区别便是他们参数传入的方式不同. call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 第一个参数意义都一样。第二个参数：apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3) 对应的apply写法为：func.apply(func1,[var1,var2,var3])，同时使用apply的好处是可以直接将当前函数的arguments对象作为apply的第二个参数传入。 123456789function f() &#123;console.log( this.name );&#125;var obj = &#123;name: "Messi",&#125;;f.call(obj); // Messif.apply(obj); //Messi 我们可以看到,效果是相同的,call apply的作用都是强制将f函数的this绑定到obj对象上.在ES5中有一个与call apply效果类似的bind方法,同样可以达成这种效果, Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。 123456789101112function f() &#123; console.log( this.name );&#125;var obj = &#123; name: "Messi",&#125;;var obj1 = &#123; name: "Bale"&#125;;f.bind(obj)(); //Messi ,由于bind将obj绑定到f函数上后返回一个新函数,因此需要再在后面加上括号进行执行,这是bind与apply和call的区别 5.new绑定用 new 调用一个构造函数，会创建一个新对象, 在创造这个新对象的过程中,新对象会自动绑定到Person对象的this上，那么 this 自然就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。123456function Person(name) &#123; this.name = name; console.log(name);&#125;var person1 = new Person('Messi'); //Messi 6.绑定优先级通过以上的介绍,我们知道了四种绑定的规则,但是当这些规则同时出现,那么谁的优先级更高呢,这才有助于我们判断this的指向.通常情况下,按照优先级排序是:new绑定 &gt; 显式绑定 &gt;隐式绑定 &gt;默认绑定 我们完全可以通过这个优先级顺序判断this的指向问题. 7.ES6箭头函数中的this箭头函数不同于传统JavaScript中的函数,箭头函数并没有属于自己的this,它的this是捕获其所在上下文的 this 值，作为自己的 this 值,并且由于没有属于自己的this,箭头函数是不会被new调用的. MDN文档中关于箭头函数的实例很清楚的说明了这一点. 在 ECMAScript 3/5 中，这个问题可以通过新增一个变量来指向期望的 this 对象，然后将该变量放到闭包中来解决。12345678910function Person() &#123; var self = this; // 也有人选择使用 `that` 而非 `self`. // 只要保证一致就好. self.age = 0; setInterval(function growUp() &#123; // 回调里面的 `self` 变量就指向了期望的那个对象了 self.age++; &#125;, 1000);&#125; 除此之外，还可以使用 bind 函数，把期望的 this 值传递给 growUp() 函数。 箭头函数则会捕获其所在上下文的 this 值，作为自己的 this 值，因此下面的代码将如期运行。123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向了 person 对象 &#125;, 1000);&#125;var p = new Person(); 当然,我们用babel转码器,也可以让我们更清楚理解箭头函数的this 12345678// ES6const obj = &#123; getArrow() &#123; return () =&gt; &#123; console.log(this === obj); &#125;; &#125;&#125; 123456789// ES5，由 Babel 转译var obj = &#123; getArrow: function getArrow() &#123; var _this = this; return function () &#123; console.log(_this === obj); &#125;; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--属性]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[六、属性 1.JavaScript中的对象JavaScript中的对象一般分为三类:内置对象(Array, Error, Date等), 宿主对象(对于前端来说指的是浏览器对象,例如window), 自定义对象(指我们自己创建的对象). 因此,我们主要讨论的内容是围绕自定义对象展开的,今天我们就对象的属性进行深入地探究. 2.属性的创建我们先定义一个对象,然后对其赋值:12var person = &#123;&#125;;person.name = "Messi"; 以上操作相当于给person对象建立了一个name属性,且值为&#39;Messi&#39;. 那么这个赋值的过程具体的原理是什么呢? 首先,我们创建了一个’空’对象,之所以我们打上引号,是因为这并不是一个严格意义上的空对象,因为在建立这个对象的过程中,JavaScript已经为这个对象内置了方法和属性,当然是不可见的,在属性的建立过程中就调用了一个隐式的方法[[put]]. 大概的创建过程是,当属性第一次被创建时,对象调用内部方法[[put]]为对象创建一个节点保存属性.12345st=&gt;start: persone=&gt;end: persen.name = &quot;Messi&quot;io1=&gt;inputoutput: [[put]]st-&gt;io1-&gt;e 3.属性的修改我们对上例中的代码做一下修改:123var person = &#123;&#125;;person.name = "Messi";person.name = "Bale"; 很显然,name被创建后,该属就被进行了修改,原属性值Messi被修改为Bale,那么这个过程又是如何发生的呢? 其实对象内部除了隐式的[[put]]方法,还有一个[[set]]方法,这个方法不同于[[put]]在创建属性时调用,而是在同一个属性被再次赋值的时候用于更新属性进行的调用. 12345st=&gt;start: person.name = &quot;Messi&quot;e=&gt;end: persen.name = &quot;Bale&quot;io1=&gt;inputoutput: [[put]]st-&gt;io1-&gt;e 4.属性的查询判断一个属性或者方法是否在一个对象中,通常有两种方式.in操作符方式:1234var person = &#123; name: "Messi"&#125;;console.log("name" in person); //true hasOwnProperty方法: 1234var person = &#123; name: "Messi"&#125;;console.log(person.hasOwnProperty("name")); //true 5.属性的删除删除一个属性,最正确的方式是用delete方法,一个错误的方式是将该属性赋值为null,该方式的错误之处在于赋值null相当于调用了[[set]]方法把原属性值更改为了null,这个保存属性的节点依然存在,而用delete方法便能彻底删除这个节点.12345var person = &#123; name: "Messi"&#125;;delete person.name;console.log("name" in person); //false 6.属性的枚举我们通常用for...in枚举对象中的属性,它会将属性一一返回.在ES5中引入了一个新的方法Object.key(),不同之处在于,它可以将结果以数组的形式返回1234567891011var person = &#123; name: "Messi", age: 29&#125;;for(var pros in person ) &#123; console.log(pros); // name age &#125;var pros = Object.keys(person);console.log(pros); //[ 'name', 'age' ] 值得注意的是,并非所有的属性都是可枚举的,例如对象自带的属性length等等,因此我们可以用propertyIsEnumerable()方法来判断一个属性是否可枚举.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--原型]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[四、原型 1.原型对象绝大部分的函数(少数内建函数除外)都有一个prototype属性,这个属性是原型对象用来创建新对象实例,而所有被创建的对象都会共享原型对象,因此这些对象便可以访问原型对象的属性,例如hasOwnProperty()方法存在于Obejct原型对象中,它便可以被任何对象当做自己的方法使用. object.hasOwnProperty( propertyName )hasOwnProperty()函数的返回值为Boolean类型。如果对象object具有名称为propertyName的属性，则返回true，否则返回false。12345678 var person = &#123; name: "Messi", age: 29, profession: "football player" &#125;;console.log(person.hasOwnProperty("name")); //trueconsole.log(person.hasOwnProperty("hasOwnProperty")); //falseconsole.log(Object.prototype.hasOwnProperty("hasOwnProperty")); //true 由以上代码可知,hasOwnProperty()并不存在于person对象中,但是person依然可以拥有此方法. 很多人此时会好奇,person对象是如何找到Object对象中的方法的呢?这其中的内部机制是什么?这便是我们接下来要说的原型链. 2.__proto__与[[Prototype]]上一篇我们的示意图中曾经出现过__proto__,在ES6之前这个__proto__是大部分主流浏览器(IE除外)引擎提供的,还尚属非ECMA标准,在解析一个对象实例的时候为对象实例添加一个__proto__属性,此属性指向原型对象,我们便可以通过此属性找到原型对象.12345678function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); //person1 = &#123;name:"Messi", age: 29, profession: "football player"&#125;;var person2 = new person("Bale", 28); //person2 = &#123;name:"Bale", age: 28, profession: "football player"&#125;;console.log(person1.__proto__ === person.prototype); //true __proto__除了被主流浏览器支持外,还被Node.js支持,在ES2015进入到规范附录部分,算是被正式纳入了标准. 而在标准的语法里,实例对象是通过内置的内部属性[[Prototype]]来追踪原型对象的,这个[[Prototype]]的指针始终指向原型对象,此属性通常情况下是不可见的,我们需要用getPrototypeOf()来读取[[Prototype]]属性值(这个值就是原型对象). 12var obj = &#123;&#125;;console.log(Object.getPrototypeOf(obj) === Object.prototype); //true 同时我们也可以用isPrototypeOf来检验某个对象是否是另一个对象的原型对象. 12var obj = &#123;&#125;;console.log(Object.prototype.isPrototypeOf(obj)); //true ３．原型链在我们了解了__proto__与[[Prototype]]之后,就可以相对容易理解原型链了,由于__proto__与[[Prototype]]功能相似,但是__proto__更容易测试方便学习,我们选择__proto__来进行原型链的讲解. 12345678910111213function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); //person1 = &#123;name:"Messi", age: 29, profession: "football player"&#125;;var person2 = new person("Bale", 28); //person2 = &#123;name:"Bale", age: 28, profession: "football player"&#125;;person1.hasOwnProperty("name");console.log(person1.hasOwnProperty("hasOwnProperty")); //fasleconsole.log(person1.__proto__ === person.prototype); //trueconsole.log(person.prototype.hasOwnProperty("hasOwnProperty")); //falseconsole.log(person1.__proto__.__proto__ === person.prototype.__proto__); // trueconsole.log(person.prototype.__proto__.hasOwnProperty("hasOwnProperty")); //true 我们可以分析这个例子,看看person1对象实例是如何调用hasOwnProperty()这个方法的. 首先person1对象实例中寻找hasOwnProperty()方法,person1.hasOwnProperty(&quot;hasOwnProperty&quot;)返回false,发现不存在此方法,这时通过__proto__找到person1的原型对象. 在person1的原型对象person1.__proto__即person.prototype中寻找hasOwnProperty()方法,person.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)返回false,依然没有找到,此时顺着person.prototype的__proto__找到其原型对象. 在person.prototype原型对象person.prototype.__proto__即Object.prototype中寻找hasOwnProperty()方法,Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)返回true,由于hasOwnProperty()为Object.prototype内置方法,因此person1顺利找到此方法并调用. 总而言之,实例对象方法调用,是现在实力对象内部找,如果找到则立即返回调用,如果没有找到就顺着__proto__向上寻找,如果找到该方法则调用,没有找到会直接报错,这便是原型链. 如图所示,会更加直观. 4.ES6中的__proto__虽然__proto__在最新的ECMA标准中被纳入了规范,但是由于__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API.标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）代替。 12345678910function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29);console.log(Object.getPrototypeOf(person1) === person.prototype); //trueObject.setPrototypeOf(person1, &#123;League: "La Liga"&#125;); console.log(person1.League); //La Liga 以上为具体用法,但是值得注意的是Object.setPrototypeOf()在使用中有一个坑,如代码所示:123456789101112function person(pname, page) &#123; this.name = pname; this.age = page;&#125;person.prototype.profession = "football player";var person1 = new person("Messi", 29); var person2 = new person("Bale", 28); Object.setPrototypeOf(person1, &#123; League: "La Liga"&#125;);console.log(person1.League); //La Ligaconsole.log(person2.League); //undefind 也就是说不同于直接用person1.__proto__.League = &quot;La Liga&quot;;会使得两个实例同时生效,Object.setPrototypeOf()只能生效一个实例对象.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--作用域]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[三、作用域 1. 为什么要理解作用域原因很简单,JavaScript中最重要的一个概念闭包的理解就建立在对作用域的理解之上,而一个对象的的构成往往离不开闭包以及作用域. 2. 动态作用域or静态作用域?首先我们要搞清楚JavaScript的作用域类型,这有助于我们在分析作用域时的判断. 静态作用域:静态作用域是指声明的作用域是根据程序正文在编译时就确定的，有时也称为词法作用域。 动态作用域:程序中某个变量所引用的对象是在程序运行时刻根据程序的控制流信息来确定的。 大多数现代编程语言都采用的静态作用域,即代码在写出来的时候就已经确定的,并非在执行时再确定,我们可以根据以下代码一探究竟.12345678function f() &#123; console.log(a);&#125;function g() &#123; var a = 7; f();&#125;g(); // a is not defined 这段代码在执行时候会报错,很明显,如果JavaScript采用了动态作用域,a在执行时确定的话,那么以上代码相当于这样:1234567function g() &#123; var a = 7; function f() &#123; console.log(a); &#125;&#125;g(); //undefind 因此,我们可以判断出JavaScript属于静态作用域. 3.函数作用域函数是存在自身作用域的,在创建函数之初,函数体内就产生了作用域,为了方便理解,我们引用了《你不知道的JavaScript》书中的代码及图例,他会很清晰地帮助我们理解函数作用域.12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); // 2, 4, 12 由于JavaScript是采用静态作用域,作用域是在函数创建的时候就确定下来的. 4.作用域链那么,我们可以仔细分析一下这个作用域链.我们可以看到scope chain通过指向本函数的变量对象,并通过本函数的变量对象与整个父级函数变量对象联系在一起,这就是作用域链. 所以说，作用域链与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。 5. 块级作用域在ES2015之前,JavaScript中实际上是没有语法层面的块级作用域,这就造成了很多意外的产生.1234for (var i = 0; i&lt;3; i++) &#123;&#125;console.log(i); //3 如果是在有块级作用域的语言中,i是不会被打印出来的,但是在JavaScript中却被打印出来,这就是变量泄露的情况,也就是说看似在块级作用域的变量泄漏到全局作用域中,这也就造成了全局污染. 在ES5中,人们为了解决这个问题,一般采用立即执行函数IIFE来模拟块级作用域,但是这种写法不易读也不优雅,因此,在ES2015中引入了let,通过let可以创建块级作用域. let与var在使用上基本是类似的,但是let有三个主要的特点 可创建块级作用域 不存在变量提升 存在暂时性死区 例如上面的代码如果改用let声明,就不存在变量污染全局的情况1234for (let i = 0; i&lt;3; i++) &#123;&#125;console.log(i); //i is not defind 至于其它let的具体用法,可以直接参考《ES6入门教程》. 6.什么是闭包我们先简单地描述一下闭包:闭包是一个函数读取其它函数变量的桥梁. 我们先从上面这个简单的例子开始12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); // 2, 4, 12 根据前面所学作用域的概念,函数f2将引用函数f1的变量a并打印,这个嵌套函数中,子函数对父函数中的变量进行了引用,而使得这个引用得以成行的桥梁就是‘闭包’. 很多讲解闭包的文章都用return做实例,值得注意的是,闭包的形成并不一定要有return,只要对其它函数变量产生了引用,就会产生闭包，而return的作用是方便外部访问. 可以看到bar通过作用域链向上寻找到变量,我理解的闭包是一个对象,包含了函数本身以及它引用的上下文环境,本实例函数的闭包可以用这段代码来示意下:{Funtion:bar, bar.variableObject:{c=12, ...}, foo.variableObject:{b=4, ...},window/global.variableObject:{a=2, ...}}具体地说，函数A包含函数B，函数B可以获取函数A中的数据，而函数A不能获取函数B中的数据，则函数A作用域以外可以通过调用函数B改变函数A的数据。 闭包只是javascript函数作用域产生的附属品]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JavaScript--预解释]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E9%A2%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[二、预解释 1.从一个实例开始仔细阅读以下JavaScript代码,你觉得运行结果会是什么呢?是 1 还是2?123456var a= 1;function f() &#123; console.log(a); var a = 2;&#125;f(); 答案是undefined. 那么到底是什么原因导致了这个让人意外的结果呢?这就要从JavaScript解释阶段说起。 2.JavaScript预解释我们可以大致把JavaScript在浏览器中运行的过程分为两个阶段预解释阶段（有人说准确的说法是应该是Parser，我们以预解释方便理解） 执行阶段,在JavaScript引擎对JavaScript代码进行执行之前,需要进行预先处理,然后再对处理后的代码进行执行。 我们平时书写的JavaScript代码并不是JavaScript执行的代码(V8引擎读取一行执行一行这种理解是错误的),它需要预解释后,再由引擎进行执行. 具体的解释过程涉及到浏览器内核的技术不属于前端领域,不过我们可以浅显的理解一下V8在处理JavaScript的一般过程: 以上例中的var a = 2;为例,我们一般人的理解为声明了一个值为2的变量a,但是在JavaScript引擎处理时却分为了两个步骤: 读取var a后,在当前作用域中查找是否有相同声明,如果没有就在当前作用域集合中创建一个名为a的变量,否则忽略此声明继续进行解析. 接下来,V8引擎会处理a = 2的赋值操作,首先会询问当前作用域中是否有名为a的变量,如果有进行赋值,否则继续向上级作用域询问. 3.JavaScript执行环境我们上面提到的所谓javascript预解释正是创建函数的执行环境（又称“执行上下文”），只有搞定了javascript的执行环境我们才能搞清楚一段代码在执行过后为什么产生这样的结果。 我们用一段伪代码表示创立的执行环境12345executionContextObj = &#123; 'scopeChain': &#123; /* 变量对象 + 所有父级执行上下文中的变量对象 */ &#125;, 'variableObject': &#123; /* 函数参数 / 参数, 内部变量以及函数声明 */ &#125;, 'this': &#123;&#125;&#125; 作用域链(scopeChain)包括下面提到的变量对象(variableObject)和所有父级执行上下文中的变量对象. 变量对象(variableObject)是与执行上下文相关的数据作用域,一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明: 变量; 函数声明; 函数的形参 在有了这些基板概念之后我们可以梳理一下js引擎创建执行的过程: 创建阶段 创建Scope chain 创建variableObject 设置this 执行阶段 变量的值、函数的引用 执行代码 而变量对象的创建细节如下: 根据函数的参数，创建并初始化arguments object 扫描函数内部代码，查找函数声明（Function declaration） 对于所有找到的函数声明，将函数名和函数引用存入变量对象中 如果变量对象中已经有同名的函数，那么就进行覆盖 扫描函数内部代码，查找变量声明（Variable declaration） 对于所有找到的变量声明，将变量名存入变量对象中，并初始化为”undefined” 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 4.变量提升正是由于以上的处理,产生了大家熟知的JavaScript中的变量提升,具体以上代码的执行过程如以下伪代码所示:12345678910111213141516171819202122// global contextexecutionContextObj = &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; a: undefined, f: pointer to function f() &#125;, 'this': &#123;...&#125;&#125;...&#125;//首先在全局执行环境中声明了变量a以及函数f,此时a虽然被声明,但是尚未赋值x = 1;function f() &#123; executionContextObj &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; arguments: &#123;&#125;, a: undefined &#125;, 'this': &#123;...&#125; &#125; //内部词法环境中声明了变量a,此时a虽然被声明,但是尚未赋值 console.log(a);//此时a需要被被打印出来,在作用域内寻找a变量赋值,于是被赋值undefined a = 2;&#125; 我们可以明显看到,a变量在预解释阶段已经被赋值undefined,在执行阶段js是自上而下单线执行，当console.log(a)执行之时,a=2还没有被执行,a变量的值便是预处理阶段被赋予的undefined, 5.函数声明与函数表达式我们看到,在编译器处理阶段,除了被var声明的变量会有变量提升这一特性之外,函数也会产生这一特性,但是函数声明与函数表达式两种范式创建的函数却表现出不同的结果. 我们先看一个实例,运行以下代码12345678910f();g();//函数声明function f() &#123; console.log('f');&#125;//函数表达式var g = function() &#123; console.log('g');&#125;; f成功被打印出来,而g函数出现了类型错误,这是什么原因呢? 12345678910111213141516executionContextObj = &#123; 'scopeChain': &#123; ... &#125;, 'variableObject': &#123; f: pointer to function f(), g: undefined&#125;, 'this': &#123;...&#125;&#125;f();g();//函数声明function f() &#123; console.log('f');&#125;//函数表达式var g = function() &#123; console.log('g');&#125;; 我们看到,在预解释阶段函数声明的f是被指向了正确的函数得以执行,而函数表达式g被赋予undefined,undefined无法被当作函数执行因此报错g is not a function. 6.冲突处理通常情况下我们不会将同一变量变量重复声明,但是出现了类似情况后,编译器会如何处理这些冲突呢? 变量之间冲突执行以下函数:123var a = 3;var a = 4;console.log(a); 结果显而易见,后声明变量值覆盖前者的值 函数之间冲突12345678f();function f() &#123; console.log('f');&#125;function f () &#123; console.log('g');&#125;; 结果同变量冲突,后者覆盖前者. 函数与变量之间冲突 123456console.log(f);function f() &#123; console.log('f');&#125;var f ='g'; 结果如下,函数声明将覆盖变量声明. [Function: f]7.ES6中的let在ES6中出现了两个最新的声明语法let与const,我们以let为例,进行测试看看与var的区别.12345function f() &#123; console.log(a); let a = 2;&#125;f(); // ReferenceError: a is not defined 这段代码直接报错显示未定义,let与const拥有类似的特性,阻止了变量提升,当代码执行到console.log(a)时,执行换将中a还从未被定义,因此产生了错误.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解javaScript--类型判断]]></title>
    <url>%2F2018%2F02%2F25%2F%E7%90%86%E8%A7%A3JavaScript--%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[一、类型判断 JavaScript原始类型:Undefined、Null、Boolean、Number、String、Symbol JavaScript引用类型:Object 1.原始类型与引用类型1.1 原始类型又被称为基本类型，原始类型保存的变量和值直接保存在栈内存(Stack)中,且空间相互独立,通过值来访问,通过一个例子来解释. 12var person = 'Messi';var person1 = person; 上述代码在栈内存的示意图是这样的,可以看到,虽然person赋值给了person1.但是两个变量并没有指向同一个值,而是person1自己单独建立一个内存空间,虽然两个变量的值相等,但却是相互独立的. 1234567var person = 'Messi';var person1 = person;var person = 1;console.log(person); //1console.log(person1); //'Messi' 上述代码示意图是这样的,person的值虽然改变,但是由于person1的值是独立储存的,因此不受影响. 值得一提的是,虽然原始类型的值是储存在相对独立空间,但是它们之间的比较是按值比较的. 123var person = 'Messi';var person1 = 'Messi';console.log(person === person1); //true 1.2引用类型剩下的就是引用类型了,即Object 类型,再往下细分，还可以分为：Object 类型、Array 类型、Date 类型、Function 类型 等。 与原始类型不同的是,引用类型的内容是保存在堆内存中,而栈内存(Heap)中会有一个堆内存地址,通过这个地址变量被指向堆内存中Object真正的值,因此引用类型是按照引用访问的. 123456789101112var a = &#123;name:"percy"&#125;;var b;b = a;a.name = "zyj";console.log(b.name); // zyjb.age = 22;console.log(a.age); // 22var c = &#123; name: "zyj", age: 22&#125;;console.log(a === c); //false 我们可以逐行分析: 1. `b = a`,如果是原始类型的话,`b`会在栈内自己独自创建一个内存空间保存值,但是引用类型只是`b`的产生一个对内存地址,指向堆内存中的`Object`. 2.`a.name = &quot;zyj&quot;`,这个操作属于改变了变量的值,在原始类型中会重新建立新的内存空间(可以看上一节的示意图),而引用类型只需要自己在堆内存中更新自己的属性即可. 3.最后创建了一个新的对象`c`,看似跟`b` `a`一样,但是在堆内存中确实两个相互独立的`Object`,引用类型是按照**引用比较**,由于`a` `c`引用的是不同的`Object`所以得到的结果是`fasle`. 2. 类型中的坑2.1 数组中的坑数组是JavaScript中最常见的类型之一了,但是在我们实践过程中同样会遇到各种各样的麻烦. 稀疏数组:指的是含有空白或空缺单元的数组12345678910111213var a = [];console.log(a.length); //0a[4] = a[5];console.log(a.length); //5a.forEach(elem =&gt; &#123; console.log(elem); //undefined&#125;);console.log(a); //[,,,,undefined] 这里需要注意: 一开始建立的空数组a的长度为0,这可以理解,但是在a[4] = a[5]之后出现了问题,a的长度变成了5,此时a数组是[,,,,undefined]这种形态. 我们通过遍历,只得到了undefined这一个值,这个undefind是由于a[4] = a[5]赋值,由于a[5]没有定义值为undefined被赋给了a[4],可以等价为a[4] = undefined. 字符串索引 123456var a = [];a[0] = 'Bale';a['age'] = 28;console.log(a.length); //1console.log(a['age']); //28console.log(a); //[ 'Bale', age: 28 ] 数组不仅可以通过数字索引,也可以通过字符串索引,但值得注意的是,字符串索引的键值对并不算在数组的长度里. 2.2 数字中的坑二进制浮点数 JavaScript 中的数字类型是基于“二进制浮点数”实现的,使用的是“双精度”格式,这就带来了一些反常的问题,我们那一道经典面试提来讲解下.123var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //false 这是个出人意料的结果,实际上a的值约为0.30000000000000004这并不是一个整数值,这就是二进制浮点数带来的副作用. 123456var a = 0.1 + 0.2;var b = 0.3;console.log(a === b); //falseconsole.log(Number.isInteger(a*10)); //falseconsole.log(Number.isInteger(b*10)); //trueconsole.log(a); //0.30000000000000004 我们可以用Number.isInteger()来判断一个数字是否为整数. NaN 1234var a = 1/new Object();console.log(typeof a); //Numberconsole.log(a); //NaNconsole.log(isNaN(a)); //true NaN属于特殊的Number类型,我们可以把它理解为坏数值,因为它属于数值计算中的错误,更加特殊的是它自己都不等价于自己NaN === NaN //false,我们只能用isNaN()来检测一个数字是否为NaN. 3.类型转换原理类型转换指的是将一种类型转换为另一种类型,例如:123var b = 2;var a = String(b);console.log(typeof a); //string 当然,类型转换分为显式和隐式,但是不管是隐式转换还是显式转换,都会遵循一定的原理,由于JavaScript是一门动态类型的语言,可以随时赋予任意值,但是各种运算符或条件判断中是需要特定类型的,因此JavaScript引擎会在运算时为变量设定类型. 这看起来很美好,JavaScript引擎帮我们搞定了类型的问题,但是引擎毕竟不是ASI(超级人工智能),它的很多动作会跟我们预期相去甚远,我们可以从一到面试题开始. 1&#123;&#125;+[] //0 答案是0 是什么原因造成了上述结果呢?那么我们得从ECMA-262中提到的转换规则和抽象操作说起,有兴趣的童鞋可以仔细阅读下这浩如烟海的语言规范,如果没这个耐心还是往下看. 这是JavaScript种类型转换可以从原始类型转为引用类型,同样可以将引用类型转为原始类型,转为原始类型的抽象操作为ToPrimitive,而后续更加细分的操作为:ToNumber ToString ToBoolean,这三种抽象操作的转换表如下所示 如果想应付面试,我觉得这张表就差不多了,但是为了更深入的探究JavaScript引擎是如何处理代码中类型转换问题的,就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,// (1) for number hint, and (2) for string hint.function ToPrimitive(x, hint) &#123; // Fast case check. if (IS_STRING(x)) return x; // Normal behavior. if (!IS_SPEC_OBJECT(x)) return x; if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive); if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT; return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultNumber(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultString(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125; 上面代码的逻辑是这样的： 如果变量为字符串，直接返回. 如果!IS_SPEC_OBJECT(x)，直接返回. 如果IS_SYMBOL_WRAPPER(x)，则抛出异常. 否则会根据传入的hint来调用DefaultNumber和DefaultString，比如如果为Date对象，会调用DefaultString. DefaultNumber：首先x.valueOf，如果为primitive，则返回valueOf后的值，否则继续调用x.toString，如果为primitive，则返回toString后的值，否则抛出异常 DefaultString：和DefaultNumber正好相反，先调用toString，如果不是primitive再调用valueOf. 那讲了实现原理，这个ToPrimitive有什么用呢？实际很多操作会调用ToPrimitive，比如加、相等或比较操。在进行加操作时会将左右操作数转换为primitive，然后进行相加。 下面来个实例，({}) + 1（将{}放在括号中是为了内核将其认为一个代码块）会输出啥？可能日常写代码并不会这样写，不过网上出过类似的面试题。 加操作只有左右运算符同时为String或Number时会执行对应的%_StringAdd或%NumberAdd，下面看下({}) + 1内部会经过哪些步骤： {}和1首先会调用ToPrimitive{}会走到DefaultNumber，首先会调用valueOf，返回的是Object {}，不是primitive类型，从而继续走到toString，返回[object Object]，是String类型最后加操作，结果为[object Object]1再比如有人问你[] + 1输出啥时，你可能知道应该怎么去计算了，先对[]调用ToPrimitive，返回空字符串，最后结果为”1”。 本系列主要参考： JavaScript 类型的那些事]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解promise]]></title>
    <url>%2F2018%2F02%2F20%2F%E7%90%86%E8%A7%A3promise%2F</url>
    <content type="text"><![CDATA[前言在学习node的路上，理解异步操作是重点，而处理的方法一直在完善，先有setTimeout,后又promise，貌似目前目前大招是async/await(目前三个都不理解，(捂脸…))，下面就开始吧。这是在看JavaScript Promise迷你书时记录的笔记,若有错误，敬请指出，感激不尽。原文Promise迷你书 1、什么是Promise1.1、常见异步处理Promise是抽象异步处理对象以及对其进行操作的组件。Promise最初被提出是在E语言，E语言是基于并列/并行处理设计的一种编程语言。常见基于javaScript的异步处理大都利用回调函数 12345678----//使用回调函数的异步处理getAsync("fileA.txt", function(error, result)&#123; if(error)&#123; throw error; &#125; &#125;);---- 1.2、使用Promise进行异步处理Promise是把类似的异步处理对象和处理规则规范化，并按照统一的接口来编写，而采取规定方法之外的写法都会出错。 12345678//使用Promise进行异步处理var promise = getAsyncPromise("fileA.txt");promise.then(function(result)&#123; //获取文件内容成功时的处理&#125;).catch(function(error)&#123; //获取文件内容失败时的处理&#125;);&lt;1&gt;返回promise对象 我们可以向预设了抽象化异步处理的promise对象，注册这个promise对象执行成功和失败时相应的回调函数。这里与常见异步处理操作不同，需严格遵守规则，无法自由的定义回调函数的参数。所以，promise的功能是可以将复杂的异步处理轻松地进行模式化 1.3、Promise简介三种API类型 ConstructorPromise类似XMLHttpRequest，从构造函数promise新建一个promise对象作为接口。 12345//创建promise对象var promise = new Promise(function(res,rej)&#123; //异步处理 //处理完后，调用resolve或reject&#125;); Instance Method通过new生成promise对象，promise.then()方法可以设置在resolve(成功)/reject(失败)时调用的回调函数。 promise.then(onFulfilled, onRejected) resolve(成功)时onFulfilled 会被调用 reject(失败)时onRejected 会被调用只想对异常进行处理时可以采用 promise.then(undefined, onRejected)这种方式，只指定reject时的回调函数即可。不过这种情况下 promise.catch(onRejected) 应该是个更好的选择。 Static Method辅助方法：promise.all()promise.resolve() 1.3.1、Promise workflow123456789101112function asyncFunction() &#123;return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('Async Hello world'); &#125;, 16); &#125;);&#125;asyncFunction().then(function (value) &#123; console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); 1.3.2、Promise的状态用new Promise实例化的promise对象有以下三个状态： “has-resolution” - Fulfilled resolve(成功)时。此时会调用 onFulfilled “has-rejection” - Rejected reject(失败)时。此时会调用 onRejected “unresolved” - Pending 既不是resolve也不是reject的状态。也就是promise对象刚被创建后的初始化状态等状态变化 promise对象的状态，从Pending转换为Fulfilled或Rejected之后， 这个promise对象的状态就不会再发生任何变化。也就是说，Promise与Event等不同，在.then后执行的函数可以肯定地说只会被调用一次。另外，Fulfilled和Rejected这两个只中任一状态都可以表示为Settled(不变的)。 Settled resolve(成功)或rejected(失败)。 1.4、编写Promise代码如何写Promise代码。 1.4.1、创建promise对象流程如下 1.new Promise(fn)返回一个promise对象 2.在fn中指定异步等处理 * 处理结果正常，调用resolve(处理结果值) * 处理结果错误，调用reject(Error对象) 在此用Promise来通过异步处理方式来获取XMLHttpRequest(XHR)的数据。 创建XHR的promise对象首先，创建一个用Promise把XHR处理包装起来的名为getURL的函数。 xhr-promise.js1234567891011121314151617181920212223242526function getURL(URL) &#123; return new Promise(function (resolve, reject) &#123; var req = new XMLHttpRequest(); req.open('GET', URL, true); req.onload = function () &#123; if (req.status == 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function () &#123; reject(new Error(req.statusText)); &#125; &#125;);&#125;//实例var URL = "http://httpbin.org/get";getURL(URL).then(function onFulfilled(value)&#123; console.log(value);&#125;).catch(function onRejected(error)&#123; console.error(error);&#125;);//输出结果为请求数据 getURL只有在通过XHR取得结果状态码为200(数据取得成功)时，调用resovle，其他情况(取得失败)时调用reject方法。 成功时 resolve(req.responseText)在response的内容中加入了这个参数，resolve方法把参数传给回调函数(then方法会接收这个参数)。 常见回调函数callback(err, response)的值为err(出错)和response(接收的数据)，来处理正常和异常的情况，而在Promise中resolve/reject则担当了这个职责 失败时 当发生错误时，onerror事件被触发，调用reject。 此时，如reject(new Error(req.statusText))，创建一个Error对象并将具体的值传入，传给reject的参数只要是Error对象(或者继承自Error对象)就行。 我的疑问]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>promise</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node要点总结]]></title>
    <url>%2F2018%2F02%2F20%2Fnode%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node开发要点1、常用前端技术： html5 css3 jQuery 2、js高级话题： 面向对象 闭包 作用域 设计模式 3、其他后端技术： mongodb redis apache nignix mysql 4、node内置核心库： 全局对象 时事件 流 网络 子程序 5、常用知名第三方库： async express koa 6、node高级话题： 异步 部署 性能调优 异常调试 node事件循环机制* javaScript高级话题(面向对象、作用域、闭包、设计模式)面向对象1、常用js类定义的方法？构造函数原型法： 1234567891011121314151617 function Person () &#123; this.name = 'pinocchio'; &#125; Person.prototype.sayName = function () &#123; alert(this.name);; &#125; var person = new Person (); person.sayName(); //对象创建: var Person = &#123; name: 'pinocchio', sayName: function () &#123; alert(this.name); &#125; &#125;; var person = Object.create(Person); person.sayName(); 2、js类继承的方法？原型链法(Person是Animal的子集，即子类)： 12345678910111213141516171819202122232425262728293031323334 function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125; function Person () &#123;&#125; Person.prototype = Animal.prototype; //人继承动物 Person.prototype = constructor = 'Person'; //更新构造函数为人属性复制法(单纯复制，两者无继承关系)： function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123;&#125; //复制动物所有属性到人 for (prop in Animal.prototype) &#123; Person.prototype[prop] = Animal.prototype[prototype]; &#125; //更新构造函数为人 Person.prototype.constructor = 'Person'; 构造器应用法: function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123; //apply,call,bind方法都行，有细微区别 Animal.call(this); &#125; 3、js类多重继承的方法怎么实现？通过类继承里面的属性复制法来实现，可以继承所有父类的prototype属性 作用域 4、js里作用域是什么样？函数作用域， 123456789var globalVar = 'global var';function test() &#123; alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义 var globalVar = 'overrided var'; // globalVar在本函数内被重定义 alert(globalVar); // overrided var&#125;alert(globalVar); // global var，使用全局变量 5、js中this指的是什么？this指的是对象本身 6、apply，call，bind有什么区别？apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； 三者第一个参数都是this要指向的对象，也就是想指定的上下文； 三者都可以利用后续参数传参； apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表 12345678910111213141516function Person () &#123;&#125;Person.prototype.sayName() &#123; alert(this.name);&#125;//普通对象，不是Person实例var obj = &#123; name: 'pinocchio'&#125;;//applyPerson.prototype.sayName.apply(obj, [param1, param2, param3]);//callPerson.prototype.sayName.call(obj, param1, param2, param3);//bind,先绑定，再执行var sn = Person.prototype.sayName.bind(obj);sn([param1, param2, param3]);sn(param1, param2, param3); 7、caller，callee和arguments分别是什么？123456789101112caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量． function parent(param1, param2, param3) &#123; child(param1, param2, param3); &#125; function child() &#123; console.log(arguments); // &#123; '0': 'mqin1', '1': 'mqin2', '2': 'mqin3' &#125; console.log(arguments.callee); // [Function: child] console.log(child.caller); // [Function: parent] &#125; parent('mqin1', 'mqin2', 'mqin3'); 闭包8、什么是闭包？闭包有什么用处？通俗的说，闭包就是作用域范围，因为js是函数作用域，所以函数就是闭包．全局函数的作用域范围就是全局，所以无须讨论．更多的应用其实是在内嵌函数，这就会涉及到内嵌作用域，或者叫作用域链。 这就会带来另外一个问题，什么时候引用结束？如果不结束，就会一直占用内存，引起内存泄漏．不用的时候就引用设为空。 9、defineProperty, hasOwnProperty, propertyIsEnumerable都是做什么用的？Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有value,writable,configurable,enumerable,set/get等.hasOwnProerty用于检查某一属性是不是存在于对象本身，继承来的 父亲的属性不算．propertyIsEnumerable用来检测某一属性是否可遍历，也就是能不能用for..in循环来取到. 设计模式10、js常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等1) 单例： 任意对象都是单例，无须特别处理var obj = {name: &#39;michaelqin&#39;, age: 30}; 2) 工厂: 就是同样形式参数返回不同的实例12345678910111213function Person() &#123; this.name = 'Person1'; &#125;function Animal() &#123; this.name = 'Animal1'; &#125;function Factory() &#123;&#125;Factory.prototype.getInstance = function(className) &#123; return eval('new ' + className + '()');&#125;var factory = new Factory();var obj1 = factory.getInstance('Person');var obj2 = factory.getInstance('Animal');console.log(obj1.name); // Person1console.log(obj2.name); // Animal1 3) 代理: 就是新建个类调用老类的接口,包一下1234567891011121314151617function Person() &#123; &#125;Person.prototype.sayName = function() &#123; console.log('michaelqin'); &#125;Person.prototype.sayAge = function() &#123; console.log(30); &#125;function PersonProxy() &#123; this.person = new Person(); var that = this; this.callMethod = function(functionName) &#123; console.log('before proxy:', functionName); that.person[functionName](); // 代理 console.log('after proxy:', functionName); &#125;&#125;var pp = new PersonProxy();pp.callMethod('sayName'); // 代理调用Person的方法sayName()pp.callMethod('sayAge'); // 代理调用Person的方法sayAge() 4) 观察者: 就是事件模式，比如按钮的onclick这样的应用.12345678910111213141516171819202122232425262728293031323334353637function Publisher() &#123; this.listeners = [];&#125;Publisher.prototype = &#123; 'addListener': function(listener) &#123; this.listeners.push(listener); &#125;, 'removeListener': function(listener) &#123; delete this.listeners[listener]; &#125;, 'notify': function(obj) &#123; for(var i = 0; i &lt; this.listeners.length; i++) &#123; var listener = this.listeners[i]; if (typeof listener !== 'undefined') &#123; listener.process(obj); &#125; &#125; &#125;&#125;; // 发布者function Subscriber() &#123;&#125;Subscriber.prototype = &#123; 'process': function(obj) &#123; console.log(obj); &#125;&#125;; // 订阅者var publisher = new Publisher();publisher.addListener(new Subscriber());publisher.addListener(new Subscriber());publisher.notify(&#123;name: 'michaelqin', ageo: 30&#125;); // 发布一个对象到所有订阅者publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者 11、列举数组相关的常用方法push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter 12、列举字符串相关的常用方法indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase node核心内置库类（事件， 流， 文件， 网络）node概览：1、node架构主要分为三层，应用app &gt;&gt; V8及node内置架构 &gt;&gt; 操作系统. V8是node运行的环境，可以理解为node虚拟机． node内置架构又可分为三层: 核心模块(javascript实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http. 2、node的核心模块EventEmitter, Stream, FS, Net, 全局对象 node全局对象：1、node有哪些全局对象？process、 console、 Buffer 2、process有哪些方法？process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit 3、console有哪些常用方法?console.log/console.info, console.error/console.warning, console.time/console.timeEnd, console.trace, console.table 4、node有哪些定时功能?setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick 5、node中的事件循环是什么样子的?process.nextTick &gt;&gt; setImmidate &gt;&gt; setTimeout/SetInterval 6、node中的Buffer如何应用?Buffer是用来处理二进制数据的，比如图片，mp3,数据库文件等.Buffer支持各种编码解码，二进制字符串互转 EventEmitter:1、什么是EventEmitter?EventEmitter是node中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题. 2、如何实现一个EventEmitter?主要分三步：定义一个子类， 调用构造函数， 继承EventEmitter 123456789101112131415var util = require('util'), EventEmitter = require('event').EventEmitter;//构造函数function MyEmitter () &#123; EventEmitter.call(this);&#125;//继承util.inherits(MyEmitter, EventEmitter);var em = new MyEmitter();//接受事件em.on('hello', function(data) &#123; console.log('收到事件hello的数据：'， data);&#125;);em.emit('hello', 'EventEmitter传递消息真方便'); 3、EventEmitter有哪些典型应用？模块之间传递消息 回调函数内外传递消息 处理流数据 观察者模式发射触发机制 4、怎么捕获EventEmitter的错误事件？监听error事件即可，若有多个EventEmitter，可用domain来统一处理。 123456789101112var domain = require('domain');var myDomain = domain.create();//接受事件并打印myDomain.on('error', function(err)&#123; console.log('domain接受到的事件', err);&#125;);myDomain.run(function() &#123; var emitter1 = new MyEmitter(); emitter1.emit('error', '错误事件来自emitter1'); var emitter2 = new MyEmitter(); emitter2.emit('error', '错误事件来自emitter2');&#125;); 5、EventEmitter中的newListenser事件有什么用处?newListener可以用来做事件机制的反射，特殊应用，事件管理等．当任何on事件添加到EventEmitter时，就会触发newListener事件，基于这种模式，我们可以做很多自定义处理. 123456789var emitter3 = new MyEmitter();emitter3.on('newListener', function(name, listener) &#123; console.log("新事件的名字:", name); console.log("新事件的代码:", listener); setTimeout(function()&#123; console.log("我是自定义延时处理机制"); &#125;, 1000);&#125;);emitter3.on('hello', function()&#123; console.log('hello node');&#125;); Streamstream是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型． 1、Stream有什么好处？非阻塞式数据处理提升效率，片段处理节省内存，管道处理方便扩展 2、Stream有哪些典型应用？文件处理、网络交换、数据转换、音视频处理 3、怎么捕获Stream的错误事件？监听error事件、方法同EventEmitter 4、哪些常用Stream，分别什么时候用？Readable为可被读流，在座位数据源时使用； Writeable为可被读流，在作为输出元时使用； Duplex为读写流，作为输入源接受被写入，同时又作为输入源被后面的流读出； Transform机制和Duplex一样，都是双向流，区别时Transfrom只需要实现一个函数_transfrom(chunk, encoding, callback); 而Duplex需要分别实现_read(size)函数和_write(chunk, encoding, callback)函数. 5、实现一个Writable Stream?三步走:1)构造函数call Writable 2) 继承Writable 3) 实现_write(chunk, encoding, callback)函数 ``` var Writeable = require(&apos;stream&apos;).Writable; var util = require(&apos;util&apos;); //构造函数 function MyWriteable(options) { Writeable.call(this, options); } //继承Writeable util.inherits(MyWriteable, Writable); MyWritable.prototype._write = function(chunk, encoding, callback) { // 此处可对写入的数据进行处理 console.log(&quot;被写入的数据是:&quot;, chunk.toString()); callback(); }; // stdin作为输入源，MyWritable作为输出源 process.stdin.pipe(new MyWritable()); ``` node高级话题(异步， 部署， 性能调优， 异步调试)1、node中的异步与同步怎么理解？node是单线程的，异步是通过一次次的事件循环来实现的。 同步则是阻塞式的io，在高并发环境下会有很大的性能问题，所以同步一般只在基础框架的启动时使用，如：加载配置文件、初始化程序 2、哪些方法可以进行异步流程控制？1）多层嵌套回调 2）单独为回调写函数，函数里再回调 3)第三方框架：async、q、promise 3、怎么绑定node程序到80端口？1）sudo 2）Apache/nginx代理 3）操作系统的firewall iptables端口绑定 4）第三方库up 4、有哪些方法可以让node程序遇到错误后自动重启?1) runit 2) forever 3) nohup npm start &amp; 4）up -watch -port 80 server.js 5、怎么充分利用多个cpu？1个cpu运行一个node程序 6、怎样调节node执行单元的内存大小?用--max-old-space-size 和 --max-new-space-size 来设置 v8 使用内存的上限 7、有哪些常用方法可以防止程序崩溃?1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试 8、怎样调试node程序?1) 监听错误事件req.on(&apos;error&apos;, function(){}), 适用EventEmitter存在的情况; 2) Promise.then.catch(error),适用Promise存在的情况 3) try-catch,适用async-await和js运行时异常，比如undefined object]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable详解及React中实践]]></title>
    <url>%2F2017%2F12%2F17%2FImmutable%E8%AF%A6%E8%A7%A3%E5%8F%8AReact%E4%B8%AD%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1、js中数据可变状态概念：js中的对象一般是可变的，由于使用了引用赋值，新的对象简单的引用了原始的对象，改变的新对象将影响到原始对 象。 例如： 1234foo = &#123;a:1&#125;;bar = foo;bar.a = 2;console.log(foor.a); //输出2 优缺点：优点：节约内存 缺点：当应用复杂后，会造成非常大的隐患 解决办法：shallowCopy（浅拷贝），deepCopy（深拷贝） 两种方法可将对象置为不可变对象，但同时也造成cpu和内存的浪费 2、Immutable.Data]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Immutable</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React笔记]]></title>
    <url>%2F2017%2F12%2F17%2FReact%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据类型 state/props state—组件本身的数据 props—从其他组件传入的组件 生命周期 getDefaultProps //获得默认数据 getInitialState //设置State数据 componentWillMount //在component即将挂在到页面上时 render componentDidMount //ui真正挂载到文档流 componentWillUnmount //文件销毁 组件间通信 widget之间通过props通信 子组件与父组件的通信 事件订阅 React-router url模式： browserHistory //yoursite.com/a/b hashHistory //yoursite.com/#a/b 两种组件：（装载页面的组件） IndexRouter //默认（没有存url） Router 写法： &lt; Link to = “url”&gt; 注释： 页面切换时，组件会被销毁，再次进入时重新加载。若要实现某功能一直运行，不受页面切换的影响，则将该功 能置于根节点上。 事件订阅 //TODO:完善整个概念]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fwebpack%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[webpack使用中的错误：1.npm run dev 出错打包错误in ./src/index.js12345Module build failed: TypeError: fileSystem.statSync is not a function at module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/utils/exists.js:7:25) at find (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/resolve-rc.js:13:9) at Object.module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/index.js:113:132) @ multi main 原因及解决方法：babel-loader7.x版本与webpack1.x不兼容，将babel-loader版本降到6.x]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装以及升级node，npm：1.安装nodejssudo apt install nodejs-legacy2.安装npmsudo apt install npm3.清楚cachesudo npm cache clean -f4.安装n包sudo npm install -g n5.获取nodejs稳定版sudo n stable6.升级npmsudo npm install -g npm]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2017%2F12%2F13%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[显示仓库中的页面1、把文件放在**.github.io仓库2、在文件路径前面加http://htmlpreview.github.io/?然后访问，如： http://htmlpreview.github.io/?https://github.com/**/example/index.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu笔记]]></title>
    <url>%2F2017%2F12%2F13%2FUbuntu%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[系统操作：1.在图形化界面下获取最高权限 sudo nautilus2.显示/隐藏文件 Ctrl+hnpm:1.在使用npm下载包的时候出现无权限修改文件问题 在npm前面加上sudo2017-09-25]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电梯模拟程序]]></title>
    <url>%2F2017%2F11%2F27%2F%E7%94%B5%E6%A2%AF%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[whim今天在等电梯的时候，突然对电梯工作流程感兴趣，想写个电梯模拟小程序。先来占个坑，写个大致思路,等考完试再来完成 //这楼有20层int max_floor = 20; 楼层构造一个类12345678//楼层class floor &#123; private: //楼层 int floor = 0; //有人上1，还是下2,或是没人按电梯0 int uds = 0；&#125; 电梯构造一个类1234567891011121314//电梯class elevator &#123; private: int current_floor = 0; //三个状态，上升1，下降2，静止0 int uds = 0; public: //上升 void up(); //下降 void down(); //判断电梯上升还是下降 void UpDown(); &#125; 判断函数构造一个类因为有两个电梯，所以把判断函数拿出来单独构造一个类。123456//判断电梯哪个电梯去载人，上升还是下降class select &#123; public: //判断哪个电梯去载人 void which（）；&#125; 函数部分1234567891011121314151617void elevator::up()&#123; //用参数判断是否到达 int arrived = 0; for (int i = 1; i &lt;= 20; i++)&#123; //判断是否到达目的楼层(类之间引用问题) if(current_floor != floor.floor)&#123; current_floor++; &#125;else &#123; arrived = 1; continue; &#125; &#125; return arrived;&#125; 大致思路就先写到这，后续加上。 真的蛮好玩诶！]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>whim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+mysql实现小型web后台程序]]></title>
    <url>%2F2017%2F11%2F26%2Fnodejs-mysql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9E%8Bweb%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[项目地址主要实现功能：1.用户名密码登录2.增删改查管理员发布的网页数据 具体小功能：1.对用户名数据进行哈希加密（签名）2.强制登录页面（重定向）3.浏览器与服务器传输数据 图片界面丑了点，当时主要把后台功能搭起来，功能基本齐全，后面会把界面做起来登录界面 首页 发布信息 用户评价 项目结构： /server.js其功能是建服务器监听8080端口。具体代码： 1234567891011121314151617181920212223242526272829303132333435var server=express();server.listen(8080);//1.获取请求数据//get自带server.use(bodyParser.urlencoded());server.use(multerObj.any());//2.cookie、sessionserver.use(cookieParser());(function ()&#123; var keys=[]; for(var i=0;i&lt;100000;i++)&#123; keys[i]='a_'+Math.random(); &#125; server.use(cookieSession(&#123; name: 'sess_id', keys: keys, maxAge: 20*60*1000 //20min &#125;));&#125;)();//3.模板server.engine('html', consolidate.ejs);server.set('views', 'template');server.set('view engine', 'html');//4.routeserver.use('/', require('./route/web')());server.use('/admin/', require('./route/admin')());//5.default：staticserver.use(static('./static/'));console.log('server is running at port 8080...'); 各段代码作用如下：1.解析请求数据2.并发给请求方cookie，3.声明调用的模板4.路由功能，区分请求并转入相应界面5.处理静态文件请求 /libs/common.js该文件封装模板，其功能是将登录时的用户输入的用户名密码等数据用哈希算法加密（签名），让该数据不可见，避免他人获取用户名密码。代码如下： 1234567 MD5_SUFFIX: '*****',md5: function (str)&#123; var obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex'); 其中，MD5_SUFFIX加在数据后面，再进行md5加密，该MD5_SUFFIX是自定义的数据的 /route/index.js在服务器运行后，服务器一直监听8080端口，当有请求访问，首先对该用户的登录状态和请求进行判定，如果不是管理员，就重定向返回登录界面。如果想访问其他页面，也不行，重定向回登录界面。只有当既是管理员，请求访问的又是登录界面才对请求予以响应。 123456789//检查登录状态 router.use((req, res, next)=&gt;&#123; if(!req.session['admin_id'] &amp;&amp; req.url!='/login')&#123; //没有登录 //转向登录界面(重定向) res.redirect('/admin/login'); &#125;else&#123; next(); &#125; &#125;); 如果已确定是管理员，就再来判定其访问请求。 1234//根据不同http请求，转向不同页面router.use('/login', require('./login')());router.use('/banners', require('./banners')());router.use('/custom',require('./custom')()); /route/login.js那是怎么判断是否为管理员？ 当管理员登录时，后台就拿着页面获取的用户名密码和数据库的进行比对，成功就给浏览器发session，不成功就不发，判定管理员的时候就是看有没有session。为什么不直接不直接用用户名密码验证，而要再加一个session？ session可以理解为cookie的加强版，具有生存期，可以控制用户在一定时间内免登陆。若采用用户名密码验证，那每 退一次，就得输入一次密码，这在实际操作中是很不方便的。 12345if(data[0].password==password)&#123; //成功 req.session['admin_id']=data[0].ID; res.redirect('/admin/'); &#125; route和template登录后，就对数据进行操作。route和template分别是存放js和静态文件的文件夹，文件夹内的js文件实现的功能相似，都是将页面和数据库连接起来，对数据进行增删改查的操作。就banners页面来说，其具体代码如下： 12//连接数据库var db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '***', database: 'learner'&#125;); 修改banner数据 1234567891011121314151617db.query(`SELECT * FROM banner_table WHERE id=$&#123;req.query.id&#125;`, (err, data)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else if(data.length==0)&#123; res.status(404).send('data not found').end(); &#125;else&#123; db.query('SELECT * FROM banner_table', (err, banners)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else&#123; res.render('admin/banners.ejs', &#123;banners, mod_data: data[0]&#125;); &#125; &#125;); &#125;&#125;); 其他数据操作功能同理]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm重新安装模块]]></title>
    <url>%2F2017%2F11%2F26%2Fnpm%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[npm删除模块，重新安装错误经过 使用hexo模块的时候，不小心将已经配置好的blog文件删除。在网上查找资料，运行npm cache clean –force，出现错误（不能使用hexo命令）。然后我就准备重装hexo，把usr/bin和local里hexo相关文件删除，用npm重新下载hexo，但还是和之前一样出错 解决 需要删除hexo相关文件和packagejson里的依赖，再重新下载hexo，就可以使用了 具体位置（linux环境）：/home/zaizizaizai/.npm-global/bin和/home/zaizizaizai/.npm-global/lib 补充：此路径为隐藏目录，在home区需要按快捷键ctrl+h显示隐藏文件，或者通过命令行进行操作]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应网页设计]]></title>
    <url>%2F2017%2F11%2F26%2F%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[点我转向原文章转译：pinocchio对于初入前端的学习者来说，设计网页自适应不同分辨率的终端是比较难解决的一件事。自适应网页设计指的是可以自动识别屏幕宽度、并做出相应调整的网页设计。 以下是自适应网页设计的方法： 一、允许网页宽度自动调整 在网页代码的头部，加入viewport元标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device- width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 所有主流浏览器(IE9)都支持这个设置。对于老式浏览器（IE6、7、8），需要使用css3-mediaqueries.js。 二、不使用绝对宽度 若在头部加入了viewport元标签，网页会自动更具屏幕宽度调整布局，所以不能使用具有绝对宽度的元素。 即css代码不能制定像素宽度 width:xxx px; 只能使用百分比宽度 width: xx%; 或者 width:auto; 三、相对大小的字体 字体也不能使用绝对大小（px），而只能使用相对大小（em）。 123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 123 h1 &#123; font-size: 1.5em; &#125; 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 123 small &#123; font-size: 0.875em; &#125; 四、流动布局（fluid grid） “流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 123456789.main &#123; float: right; width: 70%;&#125;.leftBar &#123; float: left; width: 25%;&#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向 overflow（溢出），避免了水平滚动条的出现。 五、选择加载css “自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 400px)" href="tinyScreen.css" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 123 &lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 400px) and (max-device-width: 600px)" href="smallScreen.css" /&gt; 如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 1 @import url("tinyScreen.css") screen and (max-device-width: 400px); 六、CSS的@media规则 同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 12345678910 @media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 七、图片的自适应（fluid image） 除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： img { max-width: 100%;} 这行代码对于大多数嵌入网页的视频也有效，所以可以写成： img, object { max-width: 100%;} 老版本的IE不支持max-width，所以只好写成： img { width: 100%; } 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： img { -ms-interpolation-mode: bicubic; } 或者，Ethan Marcotte的imgSizer.js。 1234 addLoadEvent(function() &#123; var imgs = document.getElementById("content").getElementsByTagName("img"); imgSizer.collate(imgs); &#125;);]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>转载</tag>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博客评论说明由于多说、跟帖等评论插件都倒了，就转向了友言。结果友言服务器是国外的，得翻墙才能用。就转向了畅言，可是这搜狐畅言得用域名（我怕还没来的及买域名了-_-）。最后还是回到大爱的git了。过程：多说、跟帖–&gt;友言–&gt;畅言–&gt;gitment 2017-11-23]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>博客说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解MongoDB]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MongoDB%2F</url>
    <content type="text"><![CDATA[这是在我看完《深入理解MongoDB》后，按照自己的理解记录下来的笔记，初次接触，若有错误，敬请指出，感谢！ 一.概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB操作模式：应用程序&lt;=&gt;mongos&lt;=&gt;集群 二.理解分片1.什么是分片（sharding）？分片（sharding）是MongoDB用来将大型集合分割到不同服务器上采用的方法。这样做是为实现3个目标：让集群“不可见”让应用程序知道要执行任何“增删改查”操作只需要发送请求给MongoDB这一个对象就行了，剩下的事就交给它了，不需要区分交给那个服务器，简化了应用程序端操作指令。在MongoDB中具体连接客户端与服务器端的就是叫做mongos的专有路由进程，mongos可以比喻为一个秘书，转发客户端的请求，和服务器端的响应。保证集群总是可以读写一个大的集合分为多个分片（shard），当其中一个进程/服务器出现问题，由运行在其他分区的其他副本接替换掉的部分继续工作。使集群易于扩展将大的集群分割为多个小的分区，当需要资源的时候，只需要添加小的空间。 2.分配数据sharding操作后得到分片（shard）是集群中负责数据某一子集的一台或多台服务器。换言之，一个分片包含数据的某个子集。例如一个集群包含1000份代表网站注册用户文档，其中一个分片就可能包含200份。若一个分片包含多个服务器，则每个服务器拥有一份完整的数据副本。 一分片一区间分配数据最简单的方法就是让一分片负责一区间的数据。假设有四个分片，依次对应[“a”,”f”),[“f”,”n”),[“n”,”t”),[“t”,”{“)区间，{是ASCII码表中字母z后面的字符。许多用户用首字母在范围[“a”,”f”)中的名字来注册，就导致分片1较大，我们可以调整区间使分片1对应的区间缩小，从而让分片均衡。但当分片1和分片2过载时，就不太好处理。假设分片1和分片2各有500G数据，分片3和分片4各有300G数据，此时就需要分片1转移100G数据到分片2，接着从分片2转移200G数据到分片3，最后分片3转移100G数据到分片4，从而使每个分片都具有400G数据，达到均衡。这还只是4个分片，执行这个操作一共移动了400G数据。当考虑到所有分片，可想需要移动的数据量是很大的。 一分片多区间重新来考虑上面的情况，此时是一分片多区间。我们可以把分片1和分片2都划分为两个区间，分片1分别对应包含400G数据的[“a”,”d”)区间和包含100G数据的[“d”,”f”)区间，分片2分别对应包含400G数据[“f”,”j”)区间和100G数据[“j”,”n”)区间。我们就可以把分片1中的[“d”,”f”)区间的数据直接移动到分片3，把分片2中的[“,j”,”n”)区间的数据直接移动到分片4，相比上一种情况，只需要移动200G数据。添加新的分片也具有同样的优势——减少数据转移量。 创建块一个区间的数据成为一个数据块（也叫块，chunk），块默认大小为200MB（兼顾可移动性和最小开销），当一个块的区间一分为二是，就变成两个块了。当提到块出不得不说片键了，如下所示{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}{“username”:”zaizizaizai”,”age”:16}如果我们选择age字段作为片键病得到一个块区间[20,30），则得到的块为：{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}可以把片键理解为一个选择器（标签），也可理解为属性，即挑选符合条件的数据，在这里不仅局限于把age作为片键，username也可以作为片键，且片键值不可修改。随着数据的增加，当一个块变大，MongoDB会自动将其分割为2个小块。若分片间数据比例失衡，MongoDB会迁移块其他分片（由叫做平衡器的进程执行），以达到分片间数据比例总是平衡的状态。同时平衡器会忽略微小的不平衡，否则会导致恶性循环。 三.建立集群选择片键片键的选择很重要，因为这关系到读操作的速度。以下介绍集中片键的几个常见反例，以便更好理解片键选择。小基数片键假设我们有3个分片，我们需要选择片键。前后端编程开发常见的建站就需要对数据分类，有用户的数据、管理员的数据、网页参数的数据，那为了方便理解和区分，就选择用户、管理员、网页参数3个片键。虽然管理员数据比较小，但用户的数据会一直增加，增加到一定程度后，MongoDB也不能分割分片里的块了，最终磁盘空间被耗尽。由于片键值数量有限，后来，就会得到一个又大又无法移动，还不能分割的块，这对数据管理造成极大的不方便。升序片键对大部分应用程序而言，新数据被访问的次数总是多于老数据，所以人们会尝试诸如时间戳或者objectID一类的字段作为片键。比如，社交软件上的发动态，每条动态包含消息、地点、时间，我们以时间段来分片。从一个数据块开始，随着时间推移，一个块满了，裂变为两个块，时间点继续增加，这个片键创造了一个单一且不可分散的热点。动态被发出，该时间点MongoDB需要对该时间点对应的块进行写操作，而当大量的动态在同一时间发出，MongoDB来不及对块进行写操作，就会造成堵塞，使应用程序瘫痪。随机片键为了避免以上的热点片键，有人选择取随机的字段来分片。采用这种字段开始还不错，但随着数据量的增加，它会变得越来越慢。现在采用随机片键，已经得到一组均匀分布于各分片的数据块。假设分片上的一个块填满并分裂了，配置服务器注意到分片2比分片1多10个块，为了抹平差距，MongoDB就将分片2中的随机5个块（块的数据量的大小不确定）经由内存发送给分片1。随着数据量的增加，这5个随机的块的数据量会很大，应发大量的磁盘IO，致使数据库变慢。好片键准升序键加搜索键快速起步 若想尽快上手，可用Github上的mongos-snippets，其中有个simple-setup.py能自动地启动、配置和生成一个集群，它需要MongoDB的Python驱动。 安装MongoDB的Python驱动sudo easy_install pymongo下载mongos-snippets库并执行以下操作python sharding/simple-setup.py –path=绝对路径 simple-setup.py会启动一个mongos进程，地址为localhost://27017 2017.10.29 pinocchio]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全概略]]></title>
    <url>%2F2017%2F11%2F23%2Fweb%E5%AE%89%E5%85%A8%E6%A6%82%E7%95%A5%2F</url>
    <content type="text"><![CDATA[声明：本文章是在看《白帽子讲web安全》时所做的记录，以供复习攻击方式重点：sql注入 xss 技巧：1.数据库里的登录ID和昵称分开 一.安全世界观1.安全是一个持续过程2.安全三要素2.1机密性2.2完整性2.3可用性 3.安全评估 资产等级划分-&gt;威胁分析-&gt;风险分析-&gt;确认解决方案 3.1资产等级划分3.2威胁分析3.3风险分析3.4确认解决方案 4.白帽子兵法4.1Secure By Default原则4.1.1黑名单、白名单4.1.2最小权限原则4.1.3纵深防御原则4.1.4数据与代码分开原则4.1.5不可预测性原则 二.浏览器安全2.1同源策略2.2浏览器沙箱更新中…… 2017.11.18]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网络安全</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
</search>
