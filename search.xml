<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node要点总结]]></title>
    <url>%2F2018%2F02%2F20%2Fnode%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[node开发技能图1、常用前端技术： html5 css3 jQuery 2、js高级话题： 面向对象 闭包 作用域 设计模式 3、其他后端技术： mongodb redis apache nignix mysql 4、node内置核心库： 全局对象 时事件 流 网络 子程序 5、常用知名第三方库： async express koa 6、node高级话题： 异步 部署 性能调优 异常调试 node事件循环机制* javaScript高级话题(面向对象、作用域、闭包、设计模式)面向对象1、常用js类定义的方法？构造函数原型法： 1234567891011121314151617 function Person () &#123; this.name = 'pinocchio'; &#125; Person.prototype.sayName = function () &#123; alert(this.name);; &#125; var person = new Person (); person.sayName(); 对象创建: var Person = &#123; name: 'pinocchio', sayName: function () &#123; alert(this.name); &#125; &#125;; var person = Object.create(Person); person.sayName(); 2、js类继承的方法？原型链法(Person是Animal的子集，即子类)： 12345678910111213141516171819202122232425262728293031323334 function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125; function Person () &#123;&#125; Person.prototype = Animal.prototype; //人继承动物 Person.prototype = constructor = 'Person'; //更新构造函数为人属性复制法(单纯复制，两者无继承关系)： function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123;&#125; //复制动物所有属性到人 for (prop in Animal.prototype) &#123; Person.prototype[prop] = Animal.prototype[prototype]; &#125; //更新构造函数为人 Person.prototype.constructor = 'Person'; 构造器应用法: function Animal () &#123; this.name = 'animal'; &#125; Animal.prototype.sayName = function () &#123; alter(this.name); &#125;; function Person () &#123; //apply,call,bind方法都行，有细微区别 Animal.call(this); &#125; 3、js类多重继承的方法怎么实现？ 通过类继承里面的属性复制法来实现，可以继承所有父类的prototype属性 作用域 4、js里作用域是什么样？函数作用域， 123456789var globalVar = 'global var';function test() &#123; alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义 var globalVar = 'overrided var'; // globalVar在本函数内被重定义 alert(globalVar); // overrided var&#125;alert(globalVar); // global var，使用全局变量 5、js中this指的是什么？this指的是对象本身 6、apply，call，bind有什么区别？apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； 三者第一个参数都是this要指向的对象，也就是想指定的上下文； 三者都可以利用后续参数传参； apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表 12345678910111213141516function Person () &#123;&#125;Person.prototype.sayName() &#123; alert(this.name);&#125;//普通对象，不是Person实例var obj = &#123; name: 'pinocchio'&#125;;//applyPerson.prototype.sayName.apply(obj, [param1, param2, param3]);//callPerson.prototype.sayName.call(obj, param1, param2, param3);//bind,先绑定，再执行var sn = Person.prototype.sayName.bind(obj);sn([param1, param2, param3]);sn(param1, param2, param3); 7、caller，callee和arguments分别是什么？123456789101112caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．function parent(param1, param2, param3) &#123; child(param1, param2, param3);&#125;function child() &#123; console.log(arguments); // &#123; '0': 'mqin1', '1': 'mqin2', '2': 'mqin3' &#125; console.log(arguments.callee); // [Function: child] console.log(child.caller); // [Function: parent]&#125;parent('mqin1', 'mqin2', 'mqin3'); 闭包8、什么是闭包？闭包有什么用处？通俗的说，闭包就是作用域范围，因为js是函数作用域，所以函数就是闭包．全局函数的作用域范围就是全局，所以无须讨论．更多的应用其实是在内嵌函数，这就会涉及到内嵌作用域，或者叫作用域链。 这就会带来另外一个问题，什么时候引用结束？如果不结束，就会一直占用内存，引起内存泄漏．不用的时候就引用设为空。 9、defineProperty, hasOwnProperty, propertyIsEnumerable都是做什么用的？Object.defineProperty(obj, prop, descriptor)用来给对象定义属性,有value,writable,configurable,enumerable,set/get等.hasOwnProerty用于检查某一属性是不是存在于对象本身，继承来的 父亲的属性不算．propertyIsEnumerable用来检测某一属性是否可遍历，也就是能不能用for..in循环来取到. 设计模式10、js常用设计模式的实现思路，单例，工厂，代理，装饰，观察者模式等1) 单例： 任意对象都是单例，无须特别处理`var obj = {name: &apos;michaelqin&apos;, age: 30};` 2) 工厂: 就是同样形式参数返回不同的实例12345678910111213function Person() &#123; this.name = 'Person1'; &#125;function Animal() &#123; this.name = 'Animal1'; &#125;function Factory() &#123;&#125;Factory.prototype.getInstance = function(className) &#123; return eval('new ' + className + '()');&#125;var factory = new Factory();var obj1 = factory.getInstance('Person');var obj2 = factory.getInstance('Animal');console.log(obj1.name); // Person1console.log(obj2.name); // Animal1 3) 代理: 就是新建个类调用老类的接口,包一下1234567891011121314151617function Person() &#123; &#125;Person.prototype.sayName = function() &#123; console.log('michaelqin'); &#125;Person.prototype.sayAge = function() &#123; console.log(30); &#125;function PersonProxy() &#123; this.person = new Person(); var that = this; this.callMethod = function(functionName) &#123; console.log('before proxy:', functionName); that.person[functionName](); // 代理 console.log('after proxy:', functionName); &#125;&#125;var pp = new PersonProxy();pp.callMethod('sayName'); // 代理调用Person的方法sayName()pp.callMethod('sayAge'); // 代理调用Person的方法sayAge() 4) 观察者: 就是事件模式，比如按钮的onclick这样的应用.12345678910111213141516171819202122232425262728293031323334353637function Publisher() &#123; this.listeners = [];&#125;Publisher.prototype = &#123; 'addListener': function(listener) &#123; this.listeners.push(listener); &#125;, 'removeListener': function(listener) &#123; delete this.listeners[listener]; &#125;, 'notify': function(obj) &#123; for(var i = 0; i &lt; this.listeners.length; i++) &#123; var listener = this.listeners[i]; if (typeof listener !== 'undefined') &#123; listener.process(obj); &#125; &#125; &#125;&#125;; // 发布者function Subscriber() &#123;&#125;Subscriber.prototype = &#123; 'process': function(obj) &#123; console.log(obj); &#125;&#125;; // 订阅者var publisher = new Publisher();publisher.addListener(new Subscriber());publisher.addListener(new Subscriber());publisher.notify(&#123;name: 'michaelqin', ageo: 30&#125;); // 发布一个对象到所有订阅者publisher.notify('2 subscribers will both perform process'); // 发布一个字符串到所有订阅者 11、列举数组相关的常用方法push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter 12、列举字符串相关的常用方法indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase node核心内置库类（事件， 流， 文件， 网络）node概览：1、node架构主要分为三层，应用app &gt;&gt; V8及node内置架构 &gt;&gt; 操作系统. V8是node运行的环境，可以理解为node虚拟机． node内置架构又可分为三层: 核心模块(javascript实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http. 2、node的核心模块EventEmitter, Stream, FS, Net, 全局对象 node全局对象：1、node有哪些全局对象？process、 console、 Buffer 2、process有哪些方法？process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit 3、console有哪些常用方法?console.log/console.info, console.error/console.warning, console.time/console.timeEnd, console.trace, console.table 4、node有哪些定时功能?setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick 5、node中的事件循环是什么样子的?process.nextTick &gt;&gt; setImmidate &gt;&gt; setTimeout/SetInterval 6、node中的Buffer如何应用?Buffer是用来处理二进制数据的，比如图片，mp3,数据库文件等.Buffer支持各种编码解码，二进制字符串互转 EventEmitter:1、什么是EventEmitter?EventEmitter是node中一个实现观察者模式的类，主要功能是监听和发射消息，用于处理多模块交互问题. 2、如何实现一个EventEmitter?主要分三步：定义一个子类， 调用构造函数， 继承EventEmitter 123456789101112131415var util = require('util'), EventEmitter = require('event').EventEmitter;//构造函数function MyEmitter () &#123; EventEmitter.call(this);&#125;//继承util.inherits(MyEmitter, EventEmitter);var em = new MyEmitter();//接受事件em.on('hello', function(data) &#123; console.log('收到事件hello的数据：'， data);&#125;);em.emit('hello', 'EventEmitter传递消息真方便'); 3、EventEmitter有哪些典型应用？模块之间传递消息 回调函数内外传递消息 处理流数据 观察者模式发射触发机制 4、怎么捕获EventEmitter的错误事件？监听error事件即可，若有多个EventEmitter，可用domain来统一处理。 123456789101112var domain = require('domain');var myDomain = domain.create();//接受事件并打印myDomain.on('error', function(err)&#123; console.log('domain接受到的事件', err);&#125;);myDomain.run(function() &#123; var emitter1 = new MyEmitter(); emitter1.emit('error', '错误事件来自emitter1'); var emitter2 = new MyEmitter(); emitter2.emit('error', '错误事件来自emitter2');&#125;); 5、EventEmitter中的newListenser事件有什么用处?newListener可以用来做事件机制的反射，特殊应用，事件管理等．当任何on事件添加到EventEmitter时，就会触发newListener事件，基于这种模式，我们可以做很多自定义处理. 123456789var emitter3 = new MyEmitter();emitter3.on('newListener', function(name, listener) &#123; console.log("新事件的名字:", name); console.log("新事件的代码:", listener); setTimeout(function()&#123; console.log("我是自定义延时处理机制"); &#125;, 1000);&#125;);emitter3.on('hello', function()&#123; console.log('hello node');&#125;); Streamstream是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，主要包括可写，可读，可读写，可转换等几种类型． 1、Stream有什么好处？非阻塞式数据处理提升效率，片段处理节省内存，管道处理方便扩展 2、Stream有哪些典型应用？文件处理、网络交换、数据转换、音视频处理 3、怎么捕获Stream的错误事件？监听error事件、方法同EventEmitter 4、哪些常用Stream，分别什么时候用？Readable为可被读流，在座位数据源时使用； Writeable为可被读流，在作为输出元时使用； Duplex为读写流，作为输入源接受被写入，同时又作为输入源被后面的流读出； Transform机制和Duplex一样，都是双向流，区别时Transfrom只需要实现一个函数_transfrom(chunk, encoding, callback); 而Duplex需要分别实现_read(size)函数和_write(chunk, encoding, callback)函数. 5、实现一个Writable Stream?三步走:1)构造函数call Writable 2) 继承Writable 3) 实现_write(chunk, encoding, callback)函数 ``` var Writeable = require(&apos;stream&apos;).Writable; var util = require(&apos;util&apos;); //构造函数 function MyWriteable(options) { Writeable.call(this, options); } //继承Writeable util.inherits(MyWriteable, Writable); MyWritable.prototype._write = function(chunk, encoding, callback) { // 此处可对写入的数据进行处理 console.log(&quot;被写入的数据是:&quot;, chunk.toString()); callback(); }; // stdin作为输入源，MyWritable作为输出源 process.stdin.pipe(new MyWritable()); ``` node高级话题(异步， 部署， 性能调优， 异步调试)1、node中的异步与同步怎么理解？node是单线程的，异步是通过一次次的事件循环来实现的。 同步则是阻塞式的io，在高并发环境下会有很大的性能问题，所以同步一般只在基础框架的启动时使用，如：加载配置文件、初始化程序 2、哪些方法可以进行异步流程控制？1）多层嵌套回调 2）单独为回调写函数，函数里再回调 3)第三方框架：async、q、promise 3、怎么绑定node程序到80端口？1）sudo 2）Apache/nginx代理 3）操作系统的firewall iptables端口绑定 4）第三方库up 4、有哪些方法可以让node程序遇到错误后自动重启?1) runit 2) forever 3) nohup npm start &amp; 4）up -watch -port 80 server.js 5、怎么充分利用多个cpu？1个cpu运行一个node程序 6、怎样调节node执行单元的内存大小?用--max-old-space-size 和 --max-new-space-size 来设置 v8 使用内存的上限 7、有哪些常用方法可以防止程序崩溃?1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试 8、怎样调试node程序?1) 监听错误事件req.on(&apos;error&apos;, function(){}), 适用EventEmitter存在的情况; 2) Promise.then.catch(error),适用Promise存在的情况 3) try-catch,适用async-await和js运行时异常，比如undefined object]]></content>
      <categories>
        <category>node笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>笔记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable详解及React中实践]]></title>
    <url>%2F2017%2F12%2F17%2FImmutable%E8%AF%A6%E8%A7%A3%E5%8F%8AReact%E4%B8%AD%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1、js中数据可变状态概念：js中的对象一般是可变的，由于使用了引用赋值，新的对象简单的引用了原始的对象，改变的新对象将影响到原始对 象。 例如： 1234foo = &#123;a:1&#125;;bar = foo;bar.a = 2;console.log(foor.a); //输出2 优缺点：优点：节约内存 缺点：当应用复杂后，会造成非常大的隐患 解决办法：shallowCopy（浅拷贝），deepCopy（深拷贝） 两种方法可将对象置为不可变对象，但同时也造成cpu和内存的浪费 2、Immutable.Data]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Immutable</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React笔记]]></title>
    <url>%2F2017%2F12%2F17%2FReact%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据类型 state/props state—组件本身的数据 props—从其他组件传入的组件 生命周期 getDefaultProps //获得默认数据 getInitialState //设置State数据 componentWillMount //在component即将挂在到页面上时 render componentDidMount //ui真正挂载到文档流 componentWillUnmount //文件销毁 组件间通信 widget之间通过props通信 子组件与父组件的通信 事件订阅 React-router url模式： browserHistory //yoursite.com/a/b hashHistory //yoursite.com/#a/b 两种组件：（装载页面的组件） IndexRouter //默认（没有存url） Router 写法： &lt; Link to = “url”&gt; 注释： 页面切换时，组件会被销毁，再次进入时重新加载。若要实现某功能一直运行，不受页面切换的影响，则将该功 能置于根节点上。 事件订阅 //TODO:完善整个概念]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记，React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fwebpack%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[webpack使用中的错误：1.npm run dev 出错打包错误in ./src/index.js12345Module build failed: TypeError: fileSystem.statSync is not a function at module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/utils/exists.js:7:25) at find (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/resolve-rc.js:13:9) at Object.module.exports (/home/zaizizaizai/computerscience/project/react/ToDoList/node_modules/babel-loader/lib/index.js:113:132) @ multi main 原因及解决方法：babel-loader7.x版本与webpack1.x不兼容，将babel-loader版本降到6.x]]></content>
      <categories>
        <category>webpack笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node笔记]]></title>
    <url>%2F2017%2F12%2F13%2Fnode%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装以及升级node，npm：1.安装nodejssudo apt install nodejs-legacy2.安装npmsudo apt install npm3.清楚cachesudo npm cache clean -f4.安装n包sudo npm install -g n5.获取nodejs稳定版sudo n stable6.升级npmsudo npm install -g npm]]></content>
      <categories>
        <category>node笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记]]></title>
    <url>%2F2017%2F12%2F13%2FGit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[显示仓库中的页面1、把文件放在**.github.io仓库2、在文件路径前面加http://htmlpreview.github.io/?然后访问，如： http://htmlpreview.github.io/?https://github.com/**/example/index.html]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu笔记]]></title>
    <url>%2F2017%2F12%2F13%2FUbuntu%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[系统操作：1.在图形化界面下获取最高权限 sudo nautilus2.显示/隐藏文件 Ctrl+hnpm:1.在使用npm下载包的时候出现无权限修改文件问题 在npm前面加上sudo2017-09-25]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电梯模拟程序]]></title>
    <url>%2F2017%2F11%2F27%2F%E7%94%B5%E6%A2%AF%E6%A8%A1%E6%8B%9F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[whim今天在等电梯的时候，突然对电梯工作流程感兴趣，想写个电梯模拟小程序。先来占个坑，写个大致思路,等考完试再来完成 //这楼有20层int max_floor = 20; 楼层构造一个类12345678//楼层class floor &#123; private: //楼层 int floor = 0; //有人上1，还是下2,或是没人按电梯0 int uds = 0；&#125; 电梯构造一个类1234567891011121314//电梯class elevator &#123; private: int current_floor = 0; //三个状态，上升1，下降2，静止0 int uds = 0; public: //上升 void up(); //下降 void down(); //判断电梯上升还是下降 void UpDown(); &#125; 判断函数构造一个类因为有两个电梯，所以把判断函数拿出来单独构造一个类。123456//判断电梯哪个电梯去载人，上升还是下降class select &#123; public: //判断哪个电梯去载人 void which（）；&#125; 函数部分1234567891011121314151617void elevator::up()&#123; //用参数判断是否到达 int arrived = 0; for (int i = 1; i &lt;= 20; i++)&#123; //判断是否到达目的楼层(类之间引用问题) if(current_floor != floor.floor)&#123; current_floor++; &#125;else &#123; arrived = 1; continue; &#125; &#125; return arrived;&#125; 大致思路就先写到这，后续加上。 真的蛮好玩诶！]]></content>
      <categories>
        <category>whim</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>whim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+mysql实现小型web后台程序]]></title>
    <url>%2F2017%2F11%2F26%2Fnodejs-mysql%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9E%8Bweb%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[项目地址主要实现功能：1.用户名密码登录2.增删改查管理员发布的网页数据 具体小功能：1.对用户名数据进行哈希加密（签名）2.强制登录页面（重定向）3.浏览器与服务器传输数据 图片界面丑了点，当时主要把后台功能搭起来，功能基本齐全，后面会把界面做起来登录界面 首页 发布信息 用户评价 项目结构： /server.js其功能是建服务器监听8080端口。具体代码： 1234567891011121314151617181920212223242526272829303132333435var server=express();server.listen(8080);//1.获取请求数据//get自带server.use(bodyParser.urlencoded());server.use(multerObj.any());//2.cookie、sessionserver.use(cookieParser());(function ()&#123; var keys=[]; for(var i=0;i&lt;100000;i++)&#123; keys[i]='a_'+Math.random(); &#125; server.use(cookieSession(&#123; name: 'sess_id', keys: keys, maxAge: 20*60*1000 //20min &#125;));&#125;)();//3.模板server.engine('html', consolidate.ejs);server.set('views', 'template');server.set('view engine', 'html');//4.routeserver.use('/', require('./route/web')());server.use('/admin/', require('./route/admin')());//5.default：staticserver.use(static('./static/'));console.log('server is running at port 8080...'); 各段代码作用如下：1.解析请求数据2.并发给请求方cookie，3.声明调用的模板4.路由功能，区分请求并转入相应界面5.处理静态文件请求 /libs/common.js该文件封装模板，其功能是将登录时的用户输入的用户名密码等数据用哈希算法加密（签名），让该数据不可见，避免他人获取用户名密码。代码如下： 1234567 MD5_SUFFIX: '*****',md5: function (str)&#123; var obj=crypto.createHash('md5'); obj.update(str); return obj.digest('hex'); 其中，MD5_SUFFIX加在数据后面，再进行md5加密，该MD5_SUFFIX是自定义的数据的 /route/index.js在服务器运行后，服务器一直监听8080端口，当有请求访问，首先对该用户的登录状态和请求进行判定，如果不是管理员，就重定向返回登录界面。如果想访问其他页面，也不行，重定向回登录界面。只有当既是管理员，请求访问的又是登录界面才对请求予以响应。 123456789//检查登录状态 router.use((req, res, next)=&gt;&#123; if(!req.session['admin_id'] &amp;&amp; req.url!='/login')&#123; //没有登录 //转向登录界面(重定向) res.redirect('/admin/login'); &#125;else&#123; next(); &#125; &#125;); 如果已确定是管理员，就再来判定其访问请求。 1234//根据不同http请求，转向不同页面router.use('/login', require('./login')());router.use('/banners', require('./banners')());router.use('/custom',require('./custom')()); /route/login.js那是怎么判断是否为管理员？ 当管理员登录时，后台就拿着页面获取的用户名密码和数据库的进行比对，成功就给浏览器发session，不成功就不发，判定管理员的时候就是看有没有session。为什么不直接不直接用用户名密码验证，而要再加一个session？ session可以理解为cookie的加强版，具有生存期，可以控制用户在一定时间内免登陆。若采用用户名密码验证，那每 退一次，就得输入一次密码，这在实际操作中是很不方便的。 12345if(data[0].password==password)&#123; //成功 req.session['admin_id']=data[0].ID; res.redirect('/admin/'); &#125; route和template登录后，就对数据进行操作。route和template分别是存放js和静态文件的文件夹，文件夹内的js文件实现的功能相似，都是将页面和数据库连接起来，对数据进行增删改查的操作。就banners页面来说，其具体代码如下： 12//连接数据库var db=mysql.createPool(&#123;host: 'localhost', user: 'root', password: '***', database: 'learner'&#125;); 修改banner数据 1234567891011121314151617db.query(`SELECT * FROM banner_table WHERE id=$&#123;req.query.id&#125;`, (err, data)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else if(data.length==0)&#123; res.status(404).send('data not found').end(); &#125;else&#123; db.query('SELECT * FROM banner_table', (err, banners)=&gt;&#123; if(err)&#123; console.error(err); res.status(500).send('database error').end(); &#125;else&#123; res.render('admin/banners.ejs', &#123;banners, mod_data: data[0]&#125;); &#125; &#125;); &#125;&#125;); 其他数据操作功能同理]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm重新安装模块]]></title>
    <url>%2F2017%2F11%2F26%2Fnpm%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[npm删除模块，重新安装错误经过 使用hexo模块的时候，不小心将已经配置好的blog文件删除。在网上查找资料，运行npm cache clean –force，出现错误（不能使用hexo命令）。然后我就准备重装hexo，把usr/bin和local里hexo相关文件删除，用npm重新下载hexo，但还是和之前一样出错 解决 需要删除hexo相关文件和packagejson里的依赖，再重新下载hexo，就可以使用了 具体位置（linux环境）：/home/zaizizaizai/.npm-global/bin和/home/zaizizaizai/.npm-global/lib 补充：此路径为隐藏目录，在home区需要按快捷键ctrl+h显示隐藏文件，或者通过命令行进行操作]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应网页设计]]></title>
    <url>%2F2017%2F11%2F26%2F%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[点我转向原文章转译：pinocchio对于初入前端的学习者来说，设计网页自适应不同分辨率的终端是比较难解决的一件事。自适应网页设计指的是可以自动识别屏幕宽度、并做出相应调整的网页设计。 以下是自适应网页设计的方法： 一、允许网页宽度自动调整 在网页代码的头部，加入viewport元标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device- width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 所有主流浏览器(IE9)都支持这个设置。对于老式浏览器（IE6、7、8），需要使用css3-mediaqueries.js。 二、不使用绝对宽度 若在头部加入了viewport元标签，网页会自动更具屏幕宽度调整布局，所以不能使用具有绝对宽度的元素。 即css代码不能制定像素宽度 width:xxx px; 只能使用百分比宽度 width: xx%; 或者 width:auto; 三、相对大小的字体 字体也不能使用绝对大小（px），而只能使用相对大小（em）。 123body &#123; font: normal 100% Helvetica, Arial, sans-serif; &#125; 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 123 h1 &#123; font-size: 1.5em; &#125; 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 123 small &#123; font-size: 0.875em; &#125; 四、流动布局（fluid grid） “流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 123456789.main &#123; float: right; width: 70%;&#125;.leftBar &#123; float: left; width: 25%;&#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向 overflow（溢出），避免了水平滚动条的出现。 五、选择加载css “自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123&lt;link rel="stylesheet" type="text/css" media="screen and (max-device-width: 400px)" href="tinyScreen.css" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 123 &lt;link rel="stylesheet" type="text/css" media="screen and (min-width: 400px) and (max-device-width: 600px)" href="smallScreen.css" /&gt; 如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 1 @import url("tinyScreen.css") screen and (max-device-width: 400px); 六、CSS的@media规则 同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 12345678910 @media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 七、图片的自适应（fluid image） 除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。 这只要一行CSS代码： img { max-width: 100%;} 这行代码对于大多数嵌入网页的视频也有效，所以可以写成： img, object { max-width: 100%;} 老版本的IE不支持max-width，所以只好写成： img { width: 100%; } 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： img { -ms-interpolation-mode: bicubic; } 或者，Ethan Marcotte的imgSizer.js。 1234 addLoadEvent(function() &#123; var imgs = document.getElementById("content").getElementsByTagName("img"); imgSizer.collate(imgs); &#125;);]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>转载</tag>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博客评论说明由于多说、跟帖等评论插件都倒了，就转向了友言。结果友言服务器是国外的，得翻墙才能用。就转向了畅言，可是这搜狐畅言得用域名（我怕还没来的及买域名了-_-）。最后还是回到大爱的git了。过程：多说、跟帖–&gt;友言–&gt;畅言–&gt;gitment 2017-11-23]]></content>
      <categories>
        <category>博客说明</category>
      </categories>
      <tags>
        <tag>博客说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解MongoDB]]></title>
    <url>%2F2017%2F11%2F23%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MongoDB%2F</url>
    <content type="text"><![CDATA[这是在我看完《深入理解MongoDB》后，按照自己的理解记录下来的笔记，初次接触，若有错误，敬请指出，感谢！ 一.概述MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB操作模式：应用程序&lt;=&gt;mongos&lt;=&gt;集群 二.理解分片1.什么是分片（sharding）？分片（sharding）是MongoDB用来将大型集合分割到不同服务器上采用的方法。这样做是为实现3个目标：让集群“不可见”让应用程序知道要执行任何“增删改查”操作只需要发送请求给MongoDB这一个对象就行了，剩下的事就交给它了，不需要区分交给那个服务器，简化了应用程序端操作指令。在MongoDB中具体连接客户端与服务器端的就是叫做mongos的专有路由进程，mongos可以比喻为一个秘书，转发客户端的请求，和服务器端的响应。保证集群总是可以读写一个大的集合分为多个分片（shard），当其中一个进程/服务器出现问题，由运行在其他分区的其他副本接替换掉的部分继续工作。使集群易于扩展将大的集群分割为多个小的分区，当需要资源的时候，只需要添加小的空间。 2.分配数据sharding操作后得到分片（shard）是集群中负责数据某一子集的一台或多台服务器。换言之，一个分片包含数据的某个子集。例如一个集群包含1000份代表网站注册用户文档，其中一个分片就可能包含200份。若一个分片包含多个服务器，则每个服务器拥有一份完整的数据副本。 一分片一区间分配数据最简单的方法就是让一分片负责一区间的数据。假设有四个分片，依次对应[“a”,”f”),[“f”,”n”),[“n”,”t”),[“t”,”{“)区间，{是ASCII码表中字母z后面的字符。许多用户用首字母在范围[“a”,”f”)中的名字来注册，就导致分片1较大，我们可以调整区间使分片1对应的区间缩小，从而让分片均衡。但当分片1和分片2过载时，就不太好处理。假设分片1和分片2各有500G数据，分片3和分片4各有300G数据，此时就需要分片1转移100G数据到分片2，接着从分片2转移200G数据到分片3，最后分片3转移100G数据到分片4，从而使每个分片都具有400G数据，达到均衡。这还只是4个分片，执行这个操作一共移动了400G数据。当考虑到所有分片，可想需要移动的数据量是很大的。 一分片多区间重新来考虑上面的情况，此时是一分片多区间。我们可以把分片1和分片2都划分为两个区间，分片1分别对应包含400G数据的[“a”,”d”)区间和包含100G数据的[“d”,”f”)区间，分片2分别对应包含400G数据[“f”,”j”)区间和100G数据[“j”,”n”)区间。我们就可以把分片1中的[“d”,”f”)区间的数据直接移动到分片3，把分片2中的[“,j”,”n”)区间的数据直接移动到分片4，相比上一种情况，只需要移动200G数据。添加新的分片也具有同样的优势——减少数据转移量。 创建块一个区间的数据成为一个数据块（也叫块，chunk），块默认大小为200MB（兼顾可移动性和最小开销），当一个块的区间一分为二是，就变成两个块了。当提到块出不得不说片键了，如下所示{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}{“username”:”zaizizaizai”,”age”:16}如果我们选择age字段作为片键病得到一个块区间[20,30），则得到的块为：{“username”:”gala”,”age”:21}{“username”:”pinocchio”,”age”:25}可以把片键理解为一个选择器（标签），也可理解为属性，即挑选符合条件的数据，在这里不仅局限于把age作为片键，username也可以作为片键，且片键值不可修改。随着数据的增加，当一个块变大，MongoDB会自动将其分割为2个小块。若分片间数据比例失衡，MongoDB会迁移块其他分片（由叫做平衡器的进程执行），以达到分片间数据比例总是平衡的状态。同时平衡器会忽略微小的不平衡，否则会导致恶性循环。 三.建立集群选择片键片键的选择很重要，因为这关系到读操作的速度。以下介绍集中片键的几个常见反例，以便更好理解片键选择。小基数片键假设我们有3个分片，我们需要选择片键。前后端编程开发常见的建站就需要对数据分类，有用户的数据、管理员的数据、网页参数的数据，那为了方便理解和区分，就选择用户、管理员、网页参数3个片键。虽然管理员数据比较小，但用户的数据会一直增加，增加到一定程度后，MongoDB也不能分割分片里的块了，最终磁盘空间被耗尽。由于片键值数量有限，后来，就会得到一个又大又无法移动，还不能分割的块，这对数据管理造成极大的不方便。升序片键对大部分应用程序而言，新数据被访问的次数总是多于老数据，所以人们会尝试诸如时间戳或者objectID一类的字段作为片键。比如，社交软件上的发动态，每条动态包含消息、地点、时间，我们以时间段来分片。从一个数据块开始，随着时间推移，一个块满了，裂变为两个块，时间点继续增加，这个片键创造了一个单一且不可分散的热点。动态被发出，该时间点MongoDB需要对该时间点对应的块进行写操作，而当大量的动态在同一时间发出，MongoDB来不及对块进行写操作，就会造成堵塞，使应用程序瘫痪。随机片键为了避免以上的热点片键，有人选择取随机的字段来分片。采用这种字段开始还不错，但随着数据量的增加，它会变得越来越慢。现在采用随机片键，已经得到一组均匀分布于各分片的数据块。假设分片上的一个块填满并分裂了，配置服务器注意到分片2比分片1多10个块，为了抹平差距，MongoDB就将分片2中的随机5个块（块的数据量的大小不确定）经由内存发送给分片1。随着数据量的增加，这5个随机的块的数据量会很大，应发大量的磁盘IO，致使数据库变慢。好片键准升序键加搜索键快速起步 若想尽快上手，可用Github上的mongos-snippets，其中有个simple-setup.py能自动地启动、配置和生成一个集群，它需要MongoDB的Python驱动。 安装MongoDB的Python驱动sudo easy_install pymongo下载mongos-snippets库并执行以下操作python sharding/simple-setup.py –path=绝对路径 simple-setup.py会启动一个mongos进程，地址为localhost://27017 2017.10.29 pinocchio]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>书籍</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全概略]]></title>
    <url>%2F2017%2F11%2F23%2Fweb%E5%AE%89%E5%85%A8%E6%A6%82%E7%95%A5%2F</url>
    <content type="text"><![CDATA[声明：本文章是在看《白帽子讲web安全》时所做的记录，以供复习攻击方式重点：sql注入 xss 技巧：1.数据库里的登录ID和昵称分开 一.安全世界观1.安全是一个持续过程2.安全三要素2.1机密性2.2完整性2.3可用性 3.安全评估 资产等级划分-&gt;威胁分析-&gt;风险分析-&gt;确认解决方案 3.1资产等级划分3.2威胁分析3.3风险分析3.4确认解决方案 4.白帽子兵法4.1Secure By Default原则4.1.1黑名单、白名单4.1.2最小权限原则4.1.3纵深防御原则4.1.4数据与代码分开原则4.1.5不可预测性原则 二.浏览器安全2.1同源策略2.2浏览器沙箱更新中…… 2017.11.18]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>网络安全</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于成功了]]></title>
    <url>%2F2017%2F11%2F22%2F%E7%BB%88%E4%BA%8E%E6%88%90%E5%8A%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[应该好了把额，刚接触hexo，之前在csdn上写，文章格式还没弄好，见谅！ 后续把文章补上…^@^]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
</search>
